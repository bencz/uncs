// sscli20_20060311

// ==++==
//
//   
//    Copyright (c) 2006 Microsoft Corporation.  All rights reserved.
//   
//    The use and distribution terms for this software are contained in the file
//    named license.txt, which can be found in the root of this distribution.
//    By using this software in any fashion, you are agreeing to be bound by the
//    terms of this license.
//   
//    You must not remove this notice, or any other, from this software.
//   
//
// ==--==
// ===========================================================================
// File: fncbind.h
//
// Defines the structure which contains information necessary to bind and generate
// code for a single function.
// ===========================================================================

// ==++==
//
//   
//    Copyright (c) 2006 Microsoft Corporation.  All rights reserved.
//   
//    The use and distribution terms for this software are contained in the file
//    named license.txt, which can be found in the root of this distribution.
//    By using this software in any fashion, you are agreeing to be bound by the
//    terms of this license.
//   
//    You must not remove this notice, or any other, from this software.
//   
//
// ==--==
// ===========================================================================
// File: fncpbind.cpp
//
// Routines for analyzing the bound body of a function
// ===========================================================================

//============================================================================
// FncBind.cs
//
// 2015/04/20 hirano567@hotmail.co.jp
//============================================================================
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Reflection;
using System.Reflection.Emit;

namespace Uncs
{
    //======================================================================
    // interface ICompileCallback
    //
    /// <summary>
    /// <para>Callack interface from binding</para>
    /// <para>Implemented by class CCompileCallbackAdapter, class CCompileCallbackForward</para>
    /// </summary>
    /// <remarks>
    /// NOTE: This is NOT a IUnknown interface!
    /// </remarks>
    //======================================================================
    internal interface ICompileCallback
    {
        // Used by extract method for reachability processing

        bool IsStartStatementNode(BASENODE node);
        bool IsEndStatementNode(BASENODE node);
        void DelimCreated(EXPRDELIM delim);
        void StartPostBinding(EXPRBLOCK block);
        void ProcessExpression(EXPR expr, BitSet bset);
        void EndPostBinding(EXPRBLOCK block);

        // CAlled when a using node
        // in the specified namespace decalration is bound to pSym

        void ResolvedUsingNode(NSDECLSYM nsDeclSym, USINGNODE usingSym, SYM sym);

        // called when we successfully bind to something
        // in the sym provided by a using in the specified namespace declaration

        void BoundToUsing(NSDECLSYM nsDeclSym, SYM sym);

        bool CheckForNameSimplification();
        void CanSimplifyName(CSourceData data, BINOPNODE node);
        void CanSimplifyNameToPredefinedType(CSourceData sourceData, BASENODE node, TYPESYM pType);
    }

    //======================================================================
    // class CCompileCallbackAdapter
    //
    /// <summary>
    /// Callack interface from binding
    /// </summary>
    /// <remarks>
    /// NOTE: This is NOT a IUnknown interface!
    /// </remarks>
    //======================================================================
    internal class CCompileCallbackAdapter : ICompileCallback
    {
        virtual public bool IsStartStatementNode(BASENODE node) { return false; }
        virtual public bool IsEndStatementNode(BASENODE node) { return false; }
        virtual public void DelimCreated(EXPRDELIM delim) { }
        virtual public void StartPostBinding(EXPRBLOCK block) { }
        virtual public void ProcessExpression(EXPR expr, BitSet bset) { }
        virtual public void EndPostBinding(EXPRBLOCK block) { }

        virtual public void ResolvedUsingNode(NSDECLSYM nsDeclSym, USINGNODE usingSym, SYM sym) { }
        virtual public void BoundToUsing(NSDECLSYM nsDeclSym, SYM sym) { }
        virtual public bool CheckForNameSimplification() { return false; }
        virtual public void CanSimplifyName(CSourceData data, BINOPNODE node) { }
        virtual public void CanSimplifyNameToPredefinedType(
            CSourceData pData, BASENODE node, TYPESYM typeSym) { }
    }

    //======================================================================
    // class CCompileCallbackForward
    //
    /// <summary>
    /// This member is used only in the context of ExtractMethodSignature to find out
    /// if the last statement of the list of selected statements is reachable or not.
    /// </summary>
    //======================================================================
    internal class CCompileCallbackForward : ICompileCallback
    {
        //------------------------------------------------------------
        // CCompileCallbackForward Fields and Properties
        //------------------------------------------------------------
        protected ICompileCallback bindCallback = null;

        //------------------------------------------------------------
        // CCompileCallbackForward Constructor
        //
        /// <summary></summary>
        //------------------------------------------------------------
        internal CCompileCallbackForward()
        {
            Reset();
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.Reset
        //
        /// <summary></summary>
        //------------------------------------------------------------
        internal void Reset()
        {
            bindCallback = null;
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.Init
        //
        /// <summary></summary>
        /// <param name="bindCallback"></param>
        //------------------------------------------------------------
        internal void Init(ICompileCallback bindCallback)
        {
            this.bindCallback = bindCallback;
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.IsForwarding
        //
        /// <summary>
        /// True if field bindCallback is not null.
        /// </summary>
        /// <returns></returns>
        //------------------------------------------------------------
        internal bool IsForwarding()
        {
            return (bindCallback != null);
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.GetTarget
        //
        /// <summary></summary>
        /// <returns></returns>
        //------------------------------------------------------------
        internal ICompileCallback GetTarget()
        {
            return bindCallback;
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.ForcePostBind
        //
        /// <summary></summary>
        /// <returns></returns>
        //------------------------------------------------------------
        internal bool ForcePostBind()
        {
            return IsForwarding();
        }

        // CCompileCallbackForward implementing IBindCallback

        //------------------------------------------------------------
        // CCompileCallbackForward.IsStartStatementNode
        //
        /// <summary></summary>
        /// <param name="node"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        public bool IsStartStatementNode(BASENODE node)
        {
            return bindCallback != null && bindCallback.IsStartStatementNode(node);
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.IsEndStatementNode
        //
        /// <summary></summary>
        /// <param name="node"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        public bool IsEndStatementNode(BASENODE node)
        {
            return bindCallback != null && bindCallback.IsEndStatementNode(node);
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.DelimCreated
        //------------------------------------------------------------
        public void DelimCreated(EXPRDELIM delim)
        {
            if (bindCallback != null)
                bindCallback.DelimCreated(delim);
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.StartPostBinding
        //------------------------------------------------------------
        public void StartPostBinding(EXPRBLOCK block)
        {
            if (bindCallback != null)
                bindCallback.StartPostBinding(block);
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.ProcessExpression
        //------------------------------------------------------------
        public void ProcessExpression(EXPR expr, BitSet bset)
        {
            if (bindCallback != null)
                bindCallback.ProcessExpression(expr, bset);
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.EndPostBinding
        //------------------------------------------------------------
        public void EndPostBinding(EXPRBLOCK block)
        {
            if (bindCallback != null)
                bindCallback.EndPostBinding(block);
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.ResolvedUsingNode
        //------------------------------------------------------------
        public void ResolvedUsingNode(NSDECLSYM nsDeclSym, USINGNODE pUsing, SYM sym)
        {
            if (bindCallback != null)
                bindCallback.ResolvedUsingNode(nsDeclSym, pUsing, sym);
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.BoundToUsing
        //------------------------------------------------------------
        public void BoundToUsing(NSDECLSYM nsDeclSym, SYM sym)
        {
            if (bindCallback != null)
                bindCallback.BoundToUsing(nsDeclSym, sym);
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.CheckForNameSimplification
        //------------------------------------------------------------
        public bool CheckForNameSimplification()
        {
            if (bindCallback != null)
                return bindCallback.CheckForNameSimplification();
            return false;
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.CanSimplifyName
        //------------------------------------------------------------
        public void CanSimplifyName(CSourceData data, BINOPNODE node)
        {
            if (bindCallback != null)
                bindCallback.CanSimplifyName(data, node);
        }

        //------------------------------------------------------------
        // CCompileCallbackForward.CanSimplifyNameToPredefinedType
        //------------------------------------------------------------
        public void CanSimplifyNameToPredefinedType(CSourceData data, BASENODE node, TYPESYM pType)
        {
            if (bindCallback != null)
                bindCallback.CanSimplifyNameToPredefinedType(data, node, pType);
        }
    }

    // inline functions must be included here so they can be picked-up by metaattr.cpp
    // so the definitions are at the end of this header

    //======================================================================
    // class LOOPLABELS
    //======================================================================
    internal class LOOPLABELS
    {
        //------------------------------------------------------------
        // LOOPLABELS   Fields and Properties
        //------------------------------------------------------------
        internal EXPRLABEL ContinueLabel = null;    // * contLabel
        internal EXPRLABEL BreakLabel = null;       // * breakLabel

        //------------------------------------------------------------
        // LOOPLABELS   Constructor (1)
        //------------------------------------------------------------
        internal LOOPLABELS() { }

        //------------------------------------------------------------
        // LOOPLABELS   Constructor (2)
        //
        /// <summary>
        /// constructor for the struct which holds the current break and continue labels...
        /// </summary>
        /// <param name="binder"></param>
        //------------------------------------------------------------
        internal LOOPLABELS(FUNCBREC binder)
        {
            this.BreakLabel = binder.NewExprLabel();
            this.ContinueLabel = binder.NewExprLabel();
            binder.LoopLabels = this;
        }
    }

    //======================================================================
    // class CHECKEDCONTEXT
    //
    /// <summary>
    /// <para>Has two boolean fields, IsNormal, IsConstant.</para>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    internal class CHECKEDCONTEXT
    {
        //------------------------------------------------------------
        // CHECKEDCONTEXT Fields and Properties
        //------------------------------------------------------------
        internal bool IsNormal;     // normal
        internal bool IsConstant;   // constant

        //------------------------------------------------------------
        // CHECKEDCONTEXT Constructor (1)
        //------------------------------------------------------------
        internal CHECKEDCONTEXT() { }

        //------------------------------------------------------------
        // CHECKEDCONTEXT Constructor (2)
        //------------------------------------------------------------
        internal CHECKEDCONTEXT(FUNCBREC binder, bool isChecked)
        {
            this.IsNormal = binder.CheckedContext.IsNormal;
            this.IsConstant = binder.CheckedContext.IsConstant;

            binder.CheckedContext.IsNormal = binder.CheckedContext.IsConstant = isChecked;
        }

        //------------------------------------------------------------
        // CHECKEDCONTEXT.Restore
        //------------------------------------------------------------
        internal void Restore(FUNCBREC binder)
        {
            binder.CheckedContext.IsNormal = this.IsNormal;
            binder.CheckedContext.IsConstant = this.IsConstant;
        }
    }

    //======================================================================
    // METHLIST
    //
    /// <summary>
    /// <para>Used to string together methods in the pool of available methods...</para>
    /// <para>Has a MethPropWithInst field and some data.</para>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    internal class METHLIST
    {
        internal MethPropWithInst MethPropWithInst = new MethPropWithInst();    // MethPropWithInst mpwi;

        /// <summary>
        /// params is the result of type variable substitution on either mpwi.MethProp().params or
        /// an expansion of mpwi.MethProp().params (for a param array).
        /// </summary>
        internal TypeArray ParameterTypes = null;    // TypeArray * params;

        /// <summary>
        /// How many parameter types are lifted (for tie-breaking).
        /// </summary>
        internal int LiftedTypeCount = 0;   // byte ctypeLift;

        /// <summary>
        /// Whether the params came from expanding mpwi.MethProp().params.
        /// </summary>
        internal bool IsExpanded = false;   // bool fExpanded;

        internal METHLIST Next = null;  // METHLIST * next;
    }

    //======================================================================
    // class AnonMethInfo
    //
    /// <summary>
    /// One of these for each anonymous method.
    /// </summary>
    //======================================================================
    internal class AnonMethInfo
    {
        /// <summary>
        /// The outer (containing) anonymous method.
        /// </summary>
        internal AnonMethInfo OuterInfo = null;  // * pamiOuter;

        /// <summary>
        /// The next (sibling) one.
        /// </summary>
        internal AnonMethInfo NextInfo = null;   // * pamiNext;

        /// <summary>
        /// The first child (contained) anonymous method.
        /// </summary>
        internal AnonMethInfo ChildInfo = null;    // * pamiChild;

        /// <summary>
        /// The parse tree.
        /// </summary>
        internal BASENODE ParseTreeNode = null; // * tree;

        /// <summary>
        /// The unique method name to use.
        /// </summary>
        internal string Name = null;    // * name;

        /// <summary>
        /// The parameter types - if given.
        /// </summary>
        internal TypeArray ParameterArray = null;   // * params

        /// <summary>
        /// The EK_LIST combined return statements.
        /// </summary>
        internal EXPR ReturnExprList = null;    // EXPR * listReturns;

        /// <summary>
        /// The list building pointer.
        /// </summary>
        internal EXPR ReturnExprListLast = null;    //EXPR** pexprListRet;

        /// <summary>
        /// The return type of the delegate type.
        /// This is in terms of user symbols - no fabricated type variables.
        /// </summary>
        internal TYPESYM ReturnTypeSym = null;  // * typeRet;

        /// <summary>
        /// EXPR for  body of the anonymous delgate
        /// </summary>
        internal EXPRBLOCK BodyBlockExpr = null;    // * pBodyExpr;

        /// <summary>
        /// The scope containing the names of the parameters
        /// </summary>
        internal SCOPESYM ParametersScopeSym = null;    // * pArgs;

        /// <summary>
        /// The local or static used to cache this anonymous delegate
        /// </summary>
        internal EXPR DelegateCacheExpr = null; // * pCachedDelegate;

        /// <summary>
        /// The delegate type of this anonymous method
        /// </summary>
        internal AGGTYPESYM DelegateTypeSym = null;    // * pDelegateType;

        /// <summary>
        /// The scope that will hold this AM
        /// </summary>
        internal SCOPESYM ScopeSym = null;  // * pScope;

        /// <summary>
        /// The &lt;this&gt; local inside the anonymous method
        /// </summary>
        internal LOCVARSYM ThisPointerSym = null;  // * thisPointer;

        /// <summary>
        /// Whether this anon meth uses locals / parameters from an outer method
        /// </summary>
        internal bool UsesLocals = false;   // fUsesLocals;

        /// <summary>
        /// Whether this anon meth uses the <this> pointer of the outer method
        /// </summary>
        internal bool UsesThis = false; // fUsesThis;

        /// <summary>
        /// has a return inside of a try or catch (inside this anonymous method)
        /// </summary>
        internal bool HasReturnAsLeave = false; // fHasRetAsLeave;

        /// <summary>
        /// Whether this anon method is in the final expr tree.
        /// </summary>
        internal bool Seen = false; // fSeen;

        /// <summary>
        /// Whether this anon method is directly in a field initializer or base ctor invocation.
        /// </summary>
        internal bool IsInCtorPreamble = false;     // fInCtorPreamble;

        // Used for definite assignment analysis
        internal BitSet BSetEnter = new BitSet();   // bsetEnter;
        internal int JBitMin = 0;                   // jbitMin
        internal int JBitLim = 0;                   // jbitLim

        /// <summary>
        /// The anonymous method SYM. Created only when actually needed.
        /// </summary>
        internal METHSYM MethodSym = null;          // * meth;

        /// <summary>
        /// (CS3) True if this will be converted to a expression tree.
        /// </summary>
        /// <remarks>2016/05/06 hirano567@hotmail.co.jp</remarks>
        internal bool ToExpressionTree = false;

        /// <summary>
        /// (CS3) the lambda expression have been converted to the expression tree.
        /// </summary>
        /// <remarks>2016/05/10 hirano567@hotmail.co.jp</remarks>
        internal bool ConversionCompleted = false;

        internal bool Compiled
        {
            get { return (this.BodyBlockExpr != null); }
        }
    }

    //======================================================================
    // enum IteratorStatesEnum
    //
    // Moved to Iterator.cs
    //======================================================================

    //======================================================================
    // enum SpecialNameKindEnum
    //
    /// <summary>
    /// <para>Used to distinguish compiler generated names in the EE</para>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    internal enum SpecialNameKindEnum : int
    {
        None = 0,

        // Fields

        /// <summary>
        /// <>1__state (also hard-coded into predefname table)
        /// </summary>
        IteratorState = 1,

        /// <summary>
        /// <>2__current (also hard-coded into predefname table)
        /// </summary>
        CurrentField = 2,

        /// <summary>
        /// <>3__... (hard-coded)
        /// </summary>
        SavedParamOrThis = 3,

        /// <summary>
        /// <>4__this (hard-coded into predefname table)
        /// </summary>
        HoistedThis = 4,

        HoistedIteratorLocal,

        OuterscopeLocals,

        HoistedWrap,

        // Locals

        DisplayClassInstance,   // can also be a field

        CachedDelegateInstance, // can also be a field

        IteratorInstance,

        // Methods

        AnonymousMethod,

        // Types

        AnonymousMethodDisplayClass,
        IteratorClass,
        FixedBufferStruct,

        // Keep This last

        LastKind = FixedBufferStruct
    }
    //C_ASSERT(SpecialNameKind::LastKind < 16);

    //======================================================================
    // class ArgInfos
    //
    /// <summary>
    /// <para>Small wrapper for passing around argument information for the various BindGrpTo* methods
    /// It is used because most things only need the type, but in the case of METHGRPs and ANONMETHs
    /// the expr is also needed to detimine if a conversion is possible</para>
    /// <para>This class has a TypeArray instance and a list of EXPR instances.</para>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    internal class ArgInfos
    {
        /// <summary>
        /// A TypeArray instance of the TYPESYM instances of arguments.
        /// </summary>
        internal TypeArray ArgumentTypes = null;    // types

        internal bool HasExprs = false;             // fHasExprs

        internal List<EXPR> ExprList = null;        // EXPR * prgexpr[];

        internal int ArgumentCount              // carg
        {
            get { return (this.ArgumentTypes != null ? this.ArgumentTypes.Count : 0); }
        }
    }

    // LOOKUPMASK is defined in enum SYMBMASK.
    //#define LOOKUPMASK (  \
    // MASK_NSAIDSYM |      \
    // MASK_AGGTYPESYM |    \
    // MASK_NUBSYM |        \
    // MASK_MEMBVARSYM |    \
    // MASK_TYVARSYM |      \
    // MASK_LOCVARSYM |     \
    // MASK_METHSYM |       \
    // MASK_PROPSYM         \
    // )

    //#define BIND_RVALUEREQUIRED 0x01 // this is a get of expr, not an assignment to expr
    //#define BIND_MEMBERSET      0x02 // indicates that an lvalue is needed
    //#define BIND_FIXEDVALUE     0x10 // ok to take address of unfixed
    //#define BIND_ARGUMENTS      0x20 // this is an argument list to a call...
    //#define BIND_BASECALL       0x40 // this is a base method or prop call
    //#define BIND_USINGVALUE     0x80 // local in a using stmt decl
    //#define BIND_STMTEXPRONLY  0x100 // only allow expressions that are valid in a statement
    //#define BIND_TYPEOK        0x200 // types are ok to be returned
    //#define BIND_MAYBECONFUSEDNEGATIVECAST  0x400 // this may be a mistaken negative cast
    //#define BIND_METHODNOTOK   0x800 // naked methods are not ok to be returned
    //#define BIND_DECLNOTOK    0x1000 // var decls are not ok to be returned
    //#define BIND_NOPARAMS     0x2000 // Do not do params expansion during overload resolution

    //======================================================================
    // enum BindFlagsEnum (BIND_)
    //
    /// <summary>
    /// <para>(In sscli, they have prefix BIND_).</para>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    [Flags]
    internal enum BindFlagsEnum : int
    {
        /// <summary>
        /// this is a get of expr, not an assignment to expr
        /// </summary>
        RValueRequired = 0x01,	// BIND_RVALUEREQUIRED

        /// <summary>
        /// indicates that an lvalue is needed
        /// </summary>
        MemberSet = 0x02,	// BIND_MEMBERSET

        /// <summary>
        /// ok to take address of unfixed
        /// </summary>
        FixedValue = 0x10,	// BIND_FIXEDVALUE

        /// <summary>
        /// this is an argument list to a call...
        /// </summary>
        Arguments = 0x20,	// BIND_ARGUMENTS

        /// <summary>
        /// this is a base method or prop call
        /// </summary>
        BaseCall = 0x40,	// BIND_BASECALL

        /// <summary>
        /// local in a using stmt decl
        /// </summary>
        UsingValue = 0x80,	// BIND_USINGVALUE

        /// <summary>
        /// only allow expressions that are valid in a statement
        /// </summary>
        StatementExpressionOnly = 0x100,	// BIND_STMTEXPRONLY

        /// <summary>
        /// types are ok to be returned
        /// </summary>
        TypeOk = 0x200,	// BIND_TYPEOK

        /// <summary>
        /// this may be a mistaken negative cast
        /// </summary>
        MaybeConfusedNegativeCast = 0x400,	// BIND_MAYBECONFUSEDNEGATIVECAST

        /// <summary>
        /// naked methods are not ok to be returned
        /// </summary>
        MethodNotOk = 0x800,	// BIND_METHODNOTOK

        /// <summary>
        /// var decls are not ok to be returned
        /// </summary>
        DeclarationNotOk = 0x1000,	// BIND_DECLNOTOK

        /// <summary>
        /// Do not do params expansion during overload resolution
        /// </summary>
        NoParams = 0x2000,	// BIND_NOPARAMS

        /// <summary>
        /// (CS3) Convert lambda expressions to expression trees
        /// </summary>
        AssignToIQueryable = NoParams << 1,
    }

    //======================================================================
    // enum BinOpKindEnum
    //
    /// <summary>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    internal enum BinOpKindEnum : int
    {
        Add,
        Sub,
        Mul,
        Shift,
        Equal,
        Compare,
        Bitwise,
        BitXor,
        Logical,

        Lim
    }

    //======================================================================
    // enum BinOpMaskEnum
    //
    /// <summary>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    [Flags]
    internal enum BinOpMaskEnum : int
    {
        None = 0,
        Add = 1 << BinOpKindEnum.Add,
        Sub = 1 << BinOpKindEnum.Sub,
        Mul = 1 << BinOpKindEnum.Mul,
        Shift = 1 << BinOpKindEnum.Shift,
        Equal = 1 << BinOpKindEnum.Equal,
        Compare = 1 << BinOpKindEnum.Compare,
        Bitwise = 1 << BinOpKindEnum.Bitwise,
        BitXor = 1 << BinOpKindEnum.BitXor,
        Logical = 1 << BinOpKindEnum.Logical,

        // The different combinations needed in operators.cpp

        Integer = Add | Sub | Mul | Equal | Compare | Bitwise | BitXor,
        Real = Add | Sub | Mul | Equal | Compare,
        BoolNorm = Equal | BitXor,

        // These are special ones.

        Delegate = Add | Sub | Equal,
        Enum = Sub | Equal | Compare | Bitwise | BitXor,
        EnumUnder = Add | Sub,
        UnderEnum = Add,
        Ptr = Sub,
        PtrNum = Add | Sub,
        NumPtr = Add,
        VoidPtr = Equal | Compare,
    }

    //======================================================================
    // enum UnaOpKindEnum
    //
    /// <summary>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    internal enum UnaOpKindEnum : int
    {
        Plus,
        Minus,
        Tilde,
        Bang,
        IncDec,

        Lim
    }

    //======================================================================
    // enum UnaOpMaskEnum
    //
    /// <summary>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    internal enum UnaOpMaskEnum : int
    {
        None = 0,
        Plus = 1 << UnaOpKindEnum.Plus,
        Minus = 1 << UnaOpKindEnum.Minus,
        Tilde = 1 << UnaOpKindEnum.Tilde,
        Bang = 1 << UnaOpKindEnum.Bang,
        IncDec = 1 << UnaOpKindEnum.IncDec,

        // The different combinations needed in operators.cpp
        Signed = Plus | Minus | Tilde,
        Unsigned = Plus | Tilde,
        Real = Plus | Minus,
        Bool = Bang,
    }

    //======================================================================
    // enum LiftFlagsEnum
    //
    /// <summary>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    [Flags]
    internal enum LiftFlagsEnum : int
    {
        None = 0,
        Lift1 = 0x01,
        Lift2 = 0x02,
        Convert1 = 0x04,
        Convert2 = 0x08,

        LiftBoth = Lift1 | Lift2,
    }

    //======================================================================
    // enum OpSigFlagsEnum
    //
    /// <summary>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    [Flags]
    internal enum OpSigFlagsEnum : int
    {
        None = 0,

        /// <summary>
        /// Convert the operands before calling the bind method
        /// </summary>
        Convert = 0x01,

        /// <summary>
        /// Operator has a lifted form
        /// </summary>
        CanLift = 0x02,

        /// <summary>
        /// Standard nullable lifting
        /// </summary>
        AutoLift = 0x04,

        // The different combinations needed in operators.cpp

        Value = Convert | CanLift | AutoLift,

        Reference = Convert,

        BoolBit = Convert | CanLift,
    }

    //======================================================================
    // enum ConvKindEnum
    //
    /// <summary>
    /// <para>Indicates what kind of conversion exists between two types.</para>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    internal enum ConvKindEnum : int
    {
        /// <summary>
        /// Identity conversion
        /// </summary>
        Identity = 1,

        /// <summary>
        /// Implicit conversion
        /// </summary>
        Implicit = 2,

        /// <summary>
        /// Explicit conversion
        /// </summary>
        Explicit = 3,

        /// <summary>
        /// Unknown so call canConvert
        /// </summary>
        Unknown = 4,

        /// <summary>
        /// None
        /// </summary>
        None = 5,
    }

    //======================================================================
    // enum BetterTypeEnum
    //
    /// <summary>
    /// <para>Indicates which type is better for overload resolution.</para>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    internal enum BetterTypeEnum : int
    {
        /// <summary>
        /// They're the same
        /// </summary>
        Same = 0,

        /// <summary>
        /// Implicit conversion
        /// </summary>
        Left = 1,

        /// <summary>
        /// Explicit conversion
        /// </summary>
        Right = 2,

        /// <summary>
        /// Neither
        /// </summary>
        Neither = 3,
    }

    //======================================================================
    // class SimpleTypeConversion
    //
    /// <summary>
    /// <para>Define the simple type conversions table.</para>
    /// <para>(CSharp\SCComp\FncBind.cs)</para>
    /// </summary>
    //======================================================================
    static internal class SimpleTypeConversion
    {
        /// <summary>
        /// Identity conversion
        /// </summary>
        internal const byte CONV_KIND_ID = (byte)ConvKindEnum.Identity;

        /// <summary>
        /// Implicit conversion
        /// </summary>
        internal const byte CONV_KIND_IMP = (byte)ConvKindEnum.Implicit;

        /// <summary>
        /// Explicit conversion
        /// </summary>
        internal const byte CONV_KIND_EXP = (byte)ConvKindEnum.Explicit;

        /// <summary>
        /// No conversion
        /// </summary>
        internal const byte CONV_KIND_NONE = (byte)ConvKindEnum.None;

        /// <summary>
        /// Mask for above.
        /// </summary>
        internal const byte CONV_KIND_MASK = 0x0F;

        /// <summary>
        /// Use a "user defined" operator function to make the conversion.
        /// </summary>
        internal const byte CONV_KIND_USEUDC = 0x40;

        // shorthands for defining the table

        internal const byte ID = CONV_KIND_ID;
        internal const byte IMP = CONV_KIND_IMP;
        internal const byte EXP = CONV_KIND_EXP;
        internal const byte NO = CONV_KIND_NONE;
        internal const byte UDC = CONV_KIND_USEUDC;

        //static internal /*const*/ byte[,] SimpleTypeConversions = // byte[NUM_SIMPLE_TYPES,NUM_SIMPLE_TYPES]
        static internal /*const*/ byte[,] Table = // byte[NUM_SIMPLE_TYPES,NUM_SIMPLE_TYPES]
        {
            // to:
            //BYTE    I2      I4      I8      FLT     DBL     DEC     CHAR    BOOL    SBYTE   U2      U4      U8           from
            { ID    ,IMP    ,IMP    ,IMP    ,IMP    ,IMP    ,IMP|UDC,EXP    ,NO ,    EXP    ,IMP    ,IMP    ,IMP    }, // BYTE
            { EXP    ,ID     ,IMP    ,IMP    ,IMP    ,IMP    ,IMP|UDC,EXP    ,NO ,    EXP    ,EXP    ,EXP    ,EXP    }, // I2
            { EXP    ,EXP    ,ID     ,IMP    ,IMP    ,IMP    ,IMP|UDC,EXP    ,NO ,    EXP    ,EXP    ,EXP    ,EXP    }, // I4
            { EXP    ,EXP    ,EXP    ,ID     ,IMP    ,IMP    ,IMP|UDC,EXP    ,NO ,    EXP    ,EXP    ,EXP    ,EXP    }, // I8
            { EXP    ,EXP    ,EXP    ,EXP    ,ID     ,IMP    ,EXP|UDC,EXP    ,NO ,    EXP    ,EXP    ,EXP    ,EXP    }, // FLT
            { EXP    ,EXP    ,EXP    ,EXP    ,EXP    ,ID     ,EXP|UDC,EXP    ,NO ,    EXP    ,EXP    ,EXP    ,EXP    }, // DBL
            { EXP|UDC,EXP|UDC,EXP|UDC,EXP|UDC,EXP|UDC,EXP|UDC,ID     ,EXP|UDC,NO ,    EXP|UDC,EXP|UDC,EXP|UDC,EXP|UDC}, // DEC
            { EXP    ,EXP    ,IMP    ,IMP    ,IMP    ,IMP    ,IMP|UDC,ID     ,NO ,    EXP    ,IMP    ,IMP    ,IMP    }, // CHAR
            { NO     ,NO     ,NO     ,NO     ,NO     ,NO     ,NO     ,NO     ,ID ,    NO     ,NO     ,NO     ,NO     }, // BOOL
            { EXP    ,IMP    ,IMP    ,IMP    ,IMP    ,IMP    ,IMP|UDC,EXP    ,NO ,    ID     ,EXP    ,EXP    ,EXP    }, // SBYTE
            { EXP    ,EXP    ,IMP    ,IMP    ,IMP    ,IMP    ,IMP|UDC,EXP    ,NO ,    EXP    ,ID     ,IMP    ,IMP    }, // U2
            { EXP    ,EXP    ,EXP    ,IMP    ,IMP    ,IMP    ,IMP|UDC,EXP    ,NO ,    EXP    ,EXP    ,ID     ,IMP    }, // U4
            { EXP    ,EXP    ,EXP    ,EXP    ,IMP    ,IMP    ,IMP|UDC,EXP    ,NO ,    EXP    ,EXP    ,EXP    ,ID     }, // U8
        };
    }

    //======================================================================
    // class FUNCBREC
    //======================================================================
    internal partial class FUNCBREC
    {
        //friend LOOPLABELS::LOOPLABELS(FUNCBREC *);
        //friend CHECKEDCONTEXT::CHECKEDCONTEXT(FUNCBREC *, bool);
        //friend void CHECKEDCONTEXT::restore(FUNCBREC *);

        //#if defined(__GNUC__) && (__GNUC__ < 3)
        //    friend struct FUNCBREC::SwitchPusher;
        //#endif

        //friend class FncBindState;
        //friend class MemberLookup;

        //internal:

        //============================================================
        // enum FUNCBREC.UnsafeStatesEnum
        //
        /// <summary>
        /// <para>(CSharp\SCComp\FncBind.cs)</para>
        /// </summary>
        //============================================================
        internal enum UnsafeStatesEnum : int
        {
            Unsafe,
            Safe,
            Unknown,
        }

        //============================================================
        // enum FUNCBREC.ConvertTypeEnum
        //
        /// <summary>
        /// <para>Flags for bindImplicitConversion/bindExplicitConversion</para>
        /// <para>(CSharp\SCComp\FncBind.cs)</para>
        /// </summary>
        //============================================================
        [Flags]
        internal enum ConvertTypeEnum : int
        {
            NOUDC = 0x01,

            /// <summary>
            /// standard only, but never pass it in, used only to check...
            /// </summary>
            STANDARD = 0x02,

            /// <summary>
            /// implicit conversion is really explicit
            /// </summary>
            ISEXPLICIT = 0x04,

            /// <summary>
            /// check overflow (like in a checked context).
            /// </summary>
            CHECKOVERFLOW = 0x08,

            /// <summary>
            /// pass this in if you mean standard conversions only
            /// </summary>
            STANDARDANDNOUDC = 0x03,
        }

        //============================================================
        // class FUNCBREC.SwitchPusher
        //============================================================
        protected class SwitchPusher
        {
            private FUNCBREC funcBRec = null;           // m_fnc;
            private EXPRSWITCH prevSwitchExpr = null;   // m_exprSwitchPrev;

            //--------------------------------------------------------
            // SwitchPusher Constructor
            //--------------------------------------------------------
            internal SwitchPusher(FUNCBREC fnc, EXPRSWITCH exprSwitchCur)
            {
                DebugUtil.Assert(fnc != null);

                this.funcBRec = fnc;
                this.prevSwitchExpr = this.funcBRec.CurrentSwitchExpr;
                this.funcBRec.CurrentSwitchExpr = exprSwitchCur;
            }

            //--------------------------------------------------------
            // SwitchPusher.Pop
            //
            /// <summary>
            /// In sscli, FUNCBREC.CurrentSwitchExpr is restored by the destructor.
            /// In C#, call this method to restore.
            /// </summary>
            //--------------------------------------------------------
            internal void Pop()
            {
                if (funcBRec != null)
                {
                    this.funcBRec.CurrentSwitchExpr = this.prevSwitchExpr;
                    this.funcBRec = null;
                }
            }
        }

        //protected:
        //============================================================
        // class FUNCBREC.FncBindState
        //
        /// <summary>
        /// In sscli, the destructors restore the saved states.
        /// but in C#, we cannot use the destructors to restore,
        /// so we should explicitly call Restore method.
        /// </summary>
        //============================================================
        protected class FncBindState
        {
            //--------------------------------------------------
            // FUNCBREC.FncBindState Fields and Properties
            //--------------------------------------------------
            private FUNCBREC funcBRec;                  // * fnc;
            private METHSYM methodSym;                  // * meth;
            private MEMBVARSYM fieldSym;                // * field;
            private BASENODE treeNode;                  // * tree;
            private AGGSYM parentAggSym;                // * aggPar;
            private DECLSYM parentDeclSym;              // * declPar;
            private TypeBindFlagsEnum typeBindFlags;    // btfFlags;
            private AGGINFO classInfo;                  // * infoCls;
            private SCOPESYM outerScopeSym;             // * scopeOuter;

            //--------------------------------------------------
            // FUNCBREC.FncBindState Constructor (1)
            //--------------------------------------------------
            internal FncBindState()
            {
                this.funcBRec = null;
            }

            //--------------------------------------------------
            // FUNCBREC.FncBindState (2)
            //--------------------------------------------------
            internal FncBindState(FUNCBREC fnc)
            {
                Save(fnc);
            }

            //~FncBindState() {
            //    if (fnc)
            //        Restore();
            //}

            //--------------------------------------------------
            // FUNCBREC.FncBindState.Save
            //--------------------------------------------------
            internal void Save(FUNCBREC fnc)
            {
                DebugUtil.Assert(fnc != null);

                this.funcBRec = fnc;
                this.methodSym = fnc.methodSym;
                this.fieldSym = fnc.currentFieldSym;
                this.treeNode = fnc.treeNode;
                this.parentAggSym = fnc.parentAggSym;
                this.parentDeclSym = fnc.parentDeclSym;
                this.typeBindFlags = fnc.typeBindFlags;
                this.classInfo = fnc.classInfo;
                this.outerScopeSym = fnc.OuterScopeSym;
            }

            //--------------------------------------------------
            // FUNCBREC.FncBindState.Restore
            //--------------------------------------------------
            internal void Restore()
            {
                if (this.funcBRec == null)
                {
                    return;
                }

                this.funcBRec.methodSym = this.methodSym;
                this.funcBRec.currentFieldSym = this.fieldSym;
                this.funcBRec.treeNode = this.treeNode;
                this.funcBRec.parentAggSym = this.parentAggSym;
                this.funcBRec.parentDeclSym = this.parentDeclSym;
                this.funcBRec.typeBindFlags = this.typeBindFlags;
                this.funcBRec.classInfo = this.classInfo;
                this.funcBRec.OuterScopeSym = this.outerScopeSym;

                this.funcBRec = null;
            }
        }

        //private:

        // Predefined operator overload resolution.

        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="kind"></param>
        /// <param name="flags"></param>
        /// <param name="op1"></param>
        /// <param name="op2"></param>
        /// <returns></returns>
        /// <remarks>In sscli,
        /// typedef EXPR * (FUNCBREC::*PfnBindBinOp)(BASENODE * tree, EXPRKIND ek, uint flags, EXPR * op1, EXPR * op2);
        /// </remarks>
        internal delegate EXPR DelegateBindBinOp(BASENODE tree, EXPRKIND kind, EXPRFLAG flags, EXPR op1, EXPR op2);

        /// <summary>/// </summary>
        /// <param name="tree"></param>
        /// <param name="kind"></param>
        /// <param name="flags"></param>
        /// <param name="op"></param>
        /// <returns></returns>
        /// <remarks>In sscli,
        /// typedef EXPR * (FUNCBREC::*PfnBindUnaOp)(BASENODE * tree, EXPRKIND ek, uint flags, EXPR * op);
        /// </remarks>
        internal delegate EXPR DelegateBindUnaOp(BASENODE tree, EXPRKIND kind, int flags, EXPR op);

        //============================================================
        // class FUNCBREC.BinOpSig
        //============================================================
        protected class BinOpSig
        {
            internal PREDEFTYPE PredefinedType1;    // pt1;
            internal PREDEFTYPE PredefinedType2;    // pt2;
            internal BinOpMaskEnum Mask;            // grfbom;
            internal int SkipCount;                 // cbosSkip;
            internal BindBinOpEnum BindOp;          // PfnBindBinOp pfn;
            internal OpSigFlagsEnum Flags;          // grfos;

            //--------------------------------------------------
            // BinOpSig Constructor (1)
            //--------------------------------------------------
            internal BinOpSig() { }

            //--------------------------------------------------
            // BinOpSig Constructor (2)
            //--------------------------------------------------
            internal BinOpSig(
                PREDEFTYPE pt1,
                PREDEFTYPE pt2,
                BinOpMaskEnum mask,
                int skips,
                BindBinOpEnum op,
                OpSigFlagsEnum flags
                )
            {
                this.PredefinedType1 = pt1;
                this.PredefinedType2 = pt2;
                this.Mask = mask;
                this.SkipCount = skips;
                this.BindOp = op;
                this.Flags = flags;
            }
        }

        //============================================================
        // class FUNCBREC.BinOpFullSig
        //============================================================
        protected class BinOpFullSig : BinOpSig
        {
            //------------------------------------------------------------
            // BinOpFullSig Fields and Properties
            //------------------------------------------------------------
            internal TYPESYM TypeSym1 = null;       // * type1;
            internal TYPESYM TypeSym2 = null;       // * type2;
            internal LiftFlagsEnum LiftFlags = 0;   // grflt;

            //------------------------------------------------------------
            // BinOpFullSig.Set (1)
            //
            /// <summary>
            /// Set the values of the BinOpFullSig from the given info.
            /// </summary>
            /// <param name="type1"></param>
            /// <param name="type2"></param>
            /// <param name="op"></param>
            /// <param name="flags"></param>
            /// <param name="liftFlags"></param>
            //------------------------------------------------------------
            internal void Set(
                TYPESYM type1,
                TYPESYM type2,
                BindBinOpEnum op,
                OpSigFlagsEnum flags,
                LiftFlagsEnum liftFlags)	// = LiftFlagsEnum.None
            {
                this.PredefinedType1 = (PREDEFTYPE)(-1);
                this.PredefinedType2 = (PREDEFTYPE)(-1);
                this.Mask = BinOpMaskEnum.None;
                this.SkipCount = 0;
                this.BindOp = op;
                this.Flags = flags;
                this.TypeSym1 = type1;
                this.TypeSym2 = type2;
                this.LiftFlags = liftFlags;
            }

            //------------------------------------------------------------
            // BinOpFullSig
            //
            /// <summary>
            /// <para>(sscli) Set the values of the BinOpFullSig from the given BinOpSig.
            /// The FUNCBREC is needed to get the predefined types.
            /// Returns true iff the predef types are found.</para>
            /// <para>In this program, only copy bos.* to this.*.
            /// If need "*(BinOpSig *)this = bos;" in sscli,
            /// use "as BinOpSig".</para>
            /// </summary>
            /// <param name="fnc"></param>
            /// <param name="bos"></param>
            /// <returns></returns>
            //------------------------------------------------------------
            internal bool Set(FUNCBREC fnc, BinOpSig bos)
            {
                //*(BinOpSig *)this = bos;
                this.PredefinedType1 = bos.PredefinedType1;
                this.PredefinedType2 = bos.PredefinedType2;
                this.Mask = bos.Mask;
                this.SkipCount = bos.SkipCount;
                this.BindOp = bos.BindOp;
                this.Flags = bos.Flags;

                DebugUtil.Assert(PredefinedType1 >= 0);
                TypeSym1 = fnc.GetOptionalPredefinedType(PredefinedType1);
                TypeSym2 = fnc.GetOptionalPredefinedType(PredefinedType2);
                this.LiftFlags = LiftFlagsEnum.None;
                return (TypeSym1 != null && TypeSym2 != null);
            }

            //------------------------------------------------------------
            // BinOpFullSig.FPreDef
            //
            /// <summary>
            /// Truen if PredefinedType1 is valid.
            /// </summary>
            /// <returns></returns>
            //------------------------------------------------------------
            internal bool FPreDef()
            {
                return PredefinedType1 >= 0;
            }
        }

        //    friend struct BinOpFullSig;

        //============================================================
        // class FUNCBREC.UnaOpSig
        //
        /// <summary>
        /// <para>(CSharp\SCComp\FncBindcs)</para>
        /// </summary>
        //============================================================
        protected class UnaOpSig
        {
            internal PREDEFTYPE PredefinedType; // pt;
            internal UnaOpMaskEnum UnaOpMask;   // grfuom;
            internal int SkipCount;             // cuosSkip;
            internal BindUnaOpEnum BindOp;      // pfn;

            //--------------------------------------------------
            // UnaOpSig Constructor (1)
            //--------------------------------------------------
            internal UnaOpSig() { }

            //--------------------------------------------------
            // UnaOpSig Constructor (2)
            //--------------------------------------------------
            internal UnaOpSig(
                PREDEFTYPE pt,
                UnaOpMaskEnum mask,
                int skips,
                BindUnaOpEnum op)
            {
                this.PredefinedType = pt;
                this.UnaOpMask = mask;
                this.SkipCount = skips;
                this.BindOp = op;
            }
        }

        //============================================================
        // class FUNCBREC.UnaOpFullSig
        //============================================================
        protected class UnaOpFullSig : UnaOpSig
        {
            //--------------------------------------------------
            // FUNCBREC.UnaOpFullSig
            //--------------------------------------------------
            internal TYPESYM TypeSym = null;        // type;
            internal LiftFlagsEnum LiftFlags = 0;   // grflt;

            //--------------------------------------------------
            // FUNCBREC.UnaOpFullSig.Set (1)
            //
            /// <summary></summary>
            /// <param name="type"></param>
            /// <param name="pfn"></param>
            /// <param name="liftFlags"></param>
            //--------------------------------------------------
            internal void Set(
                TYPESYM type,
                BindUnaOpEnum op,
                LiftFlagsEnum liftFlags)    // = LiftFlags::None)
            {
                this.PredefinedType = (PREDEFTYPE)(-1);
                this.UnaOpMask = UnaOpMaskEnum.None;
                this.BindOp = op;
                this.TypeSym = type;
                this.LiftFlags = liftFlags;
            }

            //--------------------------------------------------
            // FUNCBREC.UnaOpFullSig.Set (2)
            //
            /// <summary>
            /// <para>In sscli, override this instance by uos.
            /// But in C#, "this" is readonly and it is impossible.
            /// Instead, set this as UnaOpSig to uos.</para>
            /// </summary>
            //--------------------------------------------------
            internal bool Set(FUNCBREC fnc, UnaOpSig uos)
            {
                //*(UnaOpSig*)this = uos;
                this.PredefinedType = uos.PredefinedType;
                this.UnaOpMask = uos.UnaOpMask;
                this.SkipCount = uos.SkipCount;
                this.BindOp = uos.BindOp;

                DebugUtil.Assert(this.PredefinedType >= 0);
                this.TypeSym = fnc.GetOptionalPredefinedType(this.PredefinedType);
                this.LiftFlags = LiftFlagsEnum.None;
                return (this.TypeSym != null);
            }

            //--------------------------------------------------
            // FUNCBREC.UnaOpFullSig.FPreDef
            //
            /// <summary></summary>
            /// <returns></returns>
            //--------------------------------------------------
            internal bool FPreDef()
            {
                return this.PredefinedType >= 0;
            }
        }
        //    friend struct UnaOpFullSig;

        //private:

        //============================================================
        // class FUNCBREC.StatementListBuilder
        //
        /// <summary>
        /// <para>When finish to add statements,
        /// call GetList method to get the top EXPRSTMT of the list.</para>
        /// </summary>
        /// <remarks>
        /// In sscli, StmtListBldr
        /// </remarks>
        //============================================================
        internal class StatementListBuilder
        {
            //EXPRSTMT ** m_pstmtNext;
            private EXPRSTMT firstStatementExpr = null;
            private EXPRSTMT lastStatementExpr = null;

            //------------------------------------------------------------
            // FUNCBREC.StatementListBuilder Constructor
            //
            ///<summary>Do nothig.</summary>
            //------------------------------------------------------------
            internal StatementListBuilder() { }

            //------------------------------------------------------------
            // FUNCBREC.StatementListBuilder.Clear
            //------------------------------------------------------------
            internal void Clear()
            {
                this.firstStatementExpr = null;
                this.lastStatementExpr = null;
            }

            //------------------------------------------------------------
            // FUNCBREC.StatementListBuilder.Add (1)
            //------------------------------------------------------------
            internal void Add(EXPRSTMT stmt)
            {
                //DebugUtil.Assert(lastStatementExpr && !*lastStatementExpr);
                if (stmt != null)
                {
                    if (this.firstStatementExpr == null)
                    {
                        this.firstStatementExpr = stmt;
                        this.lastStatementExpr = stmt;
                    }
                    else
                    {
                        this.lastStatementExpr.NextStatement = stmt;
                        this.lastStatementExpr = stmt;
                    }

                    while (this.lastStatementExpr.NextStatement != null)
                    {
                        this.lastStatementExpr = this.lastStatementExpr.NextStatement;
                    }
                }
            }

            //------------------------------------------------------------
            // FUNCBREC.StatementListBuilder.Add (2)
            //------------------------------------------------------------
            internal void Add(EXPRSTMT stmt, EXPRFLAG flags)
            {
                //DebugUtil.Assert(lastStatementExpr && !*lastStatementExpr);
                if (stmt!=null)
                {
                    DebugUtil.Assert(stmt.NextStatement == null);
                    stmt.Flags |= flags;
                    Add(stmt);
                }
            }

            //------------------------------------------------------------
            // StatementListBuilder.
            //------------------------------------------------------------
            //internal void AddList(EXPRSTMT * stmt) {
            //    DebugUtil.Assert(lastStatementExpr && !*lastStatementExpr);
            //    *lastStatementExpr = stmt;
            //    while (*lastStatementExpr)
            //        lastStatementExpr = &(*lastStatementExpr).stmtNext;
            //}

            //------------------------------------------------------------
            // StatementListBuilder.
            //------------------------------------------------------------
            //internal EXPRSTMT ** PstmtNext() { return lastStatementExpr; }

            //------------------------------------------------------------
            // FUNCBREC.StatementListBuilder.GetList
            //------------------------------------------------------------
            internal EXPRSTMT GetList()
            {
                return this.firstStatementExpr;
            }

            //------------------------------------------------------------
            // FUNCBREC.StatementListBuilder.GetLast
            //------------------------------------------------------------
            internal EXPRSTMT GetLast()
            {
                return this.lastStatementExpr;
            }
        }

        //============================================================
        // class FUNCBREC.BinOpArgInfo
        //============================================================
        internal class BinOpArgInfo
        {
            internal EXPR ArgumentExpr1 = null;	        // * arg1;
            internal EXPR ArgumentExpr2 = null;	        // * arg2;
            internal PREDEFTYPE PredefinedType1 = 0;	// pt1;
            internal PREDEFTYPE PredefinedType2 = 0;	// pt2;
            internal PREDEFTYPE RawPredefinedType1 = 0;	// ptRaw1;
            internal PREDEFTYPE RawPredefinedType2 = 0;	// ptRaw2;
            internal TYPESYM TypeSym1 = null;	        // * type1;
            internal TYPESYM TypeSym2 = null;	        // * type2;
            internal TYPESYM RawTypeSym1 = null;	    // * typeRaw1;
            internal TYPESYM RawTypeSym2 = null;	    // * typeRaw2;
            internal BinOpKindEnum BinOpKind = 0;	    // bok;
            internal BinOpMaskEnum BinOpMask = 0;	    // grfbom;
        }

        //============================================================
        // class FUNCBREC.NubInfo
        //============================================================
        private class NubInfo
        {
            //------------------------------------------------------------
            // NubInfo Fields and Properties
            //------------------------------------------------------------

            /// <summary>
            /// condition for calling the operator
            /// </summary>
            internal EXPR[] ConditionExpr = { null, null }; // EXPR * rgexprCnd[2];

            /// <summary>
            /// assign to temp (or side effects)
            /// </summary>
            internal EXPR[] PreExpr = { null, null };   // EXPR * rgexprPre[2];

            /// <summary>
            /// load temp (or constant)
            /// </summary>
            internal EXPR[] TmpExpr = { null, null };  // EXPR * rgexprTmp[2];

            /// <summary>
            /// free temp (or null)
            /// </summary>
            internal EXPR[] PostExpr = { null, null };  // EXPR * rgexprPst[2];

            /// <summary>
            /// underlying value
            /// </summary>
            internal EXPR[] ValueExpr = { null, null }; // EXPR * rgexprVal[2];

            /// <summary>
            /// Combined condition
            /// </summary>
            internal EXPR CombinedConditionExpr = null; // EXPR * exprCnd;

            internal bool[] IsNull = { false, false };  // bool rgfNull[2];

            internal bool IsAlwaysNull = false; // bool fAlwaysNull: 1;

            internal bool IsAlwaysNonNull = false;  // bool fAlwaysNonNull: 1;

            internal bool IsSameTemp = false;   // bool fSameTemp: 1;

            internal bool IsActive = false; // bool fActive: 1;

            //------------------------------------------------------------
            // NubInfo Constructor
            //------------------------------------------------------------
            internal NubInfo() { }

            //------------------------------------------------------------
            // NubInfo.FConst
            //------------------------------------------------------------
            internal bool FConst(int iexpr)
            {
                DebugUtil.Assert(0 <= iexpr && iexpr < 2);
                DebugUtil.Assert(TmpExpr[iexpr] != null &&
                         (TmpExpr[iexpr].Kind == EXPRKIND.LDTMP ||
                         TmpExpr[iexpr].Kind == EXPRKIND.CONSTANT ||
                         TmpExpr[iexpr].Kind == EXPRKIND.ZEROINIT));

                return TmpExpr[iexpr].Kind != EXPRKIND.LDTMP;
            }

            //------------------------------------------------------------
            // NubInfo.Val
            //------------------------------------------------------------
            internal EXPR Val(int iexpr)
            {
                return ValueExpr[iexpr];
            }

            //------------------------------------------------------------
            // NubInfo.TmpVal
            //------------------------------------------------------------
            internal EXPR TmpVal(int iexpr)
            {
                return TmpExpr[iexpr] != null ? TmpExpr[iexpr] : ValueExpr[iexpr];
            }

            //------------------------------------------------------------
            // NubInfo.PreVal
            //------------------------------------------------------------
            internal EXPR PreVal(int iexpr)
            {
                return PreExpr[iexpr] != null ? PreExpr[iexpr] : ValueExpr[iexpr];
            }

            //------------------------------------------------------------
            // NubInfo.FAlwaysNull
            //------------------------------------------------------------
            internal bool FAlwaysNull()
            {
                DebugUtil.Assert(IsActive);
                DebugUtil.Assert(
                    !IsAlwaysNull ||
                    (IsNull[0] || IsNull[1]) &&
                    PostExpr[0] == null && PostExpr[1] == null &&
                    CombinedConditionExpr == null);

                return IsAlwaysNull;
            }

            //------------------------------------------------------------
            // NubInfo.FAlwaysNonNull
            //------------------------------------------------------------
            internal bool FAlwaysNonNull()
            {
                DebugUtil.Assert(IsActive);
                DebugUtil.Assert(
                    !IsAlwaysNonNull ||
                    PreExpr[0] == null && PreExpr[1] == null &&
                    TmpExpr[0] == null && TmpExpr[1] == null &&
                    PostExpr[0] == null && PostExpr[1] == null &&
                    ConditionExpr[0] == null && ConditionExpr[1] == null &&
                    CombinedConditionExpr == null);

                return IsAlwaysNonNull;
            }

            //------------------------------------------------------------
            // NubInfo.Init
            //------------------------------------------------------------
            internal void Init() { }
        }

        //private:
        //============================================================
        // class FUNCBREC.RewriteInfo
        //
        /// <summary>
        /// Base class for rewrite info.
        /// Used to store useful EXPRs and SYMs for rewriting an EXPR tree and tracking state
        /// </summary>
        //============================================================
        internal class RewriteInfo
        {
            //internal:
            //    virtual bool RewriteFunc(FUNCBREC * funcBRec, EXPR ** expr) = 0;
            virtual internal bool RewriteFunc(FUNCBREC funcBRec, ref EXPR expr)
            {
                throw new Exception("Do not call RewriteInfo.RewriteFunc.");
            }
        }

        //============================================================
        // class FUNCBREC.IteratorRewriteInfo
        //
        /// <summary>
        /// Used to store useful EXPRs and SYMs for rewriting an EXPR tree in an iterator
        /// and track state
        /// </summary>
        //============================================================
        internal class IteratorRewriteInfo : RewriteInfo
        {
            // The compiler generated class
            internal AGGSYM InnerAggSym = null;	// * aggInnerClass;

            // EXPR for local access (really is this access on aggInnerClass)
            internal EXPR LocalThisExpr = null;	// * exprLocalThis;

            // EXPR for aggInnerClass.$__state
            internal EXPR StateExpr = null;		// * exprState;

            // EXPR for aggInnerClass.$__current
            internal EXPR CurrentExpr = null;	// * exprCurrent;

            // EXPRLABEL for the 'return false' of an iterator
            internal EXPRLABEL ReturnFailLabelExpr = null;	// * exprLabelFailRet;

            // The current state counter
            internal IteratorStatesEnum NextState = 0;	// iNextState;

            // The current innermost finally state
            internal IteratorStatesEnum InnermostFinallyState = 0;  // iFinallyState;

            //--------------------------------------------------------
            // IteratorRewriteInfo.RewriteFunc
            //
            /// <summary></summary>
            /// <param name="funcBRec"></param>
            /// <param name="expr"></param>
            /// <returns></returns>
            //--------------------------------------------------------
            override internal bool RewriteFunc(FUNCBREC funcBRec, ref EXPR expr)
            {
                return funcBRec.RewriteIteratorFunc(ref expr, this);
            }
        }
        // friend class IteratorRewriteInfo;

        //============================================================
        // class FUNCBREC.AnonymousMethodRewriteInfo
        //
        /// <summary>
        /// Used to store useful EXPRs and SYMs for rewriting an EXPR tree in an anonymous method
        /// and track state
        /// </summary>
        //============================================================
        internal class AnonymousMethodRewriteInfo : RewriteInfo
        {
            /// <summary>
            /// The method that we are currently processing.
            /// </summary>
            internal METHSYM AnonymousMethodSym = null;	// * pAMSym;

            /// <summary>
            /// The scope that contains the arguments
            /// (including &lt;this&gt;) for the current method.
            /// </summary>
            internal SCOPESYM ArgumentsScopeSym = null;	// * pArgScope;

            /// <summary>
            /// The list of anon meth infos in pAMSym.
            /// </summary>
            internal AnonMethInfo FirstAnonymousMethodInfo = null;	// * pamiFirst;

            //--------------------------------------------------------
            // FUNCBREC.AnonymousMethodRewriteInfo Constructor
            //--------------------------------------------------------
            internal AnonymousMethodRewriteInfo(METHSYM meth, SCOPESYM scope, AnonMethInfo info)
            {
                this.AnonymousMethodSym = meth;
                this.ArgumentsScopeSym = scope;
                this.FirstAnonymousMethodInfo = info;
            }

            //--------------------------------------------------------
            // FUNCBREC.AnonymousMethodRewriteInfo.RewriteFunc
            //--------------------------------------------------------
            internal override bool RewriteFunc(FUNCBREC funcBRec, ref EXPR expr)
            {
                return funcBRec.RewriteAnonymousMethodFunc(ref expr, this);
            }
        }
        // friend class AnonymousMethodRewriteInfo;

        //============================================================
        // class FUNCBREC.UdConvInfo
        //
        /// <summary>
        /// <para>Used by bindUserDefinedConversion</para>
        /// <para>(In sscli, defined in fncbind.cpp)</para>
        /// </summary>
        //============================================================
        private class UdConvInfo
        {
            internal MethWithType MethWithType = new MethWithType();    // mwt;
            internal bool IsSrcImplicit;    // fSrcImplicit;
            internal bool IsDstImplicit;    //fDstImplicit;
        }

        //------------------------------------------------------------
        // FUNCBREC Fields and Properties (static)
        //------------------------------------------------------------
        // Two arrays below are defined in Operators.cs
        //static protected BinOpSig[] BinOpSigArray;  // static BinOpSig g_rgbos[];
        //static protected UnaOpSig[] UnaOpSigArray;  // static UnaOpSig g_rguos[];

        static protected /*const*/ byte[,] simpleTypeConversions = SimpleTypeConversion.Table;

        //static protected /*const*/ byte[,] g_mpptptBetter = new byte[Util.NUM_EXT_TYPES + 1, Util.NUM_EXT_TYPES + 1];
        // defined in Operator.cs

        static protected /*const*/ EXPRKIND[] OP2EK =   // new EXPRKIND[(int)OPERATOR.LAST];
        {
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND)((int)EXPRKIND.MULTIOFFSET + (int)EXPRKIND.ADD),
            (EXPRKIND)((int)EXPRKIND.MULTIOFFSET + (int)EXPRKIND.SUB),
            (EXPRKIND)((int)EXPRKIND.MULTIOFFSET + (int)EXPRKIND.MUL),
            (EXPRKIND)((int)EXPRKIND.MULTIOFFSET + (int)EXPRKIND.DIV),
            (EXPRKIND)((int)EXPRKIND.MULTIOFFSET + (int)EXPRKIND.MOD),
            (EXPRKIND)((int)EXPRKIND.MULTIOFFSET + (int)EXPRKIND.BITAND),
            (EXPRKIND)((int)EXPRKIND.MULTIOFFSET + (int)EXPRKIND.BITXOR),
            (EXPRKIND)((int)EXPRKIND.MULTIOFFSET + (int)EXPRKIND.BITOR),
            (EXPRKIND)((int)EXPRKIND.MULTIOFFSET + (int)EXPRKIND.LSHIFT),
            (EXPRKIND)((int)EXPRKIND.MULTIOFFSET + (int)EXPRKIND.RSHIFT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.LOGOR),
            (EXPRKIND.LOGAND),
            (EXPRKIND.BITOR),
            (EXPRKIND.BITXOR),
            (EXPRKIND.BITAND),
            (EXPRKIND.EQ),
            (EXPRKIND.NE),
            (EXPRKIND.LT),
            (EXPRKIND.LE),
            (EXPRKIND.GT),
            (EXPRKIND.GE),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.LSHIFT),
            (EXPRKIND.RSHIFT),
            (EXPRKIND.ADD),
            (EXPRKIND.SUB),
            (EXPRKIND.MUL),
            (EXPRKIND.DIV),
            (EXPRKIND.MOD),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),                   
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),                   
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
            (EXPRKIND.COUNT),
        };

        //static protected /*const*/ PREDEFNAME[] EK2NAME = new PREDEFNAME[(int)EXPRKIND.ARRLEN - (int)EXPRKIND.FIRSTOP];
        static protected PREDEFNAME[] EK2NAME =
        {
            PREDEFNAME.OPEQUALS,
            PREDEFNAME.OPCOMPARE,

            PREDEFNAME.OPTRUE,
            PREDEFNAME.OPFALSE,

            PREDEFNAME.OPINCREMENT,
            PREDEFNAME.OPDECREMENT,

            PREDEFNAME.OPNEGATION,

            PREDEFNAME.OPEQUALITY,
            PREDEFNAME.OPINEQUALITY,
            PREDEFNAME.OPLESSTHAN,
            PREDEFNAME.OPLESSTHANOREQUAL,
            PREDEFNAME.OPGREATERTHAN,
            PREDEFNAME.OPGREATERTHANOREQUAL,

            PREDEFNAME.OPPLUS,
            PREDEFNAME.OPMINUS,
            PREDEFNAME.OPMULTIPLY,
            PREDEFNAME.OPDIVISION,
            PREDEFNAME.OPMODULUS,
            PREDEFNAME.OPUNARYMINUS,
            PREDEFNAME.OPUNARYPLUS,

            PREDEFNAME.OPBITWISEAND,
            PREDEFNAME.OPBITWISEOR,
            PREDEFNAME.OPXOR,
            PREDEFNAME.OPCOMPLEMENT,

            PREDEFNAME.OPLEFTSHIFT,
            PREDEFNAME.OPRIGHTSHIFT,
        };

        static protected /*const*/ bool[] opCanBeStatement =    // new bool[(int)OPERATOR.LAST];
        {
            false,
            true,
            true,
            true,
            true,
            true,
            true,
            true,
            true,
            true,
            true,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,                   
            false,
            false,
            false,                   
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false,
            true,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
        };

        //------------------------------------------------------------
        // FUNCBREC Constants
        //------------------------------------------------------------
        private const string originalPrefix = "<>3__";

        //------------------------------------------------------------
        // FUNCBREC Fields and Properties
        //------------------------------------------------------------
        //protected:
        // Persistent members:

        // Initialized w/ each function:

        /// <summary>
        /// Callback for refactoring
        /// </summary>
        protected CCompileCallbackForward bindCallback = new CCompileCallbackForward();

        protected METHSYM methodSym = null;     // * pMSym;
        protected BASENODE treeNode;            // * pTree;
        protected METHINFO methodInfo = null;   // * info;

        /// <summary>
        ///  List of top level anonymous methods.
        /// </summary>
        protected AnonMethInfo firstAnonymousMethodInfo = null; // * m_pamiFirst;

        /// <summary>
        /// Current anonymous method being bound.
        /// </summary>
        protected AnonMethInfo currentAnonymousMethodInfo = null;   // * m_pamiCur;

        protected TypeArray classTypeVariablesForMethod = null; // * taClsVarsForMethVars;

        /// <summary>
        /// extra flags to bind type for deprecation checking
        /// </summary>
        protected TypeBindFlagsEnum typeBindFlags;  // btfFlags;

        // If initialized for a field:

        /// <summary>
        /// current field to evaluate
        /// </summary>
        protected MEMBVARSYM currentFieldSym = null;    // * pFSym;

        // original field to evaluate
        protected MEMBVARSYM originalFieldSym = null; // * pFOrigSym;

        // The following two variables are set when pMSym and pFSym and set.

        /// <summary>
        /// The parent aggregate. Can be NULL when binding class and global attributes arguments.
        /// </summary>
        protected AGGSYM parentAggSym = null;   // * parentAgg;

        /// <summary>
        /// The parent declaration, for various name binding uses.
        /// This is either an AGGDECLSYM (if parentAgg is non-NULL), or an NSDECLSYM (if parentAgg is NULL).
        /// Note that parentAgg isn't enough for name binding if partial classes are used,
        /// because the using clauses in effect may be different and unsafe state may be different.
        /// </summary>
        protected DECLSYM parentDeclSym = null; // * parentDecl;

        protected AGGINFO classInfo = null;                 // * pClassInfo;
        internal LOOPLABELS InitLabels = new LOOPLABELS();  // initLabels;
        internal LOOPLABELS LoopLabels = null;              // * loopLabels;

        /// <summary>
        /// the argument scope
        /// </summary>
        internal SCOPESYM OuterScopeSym = null; // * pOuterScope;

        //private:

        /// <summary>
        /// the current scope
        /// </summary>
        private SCOPESYM currentScopeSym = null;    // * pCurrentScope;

        /// <summary>
        /// the scope of the innermost finally, or pOuterScope if none...
        /// </summary>
        private SCOPESYM innermostFinallyScopeSym = null;   // * pFinallyScope;

        /// <summary>
        /// the scope of the innermost try, or pOuterScope if none...
        /// </summary>
        private SCOPESYM innermostTryScopeSym = null;   // * pTryScope;

        /// <summary>
        /// the scope of the innermost switch, or NULL if none
        /// </summary>
        private SCOPESYM innermostSwitchScopeSym = null;    // * pSwitchScope;

        /// <summary>
        /// the scope of the innermose catch, or NULL if none
        /// </summary>
        private SCOPESYM innermostCatchScopeSym = null; // * pCatchScope;

        private EXPRBLOCK currentBlockExpr; // class EXPRBLOCK * pCurrentBlock;;

        internal EXPRSWITCH CurrentSwitchExpr = null;   // * exprSwitchCur;

        //NRHEAP * allocator;

        private LOCVARSYM thisPointerSym = null;    // * thisPointer;

        // This is only valid during transform stage and should be NULL otherwise

        /// <summary>
        /// ONLY used by anonymous methods, keeps a &lt;this&gt; pointer for the outermost containing method.
        /// </summary>
        private LOCVARSYM outerThisPointerSym = null;   // * outerThisPointer;

        private int uninitedVarCount;
        private int unreferencedVarCount;
        private int finallyNestingCount;
        private int localCount;
        private int firstParentOffset;
        private int uniqueNameIndex = 0;
        private int errorsBeforeBind;

        /// <summary>
        /// Whether there are any forward gotos so far. This affects whether we need to
        /// track the definite assignment state of a local that has an initializer.
        /// It's strictly an optimization. In general, if you error, do so on the side
        /// of setting this to true.
        /// </summary>
        private bool areForwardGotos; // m_fForwardGotos;

        private UnsafeStatesEnum unsafeState = UnsafeStatesEnum.Unknown;

        private bool unsafeErrorGiven;
        private bool insideTryOfCatch;
        private BASENODE lastNode = null;   // * lastNode;

        internal CHECKEDCONTEXT CheckedContext = new CHECKEDCONTEXT();  //checked

        //private EXPR * userLabelList;
        //private EXPR ** pUserLabelList;
        //private List<EXPR> userLabelList = new List<EXPR>();4
        private EXPR userLabelList = null;
        private EXPR userLabelListLast = null;

        private EXPRGOTO gotoExprs = null;  // * gotos;

        /// <summary>
        /// Are we evaluating a field initializer?
        /// </summary>
        private bool evaluatingFieldInitializer = false; // inFieldInitializer;

        private bool determineImplicitTypeLater = false;

        protected COMPILER compiler = null;

        internal COMPILER Compiler
        {
            get { return this.compiler; }
        }

        //------------------------------------------------------------
        // FUNCBREC Constructor
        //
        /// <summary>
        /// Constructor, this gets called only at compiler init time...
        /// </summary>
        //------------------------------------------------------------
        internal FUNCBREC(COMPILER comp)
        {
            DebugUtil.Assert(comp != null);
            this.compiler = comp;

            //    pOuterScope = NULL;
            //    pCurrentScope = NULL;
            //    parentAgg = NULL;
            //    parentDecl = NULL;
            //    thisPointer = NULL;
            //    inFieldInitializer = false;
            //    allocator = &(compiler()->localSymAlloc);
            //    pFSym = NULL;
            //    pFOrigSym = NULL;
            //    pMSym = NULL;
            //    info = NULL;
            //    m_pamiFirst = NULL;
            //    m_pamiCur = NULL;
            //    uniqueNameIndex = 0;
            //    outerThisPointer = NULL;
            //    taClsVarsForMethVars = NULL;
            //    unsafeState = UNSAFESTATES_Unknown;
            //    exprSwitchCur = NULL;
        }

        //------------------------------------------------------------
        // FUNCBREC.CompileMethod
        //
        /// <summary>
        /// <para>compile a method.  pAMNode can point to a METHODNODE, a CTORNODE, or a
        /// CLASSNODE if compiling a synthetized constructor...</para>
        /// </summary>
        /// <param name="pAMNode"></param>
        /// <param name="methInfo"></param>
        /// <param name="classInfo"></param>
        /// <param name="argBindCallback"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR CompileMethod(
            BASENODE pAMNode,
            METHINFO methInfo,
            AGGINFO classInfo,
            ICompileCallback argBindCallback)	// = null
        {
#if DEBUG
            DebugUtil.Assert(methInfo.MethodSym != null);

            {
                if (methInfo.MethodSym.Name != null &&
                    COMPILER.IsRegString(methInfo.MethodSym.Name, "Method"))
                {
                    if (COMPILER.IsRegString(methInfo.MethodSym.ClassSym.Name, "Class"))
                    {
                        DebugUtil.Assert(false, "Compilation breakpoint hit");
                    }
                }
            }
#endif

            // Setup special member for refactoring callback
            this.bindCallback.Init(argBindCallback);

            this.insideTryOfCatch = false;

            // Define scopes and "this" local variable.
            InitMethod(methInfo, methInfo.MethodSym.ParseTreeNode, classInfo);

            SetUnsafe(methInfo.MethodSym.IsUnsafe);

            this.CheckedContext.IsNormal = Compiler.GetCheckedMode();
            this.CheckedContext.IsConstant = true;

            errorsBeforeBind = Compiler.ErrorCount();

            EXPR rval;

            switch (methInfo.MethodSym.MethodKind)
            {
                case MethodKindEnum.Ctor:
                    rval = BindConstructor(methInfo);
                    break;

                case MethodKindEnum.Dtor:
                    rval = BindDestructor(methInfo);
                    break;

                case MethodKindEnum.PropAccessor:
                    rval = BindPropertyAccessor(methInfo);
                    break;

                case MethodKindEnum.EventAccessor:
                    rval = BindEventAccessor(methInfo);
                    break;

                default:
                    //rval = methInfo.MethSym.IsInterfaceImpl ?
                    //    BindIfaceImpl(methInfo) : BindMethod(methInfo);
                    if (methInfo.MethodSym.IsInterfaceImpl)
                    {
                        rval = BindIfaceImpl(methInfo);
                    }
                    else
                    {
                        rval = BindMethod(methInfo);
                    }
                    break;
            }

            CErrorSuppression es = new CErrorSuppression();

            //--------------------------------------------------------
            // (CS4) Emit the runtime-bind class and its members.
            //--------------------------------------------------------
            if (FoundRuntimeBindedObject())
            {
            }

            //--------------------------------------------------------
            // (CS3) Compile the bodies of the lambda expressions
            //--------------------------------------------------------
            for (AnonMethInfo ami = this.firstAnonymousMethodInfo;
                ami != null;
                ami = ami.NextInfo)
            {
                if (ami.ParseTreeNode.Kind == NODEKIND.LAMBDAEXPR &&
                    ami.BodyBlockExpr == null)
                {
                    BindLambdaExpressionInner(ami);
                }
            }

#if DEBUG
            StringBuilder sb = new StringBuilder();
            sb.Length = 0;
            DebugUtil.DebugNodesOutput(sb);
            sb.Length = 0;
            DebugUtil.DebugSymsOutput(sb);
            sb.Length = 0;
            Compiler.MainSymbolManager.GlobalSymbolTable.Debug(sb);
            sb.Length = 0;
            DebugUtil.DebugExprsOutput(sb);
#endif

            //--------------------------------------------------------
            // PostBinding
            //--------------------------------------------------------
            if ((this.bindCallback.ForcePostBind() ||
                !Compiler.FAbortEarly(errorsBeforeBind, es)) &&
                rval != null &&
                rval.IsOK)
            {
                Compiler.SetLocation(COMPILER.STAGE.SCAN);
                this.bindCallback.StartPostBinding(rval as EXPRBLOCK);
                PostBindCompile(rval as EXPRBLOCK);

                // PostBindCompile marked all the anon methods that are actually used
                // (in reachable code), so filter out all the others.

                if (this.firstAnonymousMethodInfo != null)
                {
                    // Filter out the unused ones.
                    FixUpAnonMethInfoLists(ref firstAnonymousMethodInfo);
                }
                this.bindCallback.EndPostBinding(rval as EXPRBLOCK);
            }

            methInfo.FirstAnonymousMethodInfo = this.firstAnonymousMethodInfo;

            this.methodInfo = null;
            this.firstAnonymousMethodInfo = null;
            this.currentAnonymousMethodInfo = null;

            ResetUnsafe();

            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.CompileFirstField
        //
        /// <summary>
        /// called to compile the value of a constant field.  tree here points to
        /// the expression being assigned to the field...
        /// </summary>
        /// <param name="fieldSym"></param>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR CompileFirstField(MEMBVARSYM fieldSym, BASENODE treeNode)
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);

            // Save and restore state.
            FncBindState state = new FncBindState(this);

            EXPR rval = null;
            try
            {
                MEMBVARSYM oldFieldSym = this.originalFieldSym;

                this.innermostCatchScopeSym = null;
                this.innermostTryScopeSym = null;
                this.innermostFinallyScopeSym = null;
                this.innermostSwitchScopeSym = null;
                this.OuterScopeSym = null;

                currentScopeSym = Compiler.LocalSymbolManager.CreateLocalSym(
                    SYMKIND.SCOPESYM,
                    null,
                    null) as SCOPESYM;
                currentScopeSym.NestingOrder = 1;

                DebugUtil.Assert(fieldSym.IsUnevaled);
                InitField(fieldSym);
                this.originalFieldSym = this.currentFieldSym;

                // Just bind the initializer...
                rval = BindConstInitializer(fieldSym, treeNode);

                // Restore the previous field.
                this.originalFieldSym = oldFieldSym;
            }
            finally
            {
                state.Restore();
            }

            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.CompileNextField
        //
        /// <summary>
        /// called to compile a constant field
        /// which was referenced during the compilation of another constant field...
        /// </summary>
        /// <param name="pAFSym"></param>
        /// <param name="tree"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR CompileNextField(MEMBVARSYM pAFSym, BASENODE tree)
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);

            // Save and restore state.
            FncBindState state = new FncBindState(this);

            EXPR rval = null;
            try
            {
                InitField(pAFSym);

                // Just bind the initializer...
                rval = BindConstInitializer(pAFSym, tree);
            }
            finally
            {
                state.Restore();
            }
            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.IsThisPointer
        //
        /// <summary></summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal bool IsThisPointer(EXPR expr)
        {
            return (
                expr.Kind == EXPRKIND.LOCAL &&
                (expr as EXPRLOCAL).LocVarSym == this.thisPointerSym);
        }

        //    bool __fastcall hasThisPointer();
        //    LOCSLOTINFO * getThisPointerSlot();

        //------------------------------------------------------------
        // FUNCBREC.DiscardLocalState
        //
        /// <summary></summary>
        //------------------------------------------------------------
        internal void DiscardLocalState()
        {
            this.OuterScopeSym = null;              // the argument scope
            this.currentScopeSym = null;            // the current scope
            this.innermostFinallyScopeSym = null;   // the scope of the innermost finally, or pOuterScope if none...
            this.innermostTryScopeSym = null;       // the scope of the innermost try, or pOuterScope if none...
            this.innermostSwitchScopeSym = null;    // the scope of the innermost switch, or NULL if none
            this.innermostCatchScopeSym = null;     // the scope of the innermose catch, or NULL if none
            this.currentBlockExpr = null;
            this.CurrentSwitchExpr = null;
            this.thisPointerSym = null;

            // ONLY used by anonymous methods, keeps a <this> pointer for the outermost containing method.
            this.outerThisPointerSym = null;

            userLabelList = null;
            //pUserLabelList = null;
            this.gotoExprs = null;

        }

        //--------------------------------------------------
        // FUNCBREC.RewriteMoveNext
        //
        // Moved to Iterator.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.MakeIterGet
        //
        // Moved to Iterator.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.MakeIterGetEnumerator
        //
        // Moved to Iterator.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.MakeIterCur
        //
        // Moved to Iterator.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.MakeIterReset
        //
        // Moved to Iterator.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.MakeIterDispose
        //
        // Moved to Iterator.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.MakeIterCtor
        //
        // Moved to Iterator.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.FixUpAnonMethInfoLists
        //
        // Moved to AnonymousMethod.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.RewriteAnonDelegateBodies
        //
        // Moved to AnonymousMethod.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.MakeAnonCtor
        //
        // Moved to AnonymousMethod.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.GetAttributeValue (1)
        //
        /// <summary></summary>
        /// <param name="contextSym"></param>
        /// <param name="expr"></param>
        /// <param name="rval"></param>
        /// <returns></returns>
        //--------------------------------------------------
        internal bool GetAttributeValue(PARENTSYM contextSym, EXPR expr, out bool rval)
        {
            rval = false;
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            InitAttrBindContext(contextSym);

            expr = MustConvert(expr, this.GetRequiredPredefinedType(PREDEFTYPE.BOOL), 0);
            if (expr == null)
            {
                return false;
            }

            if (expr.Kind != EXPRKIND.CONSTANT)
            {
                Compiler.Error(expr.TreeNode, CSCERRID.ERR_BadAttributeParam);
                return false;
            }

            rval = (expr as EXPRCONSTANT).ConstVal.GetBool();
            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.GetAttributeValue (2)
        //
        /// <summary></summary>
        /// <param name="contextSym"></param>
        /// <param name="expr"></param>
        /// <param name="rval"></param>
        /// <returns></returns>
        //--------------------------------------------------
        internal bool GetAttributeValue(PARENTSYM contextSym, EXPR expr, out int rval)
        {
            rval = 0;
            DebugUtil.Assert(compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            InitAttrBindContext(contextSym);

            expr.TypeSym = expr.TypeSym.UnderlyingType();
            expr = MustConvert(expr, this.GetRequiredPredefinedType(PREDEFTYPE.INT), 0);
            if (expr == null)
            {
                return false;
            }

            if (expr.Kind != EXPRKIND.CONSTANT)
            {
                compiler.Error(expr.TreeNode, CSCERRID.ERR_BadAttributeParam);
                return false;
            }

            rval = (expr as EXPRCONSTANT).ConstVal.GetInt();
            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.GetAttributeValue (3)
        //
        /// <summary></summary>
        /// <param name="contextSym"></param>
        /// <param name="expr"></param>
        /// <param name="rval"></param>
        /// <returns></returns>
        //--------------------------------------------------
        internal bool GetAttributeValue(PARENTSYM contextSym, EXPR expr, out string rval)
        {
            rval = null;
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            InitAttrBindContext(contextSym);

            expr = MustConvert(expr, this.GetRequiredPredefinedType(PREDEFTYPE.STRING), 0);
            if (expr == null || !expr.IsOK)
            {
                return false;
            }

            if (expr.Kind != EXPRKIND.CONSTANT)
            {
                Compiler.Error(expr.TreeNode, CSCERRID.ERR_BadAttributeParam);
                return false;
            }

            rval = (expr as EXPRCONSTANT).ConstVal.GetString();
            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.GetAttributeValue (4)
        //
        /// <summary></summary>
        /// <param name="contextSym"></param>
        /// <param name="expr"></param>
        /// <param name="rval"></param>
        /// <returns></returns>
        //--------------------------------------------------
        internal bool GetAttributeValue(PARENTSYM contextSym, EXPR expr, out TYPESYM rval)
        {
            rval = null;
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            InitAttrBindContext(contextSym);

            expr = MustConvert(expr, this.GetRequiredPredefinedType(PREDEFTYPE.TYPE), 0);
            if (expr == null)
            {
                return false;
            }

            if (expr.Kind == EXPRKIND.CONSTANT)
            {
                rval = null;
            }
            else if (expr.Kind == EXPRKIND.TYPEOF)
            {
                rval = (expr as EXPRTYPEOF).SourceTypeSym;
            }
            else
            {
                Compiler.Error(expr.TreeNode, CSCERRID.ERR_BadAttributeParam);
                return false;
            }
            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.BindAttribute
        //
        /// <summary>
        /// Create and return an EXPRCALL instance of the constructor
        /// of the specified attribute class with given arguments.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="attributeType"></param>
        /// <param name="attribute"></param>
        /// <param name="firstNamedArg"></param>
        /// <param name="lastNamedArg"></param>
        /// <returns></returns>
        //--------------------------------------------------
        internal EXPRCALL BindAttribute(
            PARENTSYM context,
            AGGTYPESYM attributeType,
            ATTRNODE attribute,
            out EXPR firstNamedArg,
            out EXPR lastNamedArg)
        {
            firstNamedArg = null;
            lastNamedArg = null;
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            SCOPESYM scopeSym = InitAttrBindContext(context);

            // attributes are always in a safe context
            UnsafeStatesEnum oldUnsafeContext = this.unsafeState;
            this.SetUnsafe(false);

            EXPR args = BindAttrArgs(
                attributeType,
                attribute,
                ref firstNamedArg,
                ref lastNamedArg);
            // args is the first EXPR instance of the list of the positional attribute arguments.
            if (args != null && !args.IsOK)
            {
                return null;
            }

            EXPR callExpr = CreateConstructorCall(
                attribute,
                attribute,
                attributeType,
                null,
                args,
                MemLookFlagsEnum.NewObj);
            if (callExpr.Kind != EXPRKIND.CALL)
            {
                callExpr = null;
            }

            this.SetUnsafeState(oldUnsafeContext);

            // restore it (useful if we are doing param attrs...)
            this.OuterScopeSym = scopeSym;

            return SetNodeExpr(attribute, callExpr) as EXPRCALL;
        }

        //------------------------------------------------------------
        // FUNCBREC.CreateStringConstant
        //
        /// <summary>
        /// Create a CONSTVAL instance which has the given string.
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal CONSTVAL CreateStringConstant(string str)
        {
            CONSTVAL rval = new CONSTVAL();
            if (str != null)
            {
                rval.SetString(str);
            }
            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindSimplePredefinedAttribute (1)
        //
        /// <summary>
        /// Bind a parameterless predefined attribute
        /// </summary>
        /// <param name="pt"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindSimplePredefinedAttribute(PREDEFTYPE pt)
        {
            return BindSimplePredefinedAttribute(pt, null);
        }

        //------------------------------------------------------------
        // FUNCBREC.BindSimplePredefinedAttribute (2)
        //
        /// <summary>
        /// Bind a predefined attribute with a single parameter.
        /// </summary>
        /// <param name="pt"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindSimplePredefinedAttribute(PREDEFTYPE pt, EXPR args)
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);

            this.methodSym = null;
            this.currentFieldSym = null;
            this.originalFieldSym = null;

            // We null out the scope so as not to get any cache hits
            SCOPESYM scopeSym = this.OuterScopeSym;
            this.OuterScopeSym = null;

            AGGTYPESYM cls = Compiler.GetOptPredefType(pt, true);
            if (cls == null)
            {
                return null;
            }
            EXPR expr = CreateConstructorCall(null, null, cls, null, args, MemLookFlagsEnum.NewObj);

            // restore it (useful if we are doing param attrs...)
            this.OuterScopeSym = scopeSym;

            return expr;
        }

        //------------------------------------------------------------
        // FUNCBREC.bindStringPredefinedAttribute
        //
        /// <summary>
        /// Bind a predefined attribute with a single string parameter.
        /// </summary>
        /// <param name="pt"></param>
        /// <param name="arg"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindStringPredefinedAttribute(PREDEFTYPE pt, string arg)
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);

            return BindSimplePredefinedAttribute(
                pt,
                NewExprConstant(null, Compiler.GetReqPredefType(PREDEFTYPE.STRING, true), new ConstValInit(arg)));
        }

        //------------------------------------------------------------
        // FUNCBREC.bindStructLayoutArgs
        //
        /// <summary></summary>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindStructLayoutArgs()
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);

            // LayoutKind.Sequential
            AGGTYPESYM cls = Compiler.GetOptPredefType(PREDEFTYPE.LAYOUTKIND, true);
            DebugUtil.Assert(cls != null);

            return NewExprConstant(
                null,
                cls,
                new ConstValInit(Compiler.ClsDeclRec.GetLayoutKindValue(PREDEFNAME.SEQUENTIAL)));
        }

        //------------------------------------------------------------
        // FUNCBREC.BindStructLayoutNamedArgs
        //
        /// <summary></summary>
        /// <param name="hasNonZeroSize"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindStructLayoutNamedArgs(bool hasNonZeroSize)
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);

            if (hasNonZeroSize)
            {
                return null;
            }

            // add Size = 1
            return BindFieldNamedArgument(
                Compiler.GetOptPredefType(PREDEFTYPE.STRUCTLAYOUT, true),
                PREDEFNAME.Size,
                new ConstValInit((int)1));
        }

        //------------------------------------------------------------
        // FUNCBREC.BindSkipVerifyArgs
        //
        /// <summary></summary>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindSkipVerifyArgs()
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            // this is just one arg, the value of SecurityAction.RequestMinumum

            AGGTYPESYM cls = Compiler.GetOptPredefType(PREDEFTYPE.SECURITYACTION,true);
            DebugUtil.Assert(cls != null);

            string name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.REQUESTMINIMUM);
            MemberLookup mem = new MemberLookup();

            if (!mem.Lookup(
                    Compiler,
                    cls,
                    null,
                    this.parentDeclSym,
                    name,
                    0,
                    MemLookFlagsEnum.UserCallable) ||
                !mem.FirstSym.IsMEMBVARSYM)
            {
                Compiler.Error(
                    CSCERRID.ERR_MissingPredefinedMember,
                    new ErrArg(cls.Name),
                    new ErrArg(name));
                return NewError(null, null);
            }

            EXPR rval = NewExprConstant(null, cls, mem.FirstSymWithType.FieldSym.ConstVal);
            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindSkipVerifyNamedArgs
        //
        /// <summary></summary>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindSkipVerifyNamedArgs()
        {
            return BindPropertyNamedArgument(
                PREDEFTYPE.SECURITYPERMATTRIBUTE,
                PREDEFNAME.SKIPVERIFICATION,
                new ConstValInit(true));
        }

        //------------------------------------------------------------
        // FUNCBREC.BindDebuggableArgs
        //
        /// <summary>
        /// Find the SYM instance of System.Diagnostics.DebuggableAttribute.DebuggingModes enumeration.
        /// </summary>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindDebuggableArgs()
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);

            AGGSYM debuggableAggSym = Compiler.GetOptPredefAgg(PREDEFTYPE.DEBUGGABLEATTRIBUTE, true);
            if (debuggableAggSym == null)
            {
                return null;
            }

            string name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.DEBUGGINGMODES_CLASS);
            AGGSYM debuggingModesEnumAggSym = Compiler.MainSymbolManager.LookupAggMember(
                name,
                debuggableAggSym,
                SYMBMASK.AGGSYM) as AGGSYM;

            //--------------------------------------------------
            // If only one "DebuggingModes" enumeration exists, check its members.
            //--------------------------------------------------
            if (debuggingModesEnumAggSym != null &&
                debuggingModesEnumAggSym.NextSameNameSym == null &&
                debuggingModesEnumAggSym.IsEnum)
            {
                Compiler.EnsureState(debuggingModesEnumAggSym, AggStateEnum.Prepared);
                AGGTYPESYM debuggingModesEnumAts = debuggingModesEnumAggSym.GetThisType();

                // Get the enum members we care about
                MEMBVARSYM membNoOptimize = null;
                MEMBVARSYM membTrackJit = null;
                MEMBVARSYM membIgnorePdb = null;
                MEMBVARSYM membEnableENC = null;

                name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.DISABLEOPTIMIZATIONS);
                membNoOptimize = Compiler.MainSymbolManager.LookupAggMember(
                    name,
                    debuggingModesEnumAggSym,
                    SYMBMASK.MEMBVARSYM) as MEMBVARSYM;

                name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.DEFAULT);
                membTrackJit = Compiler.MainSymbolManager.LookupAggMember(
                    name,
                    debuggingModesEnumAggSym,
                    SYMBMASK.MEMBVARSYM) as MEMBVARSYM;

                name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.IGNORESYMBOLSTORESEQUENCEPOINTS);
                membIgnorePdb = Compiler.MainSymbolManager.LookupAggMember(
                    name,
                    debuggingModesEnumAggSym,
                    SYMBMASK.MEMBVARSYM) as MEMBVARSYM;

                name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.ENABLEEDITANDCONTINUE);
                membEnableENC = Compiler.MainSymbolManager.LookupAggMember(
                    name,
                    debuggingModesEnumAggSym,
                    SYMBMASK.MEMBVARSYM) as MEMBVARSYM;

                if (membNoOptimize == null ||
                    !membNoOptimize.IsConst ||
                    membNoOptimize.TypeSym != debuggingModesEnumAts ||

                    membTrackJit == null ||
                    !membTrackJit.IsConst ||
                    membTrackJit.TypeSym != debuggingModesEnumAts ||

                    membIgnorePdb == null ||
                    !membIgnorePdb.IsConst ||
                    membIgnorePdb.TypeSym != debuggingModesEnumAts ||

                    membEnableENC == null ||
                    !membEnableENC.IsConst ||
                    membEnableENC.TypeSym != debuggingModesEnumAts ||

                    FindPredefMeth(
                        null,
                        PREDEFNAME.CTOR,
                        debuggableAggSym.GetThisType(),
                        Compiler.MainSymbolManager.AllocParams(debuggingModesEnumAts),
                        false,
                        MemLookFlagsEnum.None) == null)
                {
                    goto OLD_STYLE_DEBUGGABLE;
                }

                if (!Compiler.OptionManager.GenerateDebugInfo)
                {
                    // NOTE: on the new style debuggable attribute,
                    // we need to emit it even for the pdbOnly case
                    // This is all the default behavior (or the JIT will ignore it)
                    return null;
                }

                CONSTVAL cv = membIgnorePdb.ConstVal;
                int flags = cv.GetInt();

                if (!Compiler.OptionManager.Optimize)
                {
                    flags |= membEnableENC.ConstVal.GetInt();
                }

                if (Compiler.OptionManager.GenerateDebugInfo &&
                    !Compiler.OptionManager.IsDebugInfoPDBOnly)
                {
                    flags |= membTrackJit.ConstVal.GetInt();
                }

                if (!Compiler.OptionManager.Optimize)
                {
                    flags |= membNoOptimize.ConstVal.GetInt();
                }

                cv.SetInt(flags);
                return NewExprConstant(null, debuggingModesEnumAts, cv);
            }

        OLD_STYLE_DEBUGGABLE:
            if (!Compiler.OptionManager.GenerateDebugInfo||
                Compiler.OptionManager.IsDebugInfoPDBOnly)
            {
                // This is all the default behavior (or the JIT will ignore it)
                return null;
            }

            CONSTVAL cv1 = new CONSTVAL();
            cv1.SetBool(
                Compiler.OptionManager.GenerateDebugInfo &&
                !Compiler.OptionManager.IsDebugInfoPDBOnly);

            EXPR eDebug = NewExprConstant(
                null,
                Compiler.GetReqPredefType(PREDEFTYPE.BOOL, true),
                cv1);

            CONSTVAL cv2 = new CONSTVAL();
            cv2.SetBool(!Compiler.OptionManager.Optimize);

            EXPR eDisableOpt = NewExprConstant(
                null,
                Compiler.GetReqPredefType(PREDEFTYPE.BOOL, true),
                cv2);

            return NewExprBinop(null, EXPRKIND.LIST, null, eDebug, eDisableOpt);
        }

        //------------------------------------------------------------
        // FUNCBREC.BindFixedBufferArgs
        //
        /// <summary></summary>
        /// <param name="fieldSym"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindFixedBufferArgs(MEMBVARSYM fieldSym)
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);

            // The first argument is the underlying element type of the
            // fixed buffer field, the second is the count of such elements

            EXPRTYPEOF typeofExpr = NewExpr(
                null,
                EXPRKIND.TYPEOF,
                GetRequiredPredefinedType(PREDEFTYPE.TYPE)) as EXPRTYPEOF;
            typeofExpr.SourceTypeSym = (fieldSym.TypeSym as PTRSYM).BaseTypeSym;
            typeofExpr.Flags |= EXPRFLAG.CANTBENULL;

            TYPESYM paramSym = GetRequiredPredefinedType(PREDEFTYPE.TYPEHANDLE);
            TypeArray paramList = Compiler.MainSymbolManager.AllocParams(paramSym);
            typeofExpr.MethodSym = FindPredefMeth(
                null,
                PREDEFNAME.GETTYPEFROMHANDLE,
                GetRequiredPredefinedType(PREDEFTYPE.TYPE),
                paramList,
                true,
                MemLookFlagsEnum.None);

            if (typeofExpr.MethodSym == null)
            {
                return NewError(null, null);
            }

            EXPR length = NewExprConstant(
                null,
                GetRequiredPredefinedType(PREDEFTYPE.INT),
                fieldSym.ConstVal);

            return NewExprBinop(null, EXPRKIND.LIST, null, typeofExpr, length);
        }

        //------------------------------------------------------------
        // FUNCBREC.BindCharSetNamedArg
        //
        /// <summary></summary>
        /// <param name="cls"></param>
        /// <param name="defaultCharSet"></param>
        /// <param name="firstNamedArguments"></param>
        /// <param name="lastNamedArguments"></param>
        //------------------------------------------------------------
        internal void BindCharSetNamedArg(
            AGGTYPESYM cls,
            System.Runtime.InteropServices.CharSet defaultCharSet,
            ref EXPR firstNamedArguments,
            ref EXPR lastNamedArguments)
        {
            NewList(
                BindFieldNamedArgument(
                    cls,
                    PREDEFNAME.CharSet,
                    new ConstValInit((int)defaultCharSet)),
                ref firstNamedArguments,
                ref lastNamedArguments);
        }

        //------------------------------------------------------------
        // FUNCBREC.BindCompilationRelaxationsAttributeArgs
        //
        /// <summary></summary>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindCompilationRelaxationsAttributeArgs()
        {
            // NoStringInterning
            return NewExprConstant(
                null,
                Compiler.GetReqPredefType(PREDEFTYPE.INT, true),
                new ConstValInit(8));
        }

        //------------------------------------------------------------
        // FUNCBREC.BindRuntimeCompatibilityAttributeNamedArgs
        //
        /// <summary></summary>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindRuntimeCompatibilityAttributeNamedArgs()
        {
            return BindPropertyNamedArgument(
                PREDEFTYPE.RUNTIMECOMPATIBILITY,
                PREDEFNAME.WRAPNONEXCEPTIONTHROWS,
                new ConstValInit(true));
        }

        //------------------------------------------------------------
        // FUNCBREC.BindPropertyNamedArgument
        //
        /// <summary></summary>
        /// <param name="ptAttributeType"></param>
        /// <param name="pnPropertyName"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindPropertyNamedArgument(
            PREDEFTYPE ptAttributeType,
            PREDEFNAME pnPropertyName,
            CONSTVAL value)
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);

            AGGTYPESYM cls = Compiler.GetOptPredefType(ptAttributeType, true);
            DebugUtil.Assert(cls != null);

            string name = Compiler.NameManager.GetPredefinedName(pnPropertyName);
            MemberLookup mem = new MemberLookup();

            if (!mem.Lookup(
                    Compiler,
                    cls,
                    null,
                    this.parentDeclSym,
                    name,
                    0,
                    MemLookFlagsEnum.UserCallable) ||
                !mem.FirstSym.IsPROPSYM)
            {
                Compiler.Error(CSCERRID.ERR_MissingPredefinedMember,
                    new ErrArg(cls.Name), new ErrArg(name));
                return NewError(null, null);
            }

            PropWithType pwt = mem.FirstSymWithType as PropWithType;

            EXPRPROP propExpr = NewExpr(null, EXPRKIND.PROP, pwt.PropSym.ReturnTypeSym) as EXPRPROP;
            propExpr.SlotPropWithType = pwt;
            if (pwt.PropSym.GetMethodSym != null)
            {
                propExpr.GetMethodWithType.Set(pwt.PropSym.GetMethodSym, pwt.AggTypeSym);
            }
            if (pwt.PropSym.SetMethodSym != null)
            {
                propExpr.SetMethodWithType.Set(pwt.PropSym.SetMethodSym, pwt.AggTypeSym);
            }
            propExpr.ArgumentsExpr = null;
            propExpr.ObjectExpr = null;

            EXPR exprValue = NewExprConstant(null, propExpr.TypeSym, value);
            EXPR rval = NewExprBinop(null, EXPRKIND.ASSG, propExpr.TypeSym, propExpr, exprValue);

            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.bindFieldNamedArgument
        //
        /// <summary></summary>
        /// <param name="attributeType"></param>
        /// <param name="pnFieldName"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPR BindFieldNamedArgument(
            AGGTYPESYM attributeType,
            PREDEFNAME pnFieldName,
            CONSTVAL value)
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            DebugUtil.Assert(attributeType != null);

            string name = Compiler.NameManager.GetPredefinedName(pnFieldName);
            MemberLookup mem = new MemberLookup();

            if (!mem.Lookup(
                    Compiler,
                    attributeType,
                    null,
                    this.parentDeclSym,
                    name,
                    0,
                    MemLookFlagsEnum.UserCallable) ||
                !mem.FirstSym.IsMEMBVARSYM)
            {
                Compiler.Error(CSCERRID.ERR_MissingPredefinedMember,
                    new ErrArg(attributeType.Name),
                    new ErrArg(name));
                return NewError(null, null);
            }

            FieldWithType fwt = mem.FirstSymWithType as FieldWithType;

            EXPRFIELD fieldExpr = NewExpr(null, EXPRKIND.FIELD, fwt.FieldSym.TypeSym) as EXPRFIELD;
            fieldExpr.FieldWithType = fwt;
            fieldExpr.ObjectExpr = null;

            return NewExprBinop(
                null,
                EXPRKIND.ASSG,
                fieldExpr.TypeSym,
                fieldExpr,
                NewExprConstant(null, fieldExpr.TypeSym, value));
        }

        //------------------------------------------------------------
        // FUNCBREC.RealizeStringConcat
        //
        /// <summary>
        /// Realize the given string concatenation.
        /// </summary>
        /// <param name="expr"></param>
        //------------------------------------------------------------
        internal void RealizeStringConcat(EXPRCONCAT expr)
        {
            bool allStrings = true;  // Are all arguments to the concat strings?
            AGGTYPESYM stringTypeSym = GetRequiredPredefinedType(PREDEFTYPE.STRING);

            DebugUtil.Assert((expr.Flags & EXPRFLAG.UNREALIZEDCONCAT) != 0);
            expr.Flags &= ~EXPRFLAG.UNREALIZEDCONCAT;

            // Scan the list of things being concatinated to see if they are 
            // all strings or not.
            EXPR temp = expr.List;
            while (temp != null)
            {
                EXPR item;
                if (temp.Kind == EXPRKIND.LIST)
                {
                    item = temp.AsBIN.Operand1;
                    temp = temp.AsBIN.Operand2;
                }
                else
                {
                    item = temp;
                    temp = null;
                }

                if (item.TypeSym != stringTypeSym)
                {
                    allStrings = false;
                    break;
                }
            }

            // We compile this to 4 different possibilities, depending on the arguments:
            // 1. <= 4 string arguments.
            //     string.Concat(string, string) or string.Concat(string, string, string)
            // 2. > 4 string arguments
            //     string.Concat(string[])
            // 3. <= 3 arguments, at least one not a string
            //     string.Concat(object, object) or string.Concat(object, object, object)
            // 4. > 3 arguments, at least one not a string
            //     string.Concat(object[])

            EXPR args;
            //if (expr.Count > (allStrings ? 4U : 3U))
            if (expr.Count > (allStrings ? 4 : 3))
            {
                // Create array from arguments.
                args = NewExpr(
                    null,
                    EXPRKIND.ARRINIT,
                    compiler.MainSymbolManager.GetArray(
                    GetRequiredPredefinedType(allStrings ? PREDEFTYPE.STRING : PREDEFTYPE.OBJECT),
                    1,
                    allStrings ? typeof(string[]) : typeof(object[])));
                EXPRARRINIT aiExpr = args as EXPRARRINIT;
                aiExpr.ArgumentsExpr = expr.List;
                //(args as EXPRARRINIT).dimSize = expr.Count;
                //(args as EXPRARRINIT).dimSizes = &(args.asARRINIT().dimSize);
                if (aiExpr.DimSizes == null)
                {
                    aiExpr.DimSizes = new List<int>();
                }
                aiExpr.DimSizes.Add(expr.Count);
                args.Flags |= (expr.Flags & EXPRFLAG.PUSH_OP_FIRST);
            }
            else
            {
                args = expr.List;
            }

            // Call static method String.Concat.
            EXPR call = BindPredefMethToArgs(
                expr.TreeNode,
                PREDEFNAME.STRCONCAT,
                stringTypeSym,
                null,
                args,
                null);

            expr.List = call;
        }

        //------------------------------------------------------------
        // FUNCBREC.IsManagedType
        //
        /// <summary></summary>
        /// <param name="typeSym"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal bool IsManagedType(TYPESYM typeSym)
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            Compiler.EnsureState(typeSym, AggStateEnum.Prepared);

            if (typeSym.IsVOIDSYM)
            {
                return false;
            }

            AGGSYM tempAggSym;

            switch (typeSym.FundamentalType())
            {
                case FUNDTYPE.NONE:
                case FUNDTYPE.REF:
                case FUNDTYPE.VAR:
                    return true;

                case FUNDTYPE.STRUCT:
                    if (typeSym.IsNUBSYM)
                    {
                        return true;
                    }

                    tempAggSym = typeSym.GetAggregate();
                    DebugUtil.Assert(!tempAggSym.IsManagedStruct || !tempAggSym.IsUnmanagedStruct);

                    // See if we already know.
                    if (tempAggSym.IsManagedStruct || tempAggSym.IsUnmanagedStruct)
                    {
                        return tempAggSym.IsManagedStruct;
                    }

                    // Generics are always managed.
                    if (tempAggSym.AllTypeVariables.Count > 0)
                    {
                        tempAggSym.IsManagedStruct = true;
                        return true;
                    }

                    for (SYM ps = tempAggSym.FirstChildSym; ps != null; ps = ps.NextSym)
                    {
                        if (ps.IsMEMBVARSYM && !(ps as MEMBVARSYM).IsStatic &&
                            IsManagedType((ps as MEMBVARSYM).TypeSym))
                        {
                            tempAggSym.IsManagedStruct = true;
                            return true;
                        }
                    }
                    tempAggSym.IsUnmanagedStruct = true;
                    return false;

                default:
                    return false;
            }
        }


        //------------------------------------------------------------
        // FUNCBREC.IsCastOrExpr
        //------------------------------------------------------------
        //    static bool isCastOrExpr(EXPR * search, EXPR * target);

        //------------------------------------------------------------
        // FUNCBREC.SetUnsafe
        //
        /// <summary>
        /// Set this.unsafeState field.
        /// </summary>
        /// <param name="isUnsafe"></param>
        //------------------------------------------------------------
        internal void SetUnsafe(bool isUnsafe)
        {
            unsafeState = isUnsafe ? UnsafeStatesEnum.Unsafe : UnsafeStatesEnum.Safe;
            unsafeErrorGiven = false;
        }

        //------------------------------------------------------------
        // FUNCBREC.SetUnsafeState
        //
        /// <summary></summary>
        /// <param name="newState"></param>
        //------------------------------------------------------------
        internal void SetUnsafeState(UnsafeStatesEnum newState)
        {
            this.unsafeState = newState;
        }

        //------------------------------------------------------------
        // FUNCBREC.ResetUnsafe
        //
        /// <summary></summary>
        //------------------------------------------------------------
        internal void ResetUnsafe()
        {
            this.unsafeState = UnsafeStatesEnum.Unknown;
        }

        //------------------------------------------------------------
        // FUNCBREC.IsLocalDefinitelyAssigned
        //
        // Call only when post binding is in progress
        //------------------------------------------------------------
        //bool IsLocalDefinitelyAssigned(LOCVARSYM * local, BitSet & bset, bool * pfPartial = NULL);

        //------------------------------------------------------------
        // FUNCBREC.ResetUniqueNames
        //
        /// <summary>
        /// call when finished compiling an outer-most class because
        /// no name should 'escape' or be more visible than the user's class.
        /// </summary>
        //------------------------------------------------------------
        internal void ResetUniqueNames()
        {
            uniqueNameIndex = 0;
        }
        
        //protected:
        //// Persistent members:

        //private:

        //------------------------------------------------------------
        // FUNCBREC.ResetUnsafe
        //
        /// <summary></summary>
        /// <returns></returns>
        //------------------------------------------------------------
        private bool IsUnsafeContext()
        {
            DebugUtil.Assert(this.unsafeState != UnsafeStatesEnum.Unknown);
            return this.unsafeState == UnsafeStatesEnum.Unsafe;
        }

        //------------------------------------------------------------
        // FUNCBREC.GetConvKind
        //
        /// <summary></summary>
        /// <param name="srcPdType"></param>
        /// <param name="dstPdType"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        static private ConvKindEnum GetConvKind(PREDEFTYPE srcPdType, PREDEFTYPE dstPdType)
        {
            if ((int)srcPdType < SymbolUtil.NUM_SIMPLE_TYPES && (int)dstPdType < SymbolUtil.NUM_SIMPLE_TYPES)
            {
                return (ConvKindEnum)((int)simpleTypeConversions[(int)srcPdType, (int)dstPdType] & (int)0x0F);
            }
            if (srcPdType == dstPdType || dstPdType == PREDEFTYPE.OBJECT && srcPdType < PREDEFTYPE.COUNT)
            {
                return ConvKindEnum.Implicit;
            }
            if (srcPdType == PREDEFTYPE.OBJECT && dstPdType < PREDEFTYPE.COUNT)
            {
                return ConvKindEnum.Explicit;
            }
            return ConvKindEnum.Unknown;
        }

        //------------------------------------------------------------
        // FUNCBREC.WhichTypeIsBetter (1)
        //
        /// Determined which predefined type is better relative to a given type. It is assumed that
        /// the given type is implicitly convertible to both of the predefined types (possibly via
        /// a user defined conversion, method group conversion, etc).
        //------------------------------------------------------------
        //    BetterTypeEnum WhichTypeIsBetter(PREDEFTYPE pt1, PREDEFTYPE pt2, TYPESYM * typeGiven);
        private BetterTypeEnum WhichTypeIsBetter(PREDEFTYPE pt1, PREDEFTYPE pt2, TYPESYM typeGiven)
        {
            if (pt1 == pt2)
            {
                return BetterTypeEnum.Same;
            }
            if (typeGiven.IsPredefType(pt1))
            {
                return BetterTypeEnum.Left;
            }
            if (typeGiven.IsPredefType(pt2))
            {
                return BetterTypeEnum.Right;
            }
            if ((int)pt1 <= SymbolUtil.NUM_EXT_TYPES && (int)pt2 <= SymbolUtil.NUM_EXT_TYPES)
            {
                return (BetterTypeEnum)g_mpptptBetter[(int)pt1, (int)pt2];
            }
            if (pt2 == PREDEFTYPE.OBJECT && pt1 < PREDEFTYPE.COUNT)
            {
                return BetterTypeEnum.Left;
            }
            if (pt1 == PREDEFTYPE.OBJECT && pt2 < PREDEFTYPE.COUNT)
            {
                return BetterTypeEnum.Right;
            }
            return WhichTypeIsBetter(
                GetOptionalPredefinedType(pt1),
                GetOptionalPredefinedType(pt2),
                typeGiven);
        }

        //------------------------------------------------------------
        // FUNCBREC.WhichTypeIsBetter (2)
        //
        /// <summary>
        /// Determined which type is better relative to a given type. It is assumed that the given type
        /// (or its associated expression) is implicitly convertible to both of the types (possibly via
        /// a user defined conversion, method group conversion, etc).
        /// </summary>
        /// <param name="type1"></param>
        /// <param name="type2"></param>
        /// <param name="typeGiven"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private BetterTypeEnum WhichTypeIsBetter(TYPESYM type1, TYPESYM type2, TYPESYM typeGiven)
        {
            DebugUtil.Assert(type1 != null && type2 != null);

            if (type1 == type2)
            {
                return BetterTypeEnum.Same;
            }
            if (typeGiven == type1)
            {
                return BetterTypeEnum.Left;
            }
            if (typeGiven == type2)
            {
                return BetterTypeEnum.Right;
            }

            bool f12 = CanConvert(type1, type2, 0);
            bool f21 = CanConvert(type2, type1, 0);

            if (f12 != f21)
            {
                return f12 ? BetterTypeEnum.Left : BetterTypeEnum.Right;
            }

            if (!type1.IsNUBSYM ||
                !type2.IsNUBSYM ||
                !(type1 as NUBSYM).BaseTypeSym.IsPredefined() ||
                !(type2 as NUBSYM).BaseTypeSym.IsPredefined())
            {
                return BetterTypeEnum.Neither;
            }

            PREDEFTYPE pt1 = (type1 as NUBSYM).BaseTypeSym.GetPredefType();
            PREDEFTYPE pt2 = (type2 as NUBSYM).BaseTypeSym.GetPredefType();

            if ((int)pt1 <= SymbolUtil.NUM_EXT_TYPES && (int)pt2 <= SymbolUtil.NUM_EXT_TYPES)
            {
                return (BetterTypeEnum)g_mpptptBetter[(int)pt1, (int)pt2];
            }

            return BetterTypeEnum.Neither;
        }

        // The default one is good enough for us...
        //    ~FUNCBREC();

        //------------------------------------------------------------
        // FUNCBREC.InitThisPointer
        //
        /// <summary>
        /// <para>If this.methSym is not static, define "this" instance of the declaring type,
        /// and set it this.thisPointerSym.</para>
        /// </summary>
        //------------------------------------------------------------
        private void InitThisPointer()
        {
            if (!this.methodSym.IsStatic)
            {
                // Enter the this pointer:
                this.thisPointerSym = Compiler.LocalSymbolManager.CreateLocalSym(
                    SYMKIND.LOCVARSYM,
                    Compiler.NameManager.GetPredefinedName(PREDEFNAME.THIS),
                    this.OuterScopeSym) as LOCVARSYM;

                this.thisPointerSym.IsThis = true;
                this.thisPointerSym.Access = ACCESS.PUBLIC;
                this.thisPointerSym.TypeSym = this.parentAggSym.GetThisType();
                if (this.parentAggSym.IsPredefAgg(PREDEFTYPE.G_OPTIONAL))
                {
                    this.thisPointerSym.TypeSym = Compiler.MainSymbolManager.GetNubFromNullable(
                        this.thisPointerSym.TypeSym as AGGTYPESYM);
                }
                this.thisPointerSym.LocSlotInfo.IsParameter = true;
                this.thisPointerSym.LocSlotInfo.HasInit = true;
                if (this.parentAggSym.IsStruct)
                {
                    this.thisPointerSym.LocSlotInfo.IsReferenceParameter = true;
                    if (this.methodSym.IsCtor)
                    {
                        this.thisPointerSym.LocSlotInfo.SetJbitDefAssg(this.uninitedVarCount + 1);
                        this.uninitedVarCount += FlowChecker.GetCbit(Compiler, this.parentAggSym.GetThisType());
                        this.thisPointerSym.LocSlotInfo.HasInit = false;
                    }
                }
            }
            else
            {
                this.thisPointerSym = null;
            }

            this.outerThisPointerSym = this.thisPointerSym;
        }

        //------------------------------------------------------------
        // FUNCBREC.InitField
        //
        /// <summary>
        /// Initialize the expr generator for the eval of a field constant,
        /// if another constant is being evaled already...
        /// </summary>
        /// <param name="field"></param>
        //------------------------------------------------------------
        private void InitField(MEMBVARSYM field)
        {
            DebugUtil.Assert(field != null);

            this.methodSym = null;
            this.currentFieldSym = field;
            this.treeNode = null; // pTree is only used for function members.
            this.classInfo = null;
            this.parentAggSym = currentFieldSym.ClassSym;
            this.parentDeclSym = currentFieldSym.ContainingDeclaration();
            this.typeBindFlags = currentFieldSym.IsContainedInDeprecated()
                ? TypeBindFlagsEnum.NoDeprecated
                : TypeBindFlagsEnum.None;
        }

        //------------------------------------------------------------
        // FUNCBREC.InitMethod
        //
        /// <summary>
        /// <para>
        /// Initialize the fields of this FUNCBREC instance.
        /// <list type="bullet">
        /// <item>Create and set scopes.</item>
        /// <item>Create a LOCVARSYM for "this".</item>
        /// </list>
        /// </para>
        /// </summary>
        /// <param name="methodInfo"></param>
        /// <param name="treeNode"></param>
        /// <param name="aggInfo"></param>
        //------------------------------------------------------------
        private void InitMethod(METHINFO methodInfo, BASENODE treeNode, AGGINFO aggInfo)
        {
            DebugUtil.Assert(
                methodInfo != null &&
                methodInfo.MethodSym != null &&
                treeNode != null &&
                aggInfo != null);
            DebugUtil.Assert(
                treeNode.Kind == NODEKIND.CLASS ||
                treeNode.Kind == NODEKIND.STRUCT ||
                treeNode.Kind == NODEKIND.METHOD ||
                treeNode.Kind == NODEKIND.CTOR ||
                treeNode.Kind == NODEKIND.ACCESSOR ||
                treeNode.Kind == NODEKIND.OPERATOR ||
                treeNode.Kind == NODEKIND.DTOR ||
                treeNode.Kind == NODEKIND.VARDECL ||
                treeNode.Kind == NODEKIND.PROPERTY ||
                treeNode.Kind == NODEKIND.INDEXER);
            DebugUtil.Assert(
                treeNode.Kind != NODEKIND.CLASS ||
                methodInfo.MethodSym.IsCtor ||
                methodInfo.MethodSym.IsInterfaceImpl);
            DebugUtil.Assert(
                treeNode.Kind != NODEKIND.VARDECL && treeNode.Kind != NODEKIND.PROPERTY ||
                methodInfo.MethodSym.IsAnyAccessor);

            this.methodSym = methodInfo.MethodSym;
            this.currentFieldSym = null;
            this.classTypeVariablesForMethod = null;
            this.treeNode = treeNode;
            this.classInfo = aggInfo;
            this.methodInfo = methodInfo;

            this.parentAggSym = this.methodSym.ClassSym;
            this.parentDeclSym = this.methodSym.ContainingDeclaration();

            this.typeBindFlags = this.methodSym.IsContainedInDeprecated() ?
                TypeBindFlagsEnum.NoDeprecated : TypeBindFlagsEnum.None;

            this.OuterScopeSym
                = Compiler.LocalSymbolManager.CreateLocalSym(SYMKIND.SCOPESYM, null, null) as SCOPESYM;
            this.OuterScopeSym.NestingOrder = 0;
#if DEBUG
            this.OuterScopeSym.SetName("Top Scope of Method");
#endif
            methodInfo.OuterScopeSym = this.OuterScopeSym;
            this.innermostCatchScopeSym
                = this.innermostTryScopeSym
                = this.innermostFinallyScopeSym
                = this.currentScopeSym
                = this.OuterScopeSym;
            this.innermostSwitchScopeSym = null;

            // this.InitLabels is initialzed by the initializer.
            this.InitLabels.BreakLabel = null;
            this.InitLabels.ContinueLabel = null;
            this.LoopLabels = InitLabels;

            this.uninitedVarCount = 0;
            this.unreferencedVarCount = 0;
            this.finallyNestingCount = 0;
            this.localCount = 0;
            this.firstAnonymousMethodInfo = null;
            this.currentAnonymousMethodInfo = null;
            this.gotoExprs = null;

            //userLabelList = null;
            //pUserLabelList = &userLabelList;
            this.userLabelList = null;
            this.userLabelListLast = null;

            this.areForwardGotos = false;

            InitThisPointer();

            this.currentBlockExpr = null;
            this.lastNode = null;
        }

        //------------------------------------------------------------
        // FUNCBREC.InitAttrBindContext
        //
        /// <summary>
        /// <para>Initialize the state of the FUNCBREC
        /// to prepare for binding an attribute</para>
        /// <para>Return the old value of this.OuterScopeSym.</para>
        /// </summary>
        /// <param name="contextSym"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private SCOPESYM InitAttrBindContext(PARENTSYM contextSym)
        {
            DebugUtil.Assert(
                contextSym != null &&
                !contextSym.IsBAGSYM &&
                !contextSym.IsTYPESYM);

            this.methodSym = null;
            this.currentFieldSym = null;
            this.originalFieldSym = null;
            this.firstAnonymousMethodInfo = null;
            this.currentAnonymousMethodInfo = null;

            DECLSYM contextDeclSym;

            if (contextSym.IsDECLSYM)
            {
                contextDeclSym = contextSym as DECLSYM;
            }
            else
            {
                contextDeclSym = contextSym.ContainingDeclaration();
            }

            if (this.parentDeclSym != contextDeclSym)
            {
                this.parentDeclSym = contextDeclSym;
                if (this.parentDeclSym.IsAGGDECLSYM)
                {
                    this.parentAggSym = (this.parentDeclSym as AGGDECLSYM).AggSym;
                }
                else
                {
                    this.parentAggSym = null;
                }
                this.classInfo = null;
                this.typeBindFlags =
                    ((this.parentAggSym != null && this.parentAggSym.IsContainedInDeprecated()))
                    ? TypeBindFlagsEnum.NoDeprecated
                    : TypeBindFlagsEnum.None;
            }

            SYM sym = Compiler.LocalSymbolManager.CreateLocalSym(SYMKIND.SCOPESYM, null, null);
            this.currentScopeSym = (sym != null ? (sym as SCOPESYM) : null);
            this.currentScopeSym.NestingOrder = 1;

            // We null out the scope so as not to get any cache hits
            SCOPESYM scope = OuterScopeSym;
            OuterScopeSym = null;
            return scope;
        }

        //------------------------------------------------------------
        // FUNCBREC.DeclareMethodParameters (1)
        //
        /// <summary>
        /// Create declarations for method parameters
        /// </summary>
        /// <param name="methodInfo"></param>
        /// <param name="firstParams"></param>
        /// <param name="lastParams"></param>
        //------------------------------------------------------------
        private void DeclareMethodParameters(
            METHINFO methodInfo,
            ref EXPR firstParams,	 //EXPR ** params)	// = null
            ref EXPR lastParams)
        {
            DebugUtil.Assert(
                methodInfo.ParameterInfoCount == methodInfo.MethodSym.ParameterTypes.Count ||
                methodInfo.ParameterInfoCount == (methodInfo.MethodSym.ParameterTypes.Count - 1) &&
                    methodInfo.MethodSym.ParameterTypes[methodInfo.MethodSym.ParameterTypes.Count - 1] ==
                    Compiler.MainSymbolManager.ArgListSym);

            FindLastNode(firstParams, ref lastParams);

            for (int i = 0; i < methodInfo.ParameterInfoCount; ++i)
            {
                PARAMETERNODE node = methodInfo.ParameterInfos[i].ParameterNode;
                TYPESYM type = methodInfo.MethodSym.ParameterTypes[i];

                LOCVARSYM sym = DeclareParam(
                    methodInfo.ParameterInfos[i].Name,
                    type,
                    0,
                    node != null ? node : this.treeNode,
                    null);

                //if (params)
                //    newList(MakeLocal(null, sym, true), &params);
                NewList(MakeLocal(null, sym, true), ref firstParams, ref lastParams);
            }
        }

        //------------------------------------------------------------
        // FUNCBREC.DeclareMethodParameters (2)
        //
        /// <summary>
        /// Create declarations for method parameters
        /// </summary>
        /// <param name="methodInfo"></param>
        //------------------------------------------------------------
        private void DeclareMethodParameters(METHINFO methodInfo)
        {
            EXPR first = null;
            EXPR last = null;
            DeclareMethodParameters(methodInfo, ref first, ref last);
        }

        //------------------------------------------------------------
        // FUNCBREC.AddTyVarsToScope
        //
        /// <summary>
        /// Create CACHESYM instances of the type variables of this.methSym
        /// and add them to scopeSym.
        /// </summary>
        /// <param name="scopeSym"></param>
        //------------------------------------------------------------
        private void AddTyVarsToScope(SCOPESYM scopeSym)
        {
            // First put the method type variables in the cache.
            for (int i = 0; i < this.methodSym.TypeVariables.Count; ++i)
            {
                TYVARSYM var = this.methodSym.TypeVariables.ItemAsTYVARSYM(i);
                CACHESYM sym = Compiler.LocalSymbolManager.CreateLocalSym(
                    SYMKIND.CACHESYM,
                    var.Name,
                    scopeSym) as CACHESYM;
                sym.EntrySym = var;
                sym.TypeArray = null;
                sym.ScopeSym = scopeSym;
            }
        }

        //------------------------------------------------------------
        // original sources of
        // declareVarNoScopeCheck and declareVar
        //------------------------------------------------------------

        //#ifdef DEBUG
        //#define declareVarNoScopeCheck(tree,ident,type) declareVar(tree,ident,type,true)
        //    LOCVARSYM * declareVar(BASENODE * tree, NAME * ident, TYPESYM * type, bool fSkipScopeCheck = false);
        //#else
        //#define declareVarNoScopeCheck(tree,ident,type) declareVar(tree,ident,type)
        //    LOCVARSYM * declareVar(BASENODE * tree, NAME * ident, TYPESYM * type);
        //#endif

        //// Declare the variable of a given name and type in the current scope.
        //LOCVARSYM * FUNCBREC::declareVar(BASENODE * tree, NAME * ident, TYPESYM * type
        //#ifdef DEBUG
        //                                 , bool fSkipScopeCheck
        //#endif
        //                                 )
        //{
        //    checkUnsafe(tree, type);
        //
        //    SYM * rval = compiler()->getLSymmgr().LookupLocalSym(ident, pCurrentScope, MASK_LOCVARSYM);
        //    if (rval) {
        //        compiler()->Error(tree, ERR_LocalDuplicate, ident);
        //        return NULL;
        //    }
        //
        //    localCount ++;
        //
        //    if (localCount > 0xffff) {
        //        compiler()->Error(tree, ERR_TooManyLocals);
        //    }
        //
        //    // Anonymous methods and iterators don't like locals in scopes that
        //    // don't belong to blocks!
        //    ASSERT(fSkipScopeCheck || pCurrentScope == pCurrentBlock->scopeSymbol);
        //
        //    rval = compiler()->getLSymmgr().CreateLocalSym(SK_LOCVARSYM, ident, pCurrentScope);
        //    rval->AsLOCVARSYM->type = type;
        //    rval->AsLOCVARSYM->declTree = tree;
        //
        //    storeInCache(tree, ident, rval, NULL, true);
        //
        //    return rval->AsLOCVARSYM;
        //}

        //------------------------------------------------------------
        // FUNCBREC.declareVarNoScopeCheck
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="ident"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private LOCVARSYM DeclareVarNoScopeCheck(BASENODE tree, string ident, TYPESYM type)
        {
            return DeclareVar(tree, ident, type, true);
        }

        //------------------------------------------------------------
        // FUNCBREC.DeclareVar
        //
        /// <summary>
        /// <para>Create a LOCVARSYM instance in this.currentScopeSym.</para>
        /// <para>If ident is already used, or if too many local symbols,
        /// show an error message.</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="ident"></param>
        /// <param name="typeSym"></param>
        /// <param name="skipScopeCheck"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private LOCVARSYM DeclareVar(
            BASENODE treeNode,
            string ident,
            TYPESYM typeSym,
            bool skipScopeCheck)	// = false
        {
            CheckUnsafe(treeNode, typeSym,CSCERRID.ERR_UnsafeNeeded,null);

            SYM sym = Compiler.LocalSymbolManager.LookupLocalSym(
                ident,
                this.currentScopeSym,
                SYMBMASK.LOCVARSYM);
            if (sym != null)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_LocalDuplicate, new ErrArg(ident));
                return null;
            }

            ++this.localCount;

            if (this.localCount > 0xffff)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_TooManyLocals);
            }

            // Anonymous methods and iterators don't like locals in scopes that
            // don't belong to blocks!
            DebugUtil.Assert(
                skipScopeCheck ||
                this.currentScopeSym == this.currentBlockExpr.ScopeSym);

            LOCVARSYM locSym = Compiler.LocalSymbolManager.CreateLocalSym(
                SYMKIND.LOCVARSYM,
                ident,
                this.currentScopeSym) as LOCVARSYM;
            locSym.TypeSym = typeSym;
            locSym.DeclTreeNode = treeNode;

            StoreInCache(treeNode, ident, locSym, null, true);

            return locSym;
        }

        //------------------------------------------------------------
        // FUNCBREC.DeclareParam
        //
        /// <summary>
        /// Declare the given parameter in the outermost scope.
        /// Checks for duplicate parameter names.
        /// </summary>
        /// <param name="ident"></param>
        /// <param name="typeSym"></param>
        /// <param name="flags"></param>
        /// <param name="parseTreeNode"></param>
        /// <param name="scopeSym"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private LOCVARSYM DeclareParam(
            string ident,
            TYPESYM typeSym,
            NODEFLAGS flags,
            BASENODE parseTreeNode,
            SCOPESYM scopeSym)	//  = null
        {
            DebugUtil.Assert(typeSym != null);

            if (scopeSym == null)
            {
                scopeSym = this.OuterScopeSym;
            }

            CheckUnsafe(parseTreeNode, typeSym, CSCERRID.ERR_UnsafeNeeded, null);

            SYM sym = Compiler.LocalSymbolManager.LookupLocalSym(
                ident,
                scopeSym,
                SYMBMASK.LOCVARSYM | SYMBMASK.CACHESYM);

            if (sym != null)
            {
                // Try to report the error on the name, not the type
                if (parseTreeNode != null && parseTreeNode.Kind == NODEKIND.PARAMETER)
                {
                    parseTreeNode = (parseTreeNode as PARAMETERNODE).NameNode;
                }

                if (sym.IsCACHESYM)
                {
                    DebugUtil.Assert(
                        (sym as CACHESYM).EntrySym.IsTYVARSYM &&
                        (sym as CACHESYM).EntrySym.ParentSym == this.methodSym);
                    Compiler.Error(
                        parseTreeNode,
                        CSCERRID.ERR_LocalSameNameAsTypeParam,
                        new ErrArg(ident));
                }
                else
                {
                    Compiler.Error(
                        parseTreeNode,
                        CSCERRID.ERR_DuplicateParamName,
                        new ErrArg(ident));
                }
                return null;
            }

            LOCVARSYM rval = AddParam(ident, typeSym, flags, scopeSym);
            rval.DeclTreeNode = parseTreeNode;
            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.AddParam
        //
        /// <summary>
        /// adds a parameter to the outermost scope
        /// does not do duplicate parameter error checking
        /// </summary>
        /// <param name="ident"></param>
        /// <param name="typeSym"></param>
        /// <param name="flags"></param>
        /// <param name="scopeSym"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private LOCVARSYM AddParam(
            string ident,
            TYPESYM typeSym,
            NODEFLAGS flags,
            SCOPESYM scopeSym)	// = null
        {
            flags &= (NODEFLAGS.PARMMOD_OUT | NODEFLAGS.PARMMOD_REF);
            DebugUtil.Assert(!typeSym.IsPARAMMODSYM || flags == 0);

            if (typeSym.IsPARAMMODSYM)
            {
                flags = ((typeSym as PARAMMODSYM).IsOut ? NODEFLAGS.PARMMOD_OUT : NODEFLAGS.PARMMOD_REF);
                typeSym = (typeSym as PARAMMODSYM).ParamTypeSym;
            }

            if (scopeSym == null)
            {
                scopeSym = this.OuterScopeSym;
            }

            LOCVARSYM rval = Compiler.LocalSymbolManager.CreateLocalSym(
                SYMKIND.LOCVARSYM,
                ident,
                scopeSym) as LOCVARSYM;

            rval.LocSlotInfo.HasInit = true;
            rval.LocSlotInfo.IsParameter = true;
            rval.LocSlotInfo.IsReferenced = true;     // Set this so we never report unreferenced parameters

            if (flags != 0)
            {
                rval.LocSlotInfo.IsReferenceParameter = true;
                rval.LocSlotInfo.IsUsed = true;
                if ((flags & NODEFLAGS.PARMMOD_OUT) != 0)
                {
                    rval.LocSlotInfo.HasInit = false;
                    rval.LocSlotInfo.SetJbitDefAssg(uninitedVarCount + 1);
                    this.uninitedVarCount += FlowChecker.GetCbit(Compiler, typeSym);
                }
            }

            rval.TypeSym = typeSym;
            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindType
        //
        /// <summary>
        /// Bind the given type assuming the current namespace and class context and method.
        /// This also calls EnsureState on the type.
        /// </summary>
        /// <param name="tree"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private TYPESYM BindType(TYPEBASENODE tree)
        {
            TYPESYM type = TypeBind.BindType(
                Compiler,
                tree,
                this.ContextForTypeBinding(),
                this.typeBindFlags);
            if (type != null)
            {
                Compiler.EnsureState(type, AggStateEnum.Prepared);
            }
            return type;
        }

        // Field initializers always use the parentDecl
        // because they do not have access to constructor parameters or type parameters

        //------------------------------------------------------------
        // FUNCBREC.ContextForTypeBinding
        //
        /// <summary></summary>
        /// <returns></returns>
        //------------------------------------------------------------
        private PARENTSYM ContextForTypeBinding()
        {
            if (this.methodSym != null && !evaluatingFieldInitializer)
            {
                DebugUtil.Assert(this.methodSym.ContainingDeclaration() == this.parentDeclSym);
                return this.methodSym;
            }
            return this.parentDeclSym;
        }

        //    LOCVARSYM * lookupLocalVar(NAME * name, SCOPESYM *scope);

        //------------------------------------------------------------
        // FUNCBREC.SetNodeExpr
        //
        /// <summary>
        /// Return argument expr as is.
        /// </summary>
        /// <param name="node"></param>
        /// <param name="expr"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR SetNodeExpr(BASENODE node, EXPR expr)
        {
            return expr;
        }

        //------------------------------------------------------------
        // FUNCBREC.SetNodeStmt
        //
        /// <summary>
        /// Return stmt as is, for now.
        /// </summary>
        /// <param name="node"></param>
        /// <param name="stmt"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPRSTMT SetNodeStmt(BASENODE node, EXPRSTMT stmt)
        {
            return stmt;
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExprZero
        //
        /// <summary>
        /// Create a instance of type EXPRCONSTANT or EXPRZEROINIT with value 0.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="typeSym"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR NewExprZero(BASENODE treeNode, TYPESYM typeSym)
        {
            CONSTVAL constVal = new CONSTVAL();

            switch (typeSym.FundamentalType())
            {
                default:
                    DebugUtil.Assert(false);
                    return null;

                case FUNDTYPE.PTR:
                    EXPR expr = null;
                    BindSimpleCast(treeNode, BindNull(null), typeSym, ref expr, 0);
                    return expr;

                case FUNDTYPE.I1:
                    constVal.SetSByte((sbyte)0);
                    goto case FUNDTYPE.REF;

                case FUNDTYPE.U1:
                    constVal.SetByte((byte)0);
                    goto case FUNDTYPE.REF;

                case FUNDTYPE.I2:
                    constVal.SetShort((short)0);
                    goto case FUNDTYPE.REF;

                case FUNDTYPE.U2:
                    constVal.SetUShort((ushort)0);
                    goto case FUNDTYPE.REF;

                case FUNDTYPE.I4:
                    constVal.SetInt((int)0);
                    goto case FUNDTYPE.REF;

                case FUNDTYPE.U4:
                    constVal.SetUInt((uint)0);
                    goto case FUNDTYPE.REF;

                case FUNDTYPE.I8:
                    constVal.SetLong((long)0);
                    goto case FUNDTYPE.REF;

                case FUNDTYPE.U8:
                    constVal.SetULong((ulong)0);
                    goto case FUNDTYPE.REF;

                case FUNDTYPE.R4:
                    constVal.SetFloat((float)0);
                    goto case FUNDTYPE.REF;

                case FUNDTYPE.R8:
                    constVal.SetDouble((double)0);
                    goto case FUNDTYPE.REF;

                case FUNDTYPE.STRUCT:
                    if (typeSym.IsPredefType(PREDEFTYPE.DECIMAL))
                    {
                        constVal.SetDecimal((decimal)0);
                        goto case FUNDTYPE.REF;
                    }
                    break;

                case FUNDTYPE.REF:
                    return NewExprConstant(treeNode, typeSym, constVal);

                case FUNDTYPE.VAR:
                    break;
            }

            EXPRZEROINIT rval = NewExpr(treeNode, EXPRKIND.ZEROINIT, typeSym) as EXPRZEROINIT;
            DebugUtil.Assert(rval.Operand == null);
            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExprConstant
        //
        /// <summary>
        /// This returns a null for reference types and an EXPRZEROINIT for all others.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="typeSym"></param>
        /// <param name="cnstVal"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPRCONSTANT NewExprConstant(BASENODE treeNode, TYPESYM typeSym, CONSTVAL cnstVal)
        {
            EXPRCONSTANT rval = NewExpr(treeNode, EXPRKIND.CONSTANT, typeSym) as EXPRCONSTANT;
            if (rval.List != null)
            {
                rval.ClearList();
            }
            rval.ConstVal.Set(cnstVal); // Always big enough for everything

            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExprLabel
        //
        /// <summary>
        /// create a new label expr statment...
        /// </summary>
        /// <returns></returns>
        //------------------------------------------------------------
        internal EXPRLABEL NewExprLabel()
        {
            // The second part of this assert checks that pCB is not garbage by dereferencing it...
            DebugUtil.Assert(this.currentBlockExpr != null && this.currentBlockExpr.TypeSym == null);
            DebugUtil.Assert(this.currentScopeSym != null && this.currentScopeSym.ParentSym != null);

            EXPRLABEL expr = NewExpr(null, EXPRKIND.LABEL, null) as EXPRLABEL;
            expr.ScopeSym = currentScopeSym;
            return expr;
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExprBlock
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPRBLOCK NewExprBlock(BASENODE tree)
        {
            EXPRBLOCK block = NewExpr(tree, EXPRKIND.BLOCK, null) as EXPRBLOCK;
            block.OwingBlockExpr = this.currentBlockExpr;

            return block;
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExprBinop
        //
        /// <summary>
        /// Create a binop node...
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="kind"></param>
        /// <param name="typeSym"></param>
        /// <param name="operand1"></param>
        /// <param name="operand2"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPRBINOP NewExprBinop(
            BASENODE treeNode,
            EXPRKIND kind,
            TYPESYM typeSym,
            EXPR operand1,
            EXPR operand2)
        {
            EXPRBINOP rval = NewExprCore(
                treeNode,
                kind,
                typeSym,
                EXPRFLAG.BINOP,
                EXPRKIND.BINOP) as EXPRBINOP;
            rval.Operand1 = operand1;
            rval.Operand2 = operand2;

            DebugUtil.Assert(rval.Kind == kind);
            DebugUtil.Assert((rval.Flags & EXPRFLAG.BINOP) != 0);
            return rval.AsBIN;
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExprCore
        //
        /// <summary>
        /// <para>Create a generic node...</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="kindReal"></param>
        /// <param name="typeSym"></param>
        /// <param name="flags"></param>
        /// <param name="kindAlloc"></param>
        //------------------------------------------------------------
        private EXPR NewExprCore(
            BASENODE treeNode,
            EXPRKIND kindReal,
            TYPESYM typeSym,
            EXPRFLAG flags,
            EXPRKIND kindAlloc)
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            EXPR expr = null;

            // in debug, allocate through new so that we get a vtable for the debugger
            // else, just allocate enough space and use that...

            switch (kindAlloc)
            {
                case EXPRKIND.BLOCK:
                    expr = new EXPRBLOCK();
                    break;
                case EXPRKIND.STMTAS:
                    expr = new EXPRSTMTAS();
                    break;
                case EXPRKIND.RETURN:
                    expr = new EXPRRETURN();
                    break;
                case EXPRKIND.DECL:
                    expr = new EXPRDECL();
                    break;
                case EXPRKIND.LABEL:
                    expr = new EXPRLABEL();
                    break;
                case EXPRKIND.GOTO:
                    expr = new EXPRGOTO();
                    break;
                case EXPRKIND.GOTOIF:
                    expr = new EXPRGOTOIF();
                    break;
                case EXPRKIND.SWITCH:
                    expr = new EXPRSWITCH();
                    break;
                case EXPRKIND.SWITCHLABEL:
                    expr = new EXPRSWITCHLABEL();
                    break;
                case EXPRKIND.TRY:
                    expr = new EXPRTRY();
                    break;
                case EXPRKIND.HANDLER:
                    expr = new EXPRHANDLER();
                    break;
                case EXPRKIND.THROW:
                    expr = new EXPRTHROW();
                    break;
                case EXPRKIND.NOOP:
                    expr = new EXPRNOOP();
                    break;
                case EXPRKIND.DEBUGNOOP:
                    expr = new EXPRDEBUGNOOP();
                    break;
                case EXPRKIND.DELIM:
                    expr = new EXPRDELIM();
                    break;
                case EXPRKIND.BINOP:
                    expr = new EXPRBINOP();
                    break;
                case EXPRKIND.CALL:
                    expr = new EXPRCALL();
                    break;
                case EXPRKIND.EVENT:
                    expr = new EXPREVENT();
                    break;
                case EXPRKIND.FIELD:
                    expr = new EXPRFIELD();
                    break;
                case EXPRKIND.LOCAL:
                    expr = new EXPRLOCAL();
                    break;
                case EXPRKIND.CONSTANT:
                    expr = new EXPRCONSTANT();
                    break;
                case EXPRKIND.CLASS:
                    expr = new EXPRCLASS();
                    break;
                case EXPRKIND.NSPACE:
                    expr = new EXPRNSPACE();
                    break;
                case EXPRKIND.ERROR:
                    expr = new EXPRERROR();
                    break;
                case EXPRKIND.FUNCPTR:
                    expr = new EXPRFUNCPTR();
                    break;
                case EXPRKIND.PROP:
                    expr = new EXPRPROP();
                    break;
                case EXPRKIND.MULTI:
                    expr = new EXPRMULTI();
                    break;
                case EXPRKIND.MULTIGET:
                    expr = new EXPRMULTIGET();
                    break;
                case EXPRKIND.STTMP:
                    expr = new EXPRSTTMP();
                    break;
                case EXPRKIND.LDTMP:
                    expr = new EXPRLDTMP();
                    break;
                case EXPRKIND.FREETMP:
                    expr = new EXPRFREETMP();
                    break;
                case EXPRKIND.WRAP:
                    expr = new EXPRWRAP();
                    break;
                case EXPRKIND.CONCAT:
                    expr = new EXPRCONCAT();
                    break;
                case EXPRKIND.ARRINIT:
                    expr = new EXPRARRINIT();
                    break;
                case EXPRKIND.CAST:
                    expr = new EXPRCAST();
                    break;
                case EXPRKIND.TYPEOF:
                    expr = new EXPRTYPEOF();
                    break;
                case EXPRKIND.SIZEOF:
                    expr = new EXPRSIZEOF();
                    break;
                case EXPRKIND.ZEROINIT:
                    expr = new EXPRZEROINIT();
                    break;
                case EXPRKIND.USERLOGOP:
                    expr = new EXPRUSERLOGOP();
                    break;
                case EXPRKIND.MEMGRP:
                    expr = new EXPRMEMGRP();
                    break;
                case EXPRKIND.ANONMETH:
                    expr = new EXPRANONMETH();
                    break;
                case EXPRKIND.DBLQMARK:
                    expr = new EXPRDBLQMARK();
                    break;

                case EXPRKIND.LAMBDAEXPR:   // CS3
                    expr = new EXPRLAMBDAEXPR();
                    break;
                case EXPRKIND.SYSTEMTYPE:   // CS3
                    expr = new EXPRSYSTEMTYPE();
                    break;
                case EXPRKIND.FIELDINFO:    // CS3
                    expr = new EXPRFIELDINFO();
                    break;
                case EXPRKIND.METHODINFO:   // CS3
                    expr = new EXPRMETHODINFO();
                    break;
                case EXPRKIND.CONSTRUCTORINFO:  // CS3
                    expr = new EXPRCONSTRUCTORINFO();
                    break;

                case EXPRKIND.RUNTIMEBINDEDMEMBER:  // CS4
                    expr = new EXPRRUNTIMEBINDEDMEMBER();
                    EXPR.SetRuntimeBinded(ref flags);
                    break;
                case EXPRKIND.RUNTIMEBINDEDUNAOP:
                    expr = new EXPRRUNTIMEBINDEDUNAOP();
                    EXPR.SetRuntimeBinded(ref flags);
                    break;
                case EXPRKIND.RUNTIMEBINDEDBINOP:
                    expr = new EXPRRUNTIMEBINDEDBINOP();
                    EXPR.SetRuntimeBinded(ref flags);
                    break;
                case EXPRKIND.RUNTIMEBINDEDINVOCATION:  // CS4
                    expr = new EXPRRUNTIMEBINDEDINVOCATION();
                    EXPR.SetRuntimeBinded(ref flags);
                    break;

                default:
                    DebugUtil.Assert(false, "bad kind passed to newExpr");
                    expr = new EXPR();
                    break;
            }

            expr.Kind = kindReal;
            expr.TypeSym = typeSym;
            expr.TreeNode = treeNode;
            expr.Flags = flags;

            return expr;
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExpr (1)
        //
        /// <summary>
        /// Create an EXPR instance with flags = 0.
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="kind"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR NewExpr(BASENODE tree, EXPRKIND kind, TYPESYM type)
        {
            return NewExprCore(tree, kind, type, 0, kind);
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExpr (2)
        //
        /// <summary>
        /// Create an EXPR instance. Unspecified arguments are set to default values.
        /// </summary>
        /// <param name="kind"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR NewExpr(EXPRKIND kind)
        {
            return NewExprCore(null, kind, null, 0, kind);
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExprWrap
        //
        /// <summary>
        /// Create EXPRWRAP instance and set argument wrapExpr to it.
        /// </summary>
        /// <param name="wrapExpr"></param>
        /// <param name="tempKind"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPRWRAP NewExprWrap(EXPR wrapExpr, TEMP_KIND tempKind)
        {
            EXPRWRAP rval = NewExpr(EXPRKIND.WRAP) as EXPRWRAP;
            (rval as EXPRWRAP).Expr = wrapExpr;
            if (wrapExpr != null)
            {
                rval.TypeSym = wrapExpr.TypeSym;
            }
            rval.Flags |= EXPRFLAG.LVALUE;
            rval.TempKind = tempKind;
            rval.ContainingScopeSym = this.currentScopeSym;
            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.MakeStmt
        //
        /// <summary>
        /// <para>(In sscli, flags has the default value 0.)</para>
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="expr"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPRSTMTAS MakeStmt(
            BASENODE tree,
            EXPR expr,
            EXPRFLAG flags)	// = 0
        {
            DebugUtil.Assert(expr != null && expr.Kind != EXPRKIND.STMTAS);

            EXPRSTMTAS stmt = NewExpr(tree, EXPRKIND.STMTAS, null) as EXPRSTMTAS;
            stmt.Expr = expr;
            stmt.Flags |= flags;
            return stmt;
        }

        //------------------------------------------------------------
        // FUNCBREC.NewList
        //
        /// <summary>
        /// <para>Concatenate an item onto a list</para>
        /// </summary>
        /// <remarks>
        /// <para>Return the count of added items.</para>
        /// <para>In sscli, private void newList(EXPR* newItem, EXPR*** list);</para>
        /// </remarks>
        /// <param name="newItem"></param>
        /// <param name="firstListNode"></param>
        /// <param name="lastListNode"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private int NewList(EXPR newItem, ref EXPR firstListNode, ref EXPR lastListNode)
        {
#if DEBUG
            if (!(newItem != null))
            {
                ;
            }
#endif
            DebugUtil.Assert(newItem != null);

            if (firstListNode == null)
            {
                firstListNode = newItem;
                lastListNode = firstListNode;
            }
            else if (firstListNode.Kind == EXPRKIND.LIST)
            {
                DebugUtil.Assert(lastListNode.Kind == EXPRKIND.LIST);
                EXPR expr = NewExprBinop(
                    null,
                    EXPRKIND.LIST,
                    this.GetVoidType(),
                    (lastListNode as EXPRBINOP).Operand2, newItem);
                (lastListNode as EXPRBINOP).Operand2 = expr;
                lastListNode = expr;
            }
            else
            {
                EXPR expr = NewExprBinop(
                    null,
                    EXPRKIND.LIST,
                    this.GetVoidType(),
                    firstListNode,
                    newItem);
                firstListNode = expr;
                lastListNode = expr;
            }

            int count = 0;
            while (lastListNode.Kind == EXPRKIND.LIST)
            {
                ++count;
                if ((lastListNode as EXPRBINOP).Operand2.Kind != EXPRKIND.LIST) break;
                lastListNode = (lastListNode as EXPRBINOP).Operand2;
                DebugUtil.Assert(lastListNode != null, "FUNCBREC.NewList");
            }
            // the two operands of lastListNode are elements of the list,
            // so we should count the right operand.
            // Or, in the case of a list of only one element, count == 0 yet.
            ++count;
            return count;
        }

        //------------------------------------------------------------
        // FUNCBREC::newList (sscli)
        //------------------------------------------------------------
        //void FUNCBREC::newList(EXPR * newItem, EXPR *** list)
        //{
        //    ASSERT(list != NULL);
        //    ASSERT(*list != NULL);
        //
        //    if (!newItem) return;
        //
        //    if (**list == NULL) {
        //        **list = newItem;
        //        return;
        //    }
        //    EXPRBINOP * temp = newExprBinop(
        //        NULL,
        //        EK_LIST,
        //        getVoidType(),
        //        (**list),
        //        newItem);
        //    (**list) = temp;
        //    (*list) = &(temp->p2);
        //}

        //------------------------------------------------------------
        // FUNCBREC.FindLastNode
        //
        /// <summary>
        /// <para>Find the last EXPR instance of a EXPR list by EXPRBINOP.</para>
        /// <para>If lastListNode is not null, return it as is
        /// (do not check the consistency).</para>
        /// </summary>
        /// <param name="firstListNode"></param>
        /// <param name="lastListNode"></param>
        //------------------------------------------------------------
        internal void FindLastNode(EXPR firstListNode, ref EXPR lastListNode)
        {
            if (firstListNode == null)
            {
                lastListNode = null;
                return;
            }
            else if (lastListNode != null)
            {
                return;
            }
            else
            {
                lastListNode = firstListNode;
                while (lastListNode.Kind == EXPRKIND.LIST)
                {
                    lastListNode = (lastListNode as EXPRBINOP).Operand2;
                }
                return;
            }
        }

        //------------------------------------------------------------
        // FUNCBREC.NewError
        //
        /// <summary>
        /// <para>Create an error node</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="typeSym"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPRERROR NewError(BASENODE treeNode, TYPESYM typeSym)
        {
            EXPRERROR expr;
            DebugUtil.Assert(treeNode != null);

            if (typeSym == null || typeSym.IsNeverSameType())
            {
                typeSym = Compiler.MainSymbolManager.ErrorSym;
            }
            expr = NewExpr(treeNode, EXPRKIND.ERROR, typeSym) as EXPRERROR;
            return expr;
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExprDelim
        //
        /// <summary>
        /// Create a delimiter expr
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="delim"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPRDELIM NewExprDelim(BASENODE tree, DELIMKIND delim)
        {
            EXPRDELIM expr;
            DebugUtil.Assert(tree != null);

            expr = NewExpr(tree, EXPRKIND.DELIM, null) as EXPRDELIM;
            expr.DelimKind = delim;
            return expr;
        }

        //------------------------------------------------------------
        // FUNCBREC.NewExprMemGrp
        //
        /// <summary>
        /// Create an EXPRMEMGRP instance and set fields by the data of mem.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="nameNode"></param>
        /// <param name="mem"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPRMEMGRP NewExprMemGrp(BASENODE treeNode, BASENODE nameNode, MemberLookup mem)
        {
            DebugUtil.Assert(!mem.FError());

            EXPRMEMGRP grpExpr = (NewExpr(
                treeNode,
                EXPRKIND.MEMGRP,
                Compiler.MainSymbolManager.MethodGroupTypeSym)) as EXPRMEMGRP;
            grpExpr.NameNode = nameNode;

            mem.FillGroup(grpExpr);

            return grpExpr;
        }

        //------------------------------------------------------------
        // FUNCBREC.CreateConstructorCall
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="ctorNode"></param>
        /// <param name="aggTypeSym"></param>
        /// <param name="thisExpr"></param>
        /// <param name="argsExpr"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR CreateConstructorCall(
            BASENODE treeNode,
            BASENODE ctorNode,
            AGGTYPESYM aggTypeSym,
            EXPR thisExpr,
            EXPR argsExpr,
            MemLookFlagsEnum flags)
        {
#if DEBUG
            if (aggTypeSym.SymID == 7400)
            {
                ;
            }
#endif
            // Only legal flags are EXPRFLAG.NEWOBJCALL and EXPRFLAG.BASECALL, but they can't both be set.
            DebugUtil.Assert(
                (flags & ~(MemLookFlagsEnum.NewObj | MemLookFlagsEnum.BaseCall)) == 0 &&
                (~flags & (MemLookFlagsEnum.NewObj | MemLookFlagsEnum.BaseCall)) != 0);

            TYPESYM retTypeSym = (flags & MemLookFlagsEnum.NewObj) != 0 ? aggTypeSym : this.GetVoidType();
            MemberLookup mem = new MemberLookup();

            if (!mem.Lookup(
                Compiler,
                aggTypeSym,
                thisExpr,
                this.parentDeclSym,
                Compiler.NameManager.GetPredefinedName(PREDEFNAME.CTOR),
                0,
                flags | MemLookFlagsEnum.Ctor))
            {
                mem.ReportErrors(treeNode);
                return NewError(treeNode, retTypeSym);
            }
            mem.ReportWarnings(treeNode);

            // Create the method group expression.
            EXPRMEMGRP grpExpr = NewExprMemGrp(treeNode, ctorNode, mem);

            EXPR resExpr = BindGrpToArgs(treeNode, 0, grpExpr, argsExpr);
            if (!resExpr.IsOK)
            {
                return NewError(treeNode, retTypeSym);
            }
            DebugUtil.Assert(resExpr.TypeSym == retTypeSym);

            if (aggTypeSym.FundamentalType() <= FUNDTYPE.LASTNUMERIC &&
                argsExpr != null &&
                argsExpr.Kind != EXPRKIND.LIST &&
                argsExpr.TypeSym == aggTypeSym)
            {
                DebugUtil.Assert((flags & MemLookFlagsEnum.NewObj) != 0);
                resExpr = (resExpr as EXPRCALL).ArgumentsExpr;
            }

            return resExpr;
        }

        //------------------------------------------------------------
        // FUNCBREC.IsMethPropCallable
        //
        /// <summary>
        /// Is the method/property callable. Not if it's an override or not user-callable.
        /// </summary>
        /// <param name="sym"></param>
        /// <param name="requireUC"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private bool IsMethPropCallable(METHPROPSYM mpSym, bool requireUC)
        {
            // The hide-by-name option for binding other languages takes precedence over general
            // rules of not binding to overrides.
            return
                (!mpSym.IsOverride || mpSym.IsHideByName()) &&
                (!requireUC || mpSym.IsUserCallable());
        }

        //internal:

        // called by CLSDREC::MakeIterator

        //--------------------------------------------------
        // FUNCBREC.FindPredefMeth
        //
        /// <summary>
        /// <para>This finds a predefined method with the given name and parameter types in the given type.
        /// The method must be in the given type - not in a base type.</para>
        /// <para>(In sscli, default values reportError = true, flags = MemLookFlags::None</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="predefName"></param>
        /// <param name="aggTypeSym"></param>
        /// <param name="parameterArray"></param>
        /// <param name="flags"></param>
        /// <param name="reportError"></param>
        /// <returns></returns>
        //--------------------------------------------------
        internal METHSYM FindPredefMeth(
            BASENODE treeNode,
            PREDEFNAME predefName,
            AGGTYPESYM aggTypeSym,
            TypeArray parameterArray,
            bool reportError,       //  = true
            MemLookFlagsEnum flags) //  = MemLookFlags::None
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            DebugUtil.Assert(parameterArray != null);

            // caused by GetOptPDT failing on non-required types
            if (aggTypeSym == null)
            {
                return null;
            }

            string name = Compiler.NameManager.GetPredefinedName(predefName);

            if (predefName == PREDEFNAME.CTOR)
            {
                flags |= MemLookFlagsEnum.Ctor;
            }

            MemberLookup mem = new MemberLookup();
            if (!mem.Lookup(Compiler, aggTypeSym, null, this.parentDeclSym, name, 0, flags) ||
                !mem.FirstSym.IsMETHSYM ||
                (mem.FirstSym as METHSYM).ClassSym != aggTypeSym.GetAggregate())
            {
                if (reportError)
                {
                    Compiler.Error(
                        treeNode,
                        CSCERRID.ERR_MissingPredefinedMember,
                        new ErrArg(aggTypeSym),
                        new ErrArg(name));
                }
                return null;
            }
            mem.ReportWarnings(treeNode);

            EXPRMEMGRP grpExpr = NewExprMemGrp(treeNode, null, mem);

            // Only look in the given aggTypeSym.
            grpExpr.ParentTypeSym = aggTypeSym;
            grpExpr.ContainingTypeArray = Compiler.MainSymbolManager.AllocParams(aggTypeSym as TYPESYM);

            MethWithInst mwi = new MethWithInst();
            MethWithInst mwiAmbig = new MethWithInst();

            BindGrpToParams(mwi, treeNode, grpExpr, parameterArray, reportError, mwiAmbig, null);

            DebugUtil.Assert(
                mwi == null ||
                mwi.AggTypeSym == aggTypeSym &&
                    Compiler.MainSymbolManager.SubstEqualTypeArrays(
                        parameterArray,
                        mwi.MethSym.ParameterTypes,
                        aggTypeSym,
                        null) &&
                    mwi.MethSym.TypeVariables.Count == 0);

            if (mwiAmbig.IsNotNull && !reportError)
            {
                return null;
            }

            return mwi.MethSym;
        }

        //private:

        //--------------------------------------------------
        // FUNCBREC.BindPredefMethToArgs
        //
        /// <summary>
        /// <para>This finds and binds a method with the given name to the args provided.</para>
        /// <para>(In sscli, typeArgs has the default value null.)</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="predefNameID"></param>
        /// <param name="aggTypeSym"></param>
        /// <param name="expr"></param>
        /// <param name="argsExpr"></param>
        /// <param name="typeArgs"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPredefMethToArgs(
            BASENODE treeNode,
            PREDEFNAME predefNameID,
            AGGTYPESYM aggTypeSym,
            EXPR expr,
            EXPR argsExpr,
            TypeArray typeArgs)	//  = null
        {
            string name = Compiler.NameManager.GetPredefinedName(predefNameID);
            MemberLookup mem = new MemberLookup();

            // Caused by missing type in GetOptPDT()
            if (aggTypeSym == null)
            {
                return NewError(treeNode, null);
            }

            if (!mem.Lookup(
                    Compiler,
                    aggTypeSym,
                    expr,
                    this.parentDeclSym,
                    name,
                    TypeArray.Size(typeArgs),
                    MemLookFlagsEnum.None) ||
                !mem.FirstSym.IsMETHSYM)
            {
                Compiler.Error(
                    treeNode,
                    CSCERRID.ERR_MissingPredefinedMember,
                    new ErrArg(aggTypeSym),
                    new ErrArg(name));
                return NewError(treeNode, null);
            }
            mem.ReportWarnings(treeNode);

            EXPRMEMGRP grpExpr = NewExprMemGrp(treeNode, null, mem);
            if (typeArgs != null)
            {
                grpExpr.TypeArguments = typeArgs;
            }
            return BindGrpToArgs(treeNode, 0, grpExpr, argsExpr);
        }

        //--------------------------------------------------
        // FUNCBREC.BindGrpToArgs
        //
        /// <summary>
        /// <para>Given a method group or indexer group,
        /// bind it to the arguments for an invocation.</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="bindFlags"></param>
        /// <param name="memGrpExpr"></param>
        /// <param name="argsExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindGrpToArgs(
            BASENODE treeNode,
            BindFlagsEnum bindFlags,
            EXPRMEMGRP memGrpExpr,
            EXPR argsExpr)
        {
            DebugUtil.Assert(
                memGrpExpr.SymKind == SYMKIND.METHSYM ||
                memGrpExpr.SymKind == SYMKIND.PROPSYM && (memGrpExpr.Flags & EXPRFLAG.INDEXER) != 0);

            //--------------------------------------------------
            // Count the args.
            //--------------------------------------------------
            ArgInfos argInfo = null;
            int argCount = 0;
            if (argsExpr != null)
            {
                for (EXPR list = argsExpr; list != null; )
                {
                    ++argCount;
                    EXPR arg;

                    if (list.Kind == EXPRKIND.LIST)
                    {
                        arg = list.AsBIN.Operand1;
                        list = list.AsBIN.Operand2;
                    }
                    else
                    {
                        arg = list;
                        list = null;
                    }

                    // If an arg has a generic ERRORSYM for its type, bail out.
                    if (arg.TypeSym.IsERRORSYM && arg.TypeSym.ParentSym == null)
                    {
                        return NewError(treeNode, null);
                    }
                }
            }

            argInfo = new ArgInfos();
            // argInfo.ExprList is created by FillInArgInfoFromArgList
            FillInArgInfoFromArgList(argInfo, argsExpr);

            MethPropWithInst mpwiBest = new MethPropWithInst();
            if (!BindGrpToArgsCore(
                    mpwiBest,
                    treeNode,
                    bindFlags,
                    memGrpExpr,
                    argInfo,
                    null,
                    true,
                    null))
            {
                return NewError(treeNode, null);
            }
            // if an appropriate METHPROPSYM instance was found, it is set to mpwiBest.

            EXPR resExpr = null;

            if (memGrpExpr.SymKind == SYMKIND.PROPSYM)
            {
                DebugUtil.Assert((memGrpExpr.Flags & EXPRFLAG.INDEXER) != 0);
                DebugUtil.Assert(((int)EXPRFLAG.BASECALL) == (int)BindFlagsEnum.BaseCall);

                resExpr = BindToProperty(
                    treeNode,
                    memGrpExpr.ObjectExpr,
                    PropWithType.Convert(mpwiBest),
                    (bindFlags | (BindFlagsEnum)((int)memGrpExpr.Flags & (int)EXPRFLAG.BASECALL)),
                    argsExpr,
                    null);
            }
            else
            {
                DebugUtil.Assert(memGrpExpr.SymKind == SYMKIND.METHSYM);
                METHSYM methSym = mpwiBest.MethSym;

                if (methSym.IsPartialMethod && methSym.HasNoBody)
                {
                    resExpr = NewExpr(treeNode, EXPRKIND.NOOP, GetVoidType());
                }
                else
                {
                    resExpr = BindToMethod(
                        treeNode,
                        memGrpExpr.ObjectExpr,
                        MethWithInst.Convert(mpwiBest),
                        argsExpr,
                        (MemLookFlagsEnum)memGrpExpr.Flags);
                }
            }
            return resExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindGrpToArgsCore
        //
        /// <summary>
        /// Given a method group or indexer group,
        /// bind it to the arguments for an invocation.
        /// </summary>
        /// <param name="methPropWithInst"></param>
        /// <param name="treeNode"></param>
        /// <param name="bindFlags"></param>
        /// <param name="groupExpr"></param>
        /// <param name="argInfos"></param>
        /// <param name="delegateAggTypeSym"></param>
        /// <param name="reportErrors"></param>
        /// <param name="ambigMethPropWithInst"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool BindGrpToArgsCore(
            MethPropWithInst methPropWithInst,
            BASENODE treeNode,
            BindFlagsEnum bindFlags,
            EXPRMEMGRP groupExpr,
            ArgInfos argInfos,
            AGGTYPESYM delegateAggTypeSym,
            bool reportErrors,
            MethPropWithInst ambigMethPropWithInst)
        {
#if DEBUG
            if (treeNode != null &&
                treeNode.NodeID == 10858)
            {
                ;
            }
#endif
            DebugUtil.Assert(methPropWithInst != null);
            DebugUtil.Assert(reportErrors || ambigMethPropWithInst != null);
            DebugUtil.Assert(
                groupExpr != null &&
                (groupExpr.SymKind == SYMKIND.METHSYM ||
                    groupExpr.SymKind == SYMKIND.PROPSYM && (groupExpr.Flags & EXPRFLAG.INDEXER) != 0));
            // We need the EXPRs for error reporting for non-delegates

            DebugUtil.Assert(delegateAggTypeSym != null || argInfos.HasExprs);
            string name = groupExpr.Name;
            TypeArray typeArgs = groupExpr.TypeArguments;
            SYMBMASK mask = (SYMBMASK)((long)1 << (int)groupExpr.SymKind);

            // Only methods should have type args.

            DebugUtil.Assert(mask == SYMBMASK.METHSYM || typeArgs.Count == 0);
            methPropWithInst.Clear();
            if (ambigMethPropWithInst != null)
            {
                ambigMethPropWithInst.Clear();
            }

            TYPESYM qualTypeSym = null;

            if ((groupExpr.Flags & EXPRFLAG.BASECALL) != 0)
            {
                qualTypeSym = null;
            }
            else if ((groupExpr.Flags & EXPRFLAG.CTOR) != 0)
            {
                qualTypeSym = groupExpr.ParentTypeSym;
            }
            else if (groupExpr.ObjectExpr != null)
            {
                qualTypeSym = groupExpr.ObjectExpr.TypeSym;
            }
            else
            {
                qualTypeSym = null;
            }

            TypeArray containingTypeArray = groupExpr.ContainingTypeArray;
            if (containingTypeArray == null)
            {
                containingTypeArray = BSYMMGR.EmptyTypeArray;
            }
            DebugUtil.Assert(
                containingTypeArray.Count > 0 ||
                groupExpr.ParentTypeSym != null && !groupExpr.ParentTypeSym.IsInterfaceType());
            AGGTYPESYM currentAts = null;
            int currentTypeIndex = 0;

            if (containingTypeArray.Count > 0)
            {
                currentAts = containingTypeArray[currentTypeIndex] as AGGTYPESYM;
                // Clear all the hidden flags.
                for (int i = 0; i < containingTypeArray.Count; ++i)
                {
                    (containingTypeArray[i] as AGGTYPESYM).AllHidden = false;
                }
            }
            else
            {
                // If the full set of types isn't given, we better be in a class.
                // For the interface and type variable case,
                // MemberLookup.Lookup should have been called.
                DebugUtil.Assert(
                    groupExpr.ParentTypeSym.IsAGGTYPESYM &&
                    !groupExpr.ParentTypeSym.IsInterfaceType());
                currentAts = groupExpr.ParentTypeSym as AGGTYPESYM;
            }

            DebugUtil.Assert(
                groupExpr.MethPropSym == null ||
                groupExpr.MethPropSym.ClassSym == currentAts.GetAggregate());
            METHLIST methList = null;  // List of method matches
            METHLIST methListLast = null;

            int cargBest = -1;
            MethPropWithInst bestMpwi = new MethPropWithInst(null, null, null);
            MethPropWithInst inaccessMpwi = new MethPropWithInst(null, null, null);
            MethPropWithInst bogusMpwi = new MethPropWithInst(null, null, null);
            MethPropWithInst paramTypeConstraintsMpwi = new MethPropWithInst(null, null, null);
            MethWithType cantInferMwt = new MethWithType(null, null);
            MethWithType badArityMwt = new MethWithType(null, null);
            TypeArray bestParams = null;
            METHPROPSYM currentMethPropSym = null;
            TypeArray currentParams = new TypeArray();  // = null;
            bool isExpanded = false;
            bool isPartialMethod = false;

            List<SymWithType> wrongSwtCount = new List<SymWithType>();

            //--------------------------------------------------
            // Look for candidates.
            //--------------------------------------------------
            for (; ; ) // for 1
            {
            LNextSym:
                //----------------------------------------
                // Deal with params. (Expand params.)
                //----------------------------------------
                if ((bindFlags & BindFlagsEnum.NoParams) == 0 &&
                    currentMethPropSym != null &&
                    currentMethPropSym.IsParameterArray &&
                    !isExpanded &&
                    argInfos.ArgumentCount >= currentParams.Count - 1)
                {
                    DebugUtil.Assert(
                        methList == null ||
                        methList.MethPropWithInst.MethPropSym != currentMethPropSym);

                    // Construct the expanded params.
                    currentParams = GetExpandedParams(
                        currentMethPropSym.ParameterTypes,
                        argInfos.ArgumentCount);

                    isExpanded = true;
                    DebugUtil.Assert(currentParams != currentMethPropSym.ParameterTypes);
                    goto LHaveSym;
                }

            LNextSymNoParams:
                isExpanded = false;

                //----------------------------------------
                // Find the next sym.
                //----------------------------------------
                for (; ; )  // for 2
                {
                    currentMethPropSym =
                        (currentMethPropSym == null)
                        ? Compiler.MainSymbolManager.LookupAggMember(
                            name,
                            currentAts.GetAggregate(), mask) as METHPROPSYM
                        : BSYMMGR.LookupNextSym(
                            currentMethPropSym,
                            currentAts.GetAggregate(),
                            mask) as METHPROPSYM;

                    if (currentMethPropSym == null)
                    {
                        // Find the next type.
                        // If we've found some applicable methods in a class
                        // then we don't need to look any further.

                        if (methList != null &&
                            methList.MethPropWithInst.IsNotNull &&
                            !methList.MethPropWithInst.AggTypeSym.IsInterfaceType())
                        {
                            goto LListDone;
                        }

                        if (containingTypeArray.Count > 0)
                        {
                            for (; ; )
                            {
                                if (++currentTypeIndex >= containingTypeArray.Count)
                                {
                                    goto LListDone;
                                }
                                currentAts = containingTypeArray[currentTypeIndex] as AGGTYPESYM;
                                if (!currentAts.AllHidden) break;
                            }
                        }
                        else
                        {
                            DebugUtil.Assert(methList == null);
                            currentAts = currentAts.GetBaseClass();
                            if (currentAts == null)
                            {
                                goto LListDone;
                            }
                        }
                        continue;
                    } // if (currentMethPropSym == null)

                    // From here, currentMethPropSym != null

                    if (groupExpr.MethPropSym != null && currentMethPropSym != groupExpr.MethPropSym)
                    {
                        continue;
                    }

                    // Make sure that whether we're seeing a ctor is consistent with the flag.
                    // The only properties we handle are indexers.

                    if (mask == SYMBMASK.METHSYM && (
                        ((groupExpr.Flags & EXPRFLAG.CTOR) == 0) != (!(currentMethPropSym as METHSYM).IsCtor) ||
                        ((groupExpr.Flags & EXPRFLAG.OPERATOR) == 0) != !(currentMethPropSym as METHSYM).IsOperator) ||
                        mask == SYMBMASK.PROPSYM && !(currentMethPropSym as PROPSYM).IsIndexer)
                    {
                        // Get the next symbol.
                        continue;
                    }

                    currentParams = currentMethPropSym.ParameterTypes;

                    if (IsMethPropCallable(currentMethPropSym, (groupExpr.Flags & EXPRFLAG.USERCALLABLE) != 0))
                    {
                        break;
                    }
                } // for (; ; )  // for 2

                //----------------------------------------
                // Check the consistency of the count of arguments.
                //----------------------------------------
                if (currentParams.Count != argInfos.ArgumentCount)
                {
                    if (//cswtWrongCount < cswtMaxWrongCount &&
                        (!currentMethPropSym.IsParameterArray || argInfos.ArgumentCount < currentParams.Count - 1))
                    {
                        //rgswtWrongCount[cswtWrongCount++].Set(currentMethPropSym, currentAts);
                        wrongSwtCount.Add(new SymWithType(currentMethPropSym, currentAts));
                    }
                    continue;
                }

            LHaveSym:
                //----------------------------------------
                // Type Arguments
                // Check the consistency of the count of type arguments.
                //----------------------------------------
                TypeArray currentTypeArgs = null;

                // Get the type args.
                if (currentMethPropSym.IsMETHSYM &&
                    (currentMethPropSym as METHSYM).TypeVariables.Count != typeArgs.Count)
                {
                    // Can't infer if some type args are specified.
                    if (typeArgs.Count > 0)
                    {
                        if (badArityMwt.IsNull)
                        {
                            badArityMwt.Set(currentMethPropSym as METHSYM, currentAts);
                        }
                        goto LNextSymNoParams;
                    }
                    DebugUtil.Assert((currentMethPropSym as METHSYM).TypeVariables.Count > 0);

                    // Try to infer.
                    if (!InferTypeArgs(
                        currentMethPropSym as METHSYM,
                        currentAts,
                        currentParams,
                        argInfos,
                        groupExpr.ObjectExpr,
                        ref currentTypeArgs))
                    {
                        METHSYM curMethSym = currentMethPropSym as METHSYM;
                        AGGSYM linqEnumerableSym
                            = Compiler.GetOptPredefAgg(PREDEFTYPE.LINQ_ENUMERABLE, true);
                        bool inferCompleted = false;

                        if (curMethSym.IsInstanceExtensionMethod)
                        {
                            if (curMethSym.StaticExtensionMethodSym.ParentAggSym
                                == linqEnumerableSym)
                            {
                                inferCompleted = InferTypeLinqEnumerable(
                                    groupExpr,
                                    curMethSym,
                                    argInfos,
                                    ref currentTypeArgs);
                            }
                        }
                        else if (curMethSym.ParentAggSym == linqEnumerableSym)
                        {
                            inferCompleted = InferTypeLinqEnumerable(
                                groupExpr,
                                curMethSym,
                                argInfos,
                                ref currentTypeArgs);
                        }

                        if (!inferCompleted)
                        {
                            if (cantInferMwt.IsNull)
                            {
                                cantInferMwt.Set(currentMethPropSym as METHSYM, currentAts);
                            }
                            continue;
                        }
                    }
                }
                else
                {
                    currentTypeArgs = typeArgs;
                }

                //----------------------------------------
                // Accessibility
                //----------------------------------------
                bool canAccess = Compiler.ClsDeclRec.CheckAccess(
                    currentMethPropSym,
                    currentAts,
                    this.parentDeclSym,
                    qualTypeSym);
                if (!canAccess && (methList != null || inaccessMpwi.IsNotNull))
                {
                    // We'll never use this one for error reporting anyway, so just skip it.
                    goto LNextSymNoParams;
                }

                bool isBogus = canAccess && Compiler.CheckBogus(currentMethPropSym);
                if (isBogus && (methList != null || inaccessMpwi.IsNotNull || bogusMpwi.IsNotNull))
                {
                    // We'll never use this one for error reporting anyway, so just skip it.
                    goto LNextSymNoParams;
                }

                //----------------------------------------
                // Types of arguments (1)
                //----------------------------------------
                if (argInfos.ArgumentCount > 0)
                {
                    currentParams = Compiler.MainSymbolManager.SubstTypeArray(
                        currentParams,
                        currentAts,
                        currentTypeArgs);

                    for (int ivar = 0; ivar < argInfos.ArgumentCount; ++ivar)
                    {
                        TYPESYM typeSym = currentParams[ivar];
                        if (!TypeBind.CheckConstraints(
                                Compiler,
                                treeNode,
                                typeSym,
                                CheckConstraintsFlagsEnum.NoErrors))
                        {
                            paramTypeConstraintsMpwi.Set(
                                currentMethPropSym,
                                currentAts,
                                currentTypeArgs);
                            goto LNextSym;
                        }
                    }

                    for (int ivar = 0; ivar < argInfos.ArgumentCount; ++ivar)
                    {
                        TYPESYM typeSym = currentParams[ivar];

                        if (argInfos.HasExprs ?
                            !CanConvert(argInfos.ExprList[ivar], typeSym, 0) :
                            !CanConvert(argInfos.ArgumentTypes[ivar], typeSym, 0))
                        {
                            if (ivar > cargBest)
                            {
                                cargBest = ivar;
                                bestMpwi.Set(currentMethPropSym, currentAts, currentTypeArgs);
                                bestParams = currentParams;
                            }
                            else if (ivar == cargBest && argInfos.ArgumentTypes[ivar] != typeSym)
                            {
                                // this is to eliminate the paranoid case of types that are equal
                                // but can't convert (think ERRORSYM != ERRORSYM)

                                // See if they just differ in out / ref.
                                TYPESYM argStripped = argInfos.ArgumentTypes[ivar].IsPARAMMODSYM ?
                                    (argInfos.ArgumentTypes[ivar] as PARAMMODSYM).ParamTypeSym :
                                    argInfos.ArgumentTypes[ivar];
                                TYPESYM varStripped = typeSym.IsPARAMMODSYM ?
                                    (typeSym as PARAMMODSYM).ParamTypeSym : typeSym;
                                if (argStripped == varStripped)
                                {
                                    bestMpwi.Set(currentMethPropSym, currentAts, currentTypeArgs);
                                    bestParams = currentParams;
                                }
                            }
                            goto LNextSym;
                        }
                    }
                } // if (argInfos.TypeArgumentCount > 0)

                //----------------------------------------
                // Types of arguments (2) (CS3)Extension methods
                //----------------------------------------
                METHSYM cMethSym = currentMethPropSym as METHSYM;
                if (cMethSym != null && cMethSym.IsInstanceExtensionMethod)
                {
                    DebugUtil.Assert(groupExpr.ObjectExpr != null);

                    METHSYM sMethSym = cMethSym.StaticExtensionMethodSym;
                    DebugUtil.Assert(
                        sMethSym != null &&
                        sMethSym.ParameterTypes != null &&
                        sMethSym.ParameterTypes.Count > 0);

                    TYPESYM argTypeSym1 = Compiler.MainSymbolManager.SubstType(
                        sMethSym.ParameterTypes[0],
                        currentAts,
                        currentTypeArgs);

                    if (!CanConvert(groupExpr.ObjectExpr.TypeSym, argTypeSym1, 0))
                    {
                        goto LNextSym;
                    }
                }

                // We know we have the right number of arguments and they are all convertable.

                //----------------------------------------
                // Add the found METHPROPSYM instance and AGGTYPESYM instance to method list.
                // Or record the error information.
                //----------------------------------------
                if (!canAccess)
                {
                    // In case we never get an accessible method, this will allow us to give
                    // a better error...
                    DebugUtil.Assert(inaccessMpwi.IsNull);
                    inaccessMpwi.Set(currentMethPropSym, currentAts, currentTypeArgs);
                }
                else if (isBogus)
                {
                    // In case we never get a good method, this will allow us to give
                    // a better error...
                    DebugUtil.Assert(bogusMpwi.IsNull);
                    bogusMpwi.Set(currentMethPropSym, currentAts, currentTypeArgs);
                }
                else
                {
                    // This is a plausible method / property to call.
                    //METHLIST * pmeth = STACK_ALLOC(METHLIST, 1);
                    METHLIST newMethList = new METHLIST();

                    // Link it in at the end of the list.
                    //DebugUtil.Assert(!*methListLast);
                    //*methListLast = pmeth;
                    //pmeth.next = null;
                    //methListLast = &pmeth.next;
                    if (methList == null)
                    {
                        methList = methListLast = newMethList;
                    }
                    else
                    {
                        //DebugUtil.Assert(methListLast != null);
                        methListLast.Next = newMethList;
                        methListLast = newMethList;
                    }

                    newMethList.MethPropWithInst.Set(currentMethPropSym, currentAts, currentTypeArgs);
                    //newMethList.ctypeLift = 0;
                    newMethList.ParameterTypes = currentParams;
                    newMethList.IsExpanded = isExpanded;

                    if (currentAts.IsInterfaceType())
                    {
                        // Mark base interfaces.
                        TypeArray ifaces = currentAts.GetIfacesAll();
                        for (int i = 0; i < ifaces.Count; i++)
                        {
                            AGGTYPESYM type = ifaces[i] as AGGTYPESYM;
                            DebugUtil.Assert(type.IsInterfaceType());
                            type.AllHidden = true;
                        }

                        // Mark object.
                        AGGTYPESYM typeObject = this.GetRequiredPredefinedType(PREDEFTYPE.OBJECT);
                        typeObject.AllHidden = true;
                    }
                } // if (!canAccess)

                // Don't look at the expanded form.
                goto LNextSymNoParams;
            } // for (; ; ) // for 1

        LListDone:
            // We looked at all the evidence, and we come to render the verdict:
            METHLIST bestMethList;

            if (methList == null)
            {
                goto LError;
            }

            if (methList.Next == null)
            {
                // We found the single best method to call.
                bestMethList = methList;
            }
            else
            {
                METHLIST ambigMethList1 = null;
                METHLIST ambigMethList2 = null;

                bestMethList = FindBestMethod(methList, argInfos, out ambigMethList1, out ambigMethList2);

                if (bestMethList == null)
                {
                    // Arbitrarily use the first one,
                    // but make sure to report errors or give the ambiguous one
                    // back to the caller.
                    bestMethList = ambigMethList1;
                    if (ambigMethPropWithInst != null)
                    {
                        ambigMethPropWithInst.Set(ambigMethList2.MethPropWithInst);
                    }

                    if (reportErrors)
                    {
                        if (ambigMethList1.ParameterTypes != ambigMethList2.ParameterTypes ||
                            ambigMethList1.MethPropWithInst.MethPropSym.ParameterTypes.Count
                                != ambigMethList2.MethPropWithInst.MethPropSym.ParameterTypes.Count ||
                            ambigMethList1.MethPropWithInst.TypeArguments
                                != ambigMethList2.MethPropWithInst.TypeArguments ||
                            ambigMethList1.MethPropWithInst.AggTypeSym
                                != ambigMethList2.MethPropWithInst.AggTypeSym ||
                            ambigMethList1.MethPropWithInst.MethPropSym.ParameterTypes
                                == ambigMethList2.MethPropWithInst.MethPropSym.ParameterTypes)
                        {
                            Compiler.Error(
                                treeNode,
                                CSCERRID.ERR_AmbigCall,
                                new ErrArg(ambigMethList1.MethPropWithInst),
                                new ErrArg(ambigMethList2.MethPropWithInst));
                        }
                        else
                        {
                            // The two signatures are identical
                            // so don't use the type args in the error message.
                            Compiler.Error(
                                treeNode,
                                CSCERRID.ERR_AmbigCall,
                                new ErrArg(ambigMethList1.MethPropWithInst.MethPropSym),
                                new ErrArg(ambigMethList2.MethPropWithInst.MethPropSym));
                        }
                    }
                }
            } // if (methList.Next == null)

            // This is the "success" exit path.
            DebugUtil.Assert(bestMethList != null);
            bestMpwi = bestMethList.MethPropWithInst;

            methPropWithInst.Set(bestMpwi);
            if (!reportErrors)
            {
                return true;
            }

            // used for Methods and Indexers
            DebugUtil.Assert(
                groupExpr.SymKind == SYMKIND.METHSYM ||
                groupExpr.SymKind == SYMKIND.PROPSYM && (groupExpr.Flags & EXPRFLAG.INDEXER) != 0);
            DebugUtil.Assert(
                groupExpr.TypeArguments.Count == 0 ||
                groupExpr.SymKind == SYMKIND.METHSYM);

            // if this is a binding to finalize on object, then complain:
            if (bestMpwi.MethPropSym.Name == Compiler.NameManager.GetPredefinedName(PREDEFNAME.DTOR) &&
                bestMpwi.MethPropSym.ClassSym.IsPredefAgg(PREDEFTYPE.OBJECT))
            {
                if ((groupExpr.Flags & EXPRFLAG.BASECALL) != 0)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_CallingBaseFinalizeDeprecated);
                }
                else
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_CallingFinalizeDepracated);
                }
            }

            DebugUtil.Assert(
                (groupExpr.Flags & EXPRFLAG.USERCALLABLE) == 0 ||
                bestMpwi.MethPropSym.IsUserCallable());

            if (groupExpr.SymKind == SYMKIND.METHSYM)
            {
                DebugUtil.Assert(bestMpwi.MethPropSym.IsMETHSYM);

                if (bestMpwi.TypeArguments.Count > 0)
                {
                    // Check method type variable constraints.
                    TypeBind.CheckMethConstraints(Compiler, treeNode, MethWithInst.Convert(bestMpwi));
                }
            }

            return true;

        LError:
            //--------------------------------------------------
            // Error handling
            //--------------------------------------------------
            if (!reportErrors)
            {
                return false;
            }
            DebugUtil.Assert(methList == null);

            if (inaccessMpwi != null && inaccessMpwi.IsNotNull)
            {
                // We might have called this, but it is inaccesable...
                Compiler.ClsDeclRec.ReportAccessError(
                    treeNode,
                    inaccessMpwi,
                    this.parentDeclSym,
                    qualTypeSym);
                return false;
            }
            if (bogusMpwi != null && bogusMpwi.IsNotNull)
            {
                // We might have called this, but it is bogus...
                Compiler.ErrorRef(
                    treeNode,
                    CSCERRID.ERR_BindToBogus,
                    new ErrArgRef(bogusMpwi));
                return false;
            }

            bool useDelegateErrors = false;
            string errorName = name;

            if (groupExpr.ObjectExpr != null &&
                groupExpr.ObjectExpr.TypeSym != null &&
                groupExpr.ObjectExpr.TypeSym.IsDelegateType() &&
                groupExpr.Name == Compiler.NameManager.GetPredefinedName(PREDEFNAME.INVOKE))
            {
                DebugUtil.Assert(
                    bestMpwi == null ||
                    bestMpwi.MethPropSym.ClassSym.IsDelegate);
                DebugUtil.Assert(
                    bestMpwi == null ||
                    bestMpwi.AggTypeSym.GetAggregate().IsDelegate);

                useDelegateErrors = true;
                errorName = groupExpr.ObjectExpr.TypeSym.GetAggregate().Name;
            }

            if (bestMpwi != null && bestMpwi.IsNotNull)
            {
                // Best matching overloaded method 'name' had some invalid arguments.
                if (delegateAggTypeSym != null)
                {
                    Compiler.ErrorRef(
                        treeNode,
                        CSCERRID.ERR_MethDelegateMismatch,
                        new ErrArgRef(errorName),
                        new ErrArgRef(delegateAggTypeSym),
                        new ErrArgRef(bestMpwi));
                    return false;
                }

                if (useDelegateErrors)
                {
                    Compiler.Error(
                        treeNode,
                        CSCERRID.ERR_BadDelArgTypes,
                        new ErrArg(bestMpwi.AggTypeSym));
                    // Point to the Delegate, not the Invoke method
                }
                else
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_BadArgTypes, new ErrArgRef(bestMpwi));
                }

                // Argument X: cannot convert type 'Y' to type 'Z'
                for (int ivar = 0; ivar < argInfos.ArgumentCount; ivar++)
                {
                    TYPESYM typeSym = bestParams[ivar];

                    if (!CanConvert(argInfos.ExprList[ivar], typeSym, 0))
                    {
                        // See if they just differ in out / ref.
                        TYPESYM argStripped = argInfos.ArgumentTypes[ivar].IsPARAMMODSYM
                            ? (argInfos.ArgumentTypes[ivar] as PARAMMODSYM).ParamTypeSym
                            : argInfos.ArgumentTypes[ivar];
                        TYPESYM varStripped = typeSym.IsPARAMMODSYM
                            ? (typeSym as PARAMMODSYM).ParamTypeSym
                            : typeSym;
                        if (argStripped == varStripped)
                        {
                            if (varStripped != typeSym)
                            {
                                Compiler.Error(argInfos.ExprList[ivar].TreeNode, CSCERRID.ERR_BadArgRef,
                                    new ErrArg(ivar + 1),
                                    new ErrArg((typeSym as PARAMMODSYM).IsOut ? "out" : "ref"));
                            }
                            else
                            {
                                // the argument is decorated, but doesn't needs a 'ref' or 'out'
                                Compiler.Error(
                                    argInfos.ExprList[ivar].TreeNode,
                                    CSCERRID.ERR_BadArgExtraRef,
                                    new ErrArg(ivar + 1),
                                    new ErrArg((argInfos.ArgumentTypes[ivar] as PARAMMODSYM).IsOut ? "out" : "ref"));
                            }
                        }
                        else
                        {
                            Compiler.Error(
                                argInfos.ExprList[ivar].TreeNode,
                                CSCERRID.ERR_BadArgType,
                                new ErrArg(ivar + 1),
                                new ErrArg(argInfos.ArgumentTypes[ivar], ErrArgFlagsEnum.Unique),
                                new ErrArg(typeSym, ErrArgFlagsEnum.Unique));
                        }
                    }
                }
            }
            else if (cantInferMwt != null && cantInferMwt.IsNotNull)
            {
                Compiler.Error(
                    treeNode,
                    CSCERRID.ERR_CantInferMethTypeArgs,
                    new ErrArg(cantInferMwt));
            }
            else if (badArityMwt != null && badArityMwt.IsNotNull)
            {
                int cvar = badArityMwt.MethSym.TypeVariables.Count;
                Compiler.ErrorRef(
                    treeNode,
                    cvar > 0 ? CSCERRID.ERR_BadArity : CSCERRID.ERR_HasNoTypeVars,
                    new ErrArgRef(badArityMwt),
                    new ErrArgSymKind(badArityMwt.MethSym),
                    new ErrArgRef(argInfos.ArgumentCount));
            }
            else if (paramTypeConstraintsMpwi != null && paramTypeConstraintsMpwi.IsNotNull)
            {
                // This will always report an error
                TypeBind.CheckMethConstraints(
                    Compiler,
                    treeNode,
                    MethWithInst.Convert(paramTypeConstraintsMpwi));
            }
            else
            {
                CError err = null;

                if (delegateAggTypeSym != null)
                {
                    err = Compiler.MakeError(
                        treeNode,
                        CSCERRID.ERR_MethDelegateMismatch,
                        new ErrArg(errorName),
                        new ErrArg(delegateAggTypeSym));
                    Compiler.AddRelatedSymLoc(err, delegateAggTypeSym);
                }
                else
                {
                    if ((groupExpr.Flags & EXPRFLAG.CTOR) != 0)
                    {
                        errorName = groupExpr.ParentTypeSym.IsTYVARSYM
                            ? groupExpr.ParentTypeSym.Name
                            : groupExpr.ParentTypeSym.GetAggregate().Name;
                    }

                    err = Compiler.MakeError(
                        treeNode,
                        useDelegateErrors ? CSCERRID.ERR_BadDelArgCount : CSCERRID.ERR_BadArgCount,
                        new ErrArg(errorName),
                        new ErrArg(argInfos.ArgumentCount));
                }

                for (int i = 0; i < wrongSwtCount.Count; ++i)
                {
                    if (Compiler.ClsDeclRec.CheckAccess(
                            wrongSwtCount[i].Sym,
                            wrongSwtCount[i].AggTypeSym,
                            this.parentDeclSym,
                            qualTypeSym))
                    {
                        Compiler.AddRelatedSymLoc(err, wrongSwtCount[i].Sym);
                    }
                }
                Compiler.SubmitError(err);
            }

            return false;
        }

        //--------------------------------------------------
        // FUNCBREC.FillInArgInfoFromArgList
        //
        /// <summary>
        /// Fill argInfo.ExprList with EXPR instances in the list starting at args,
        /// and fill argInfo.TypeArguments with EXPR.TypeSym instances.
        /// </summary>
        /// <param name="argInfo"></param>
        /// <param name="args"></param>
        //--------------------------------------------------
        private void FillInArgInfoFromArgList(ArgInfos argInfo, EXPR args)
        {
            //TYPESYM ** prgtype = STACK_ALLOC(TYPESYM*, argInfo.carg);
            argInfo.ExprList = new List<EXPR>();
            TypeArray typeArray = new TypeArray();
            argInfo.HasExprs = true;

            int iarg = 0;
            for (EXPR list = args; list != null; iarg++)
            {
                EXPR arg;
                if (list.Kind == EXPRKIND.LIST)
                {
                    arg = list.AsBIN.Operand1;
                    list = list.AsBIN.Operand2;
                }
                else
                {
                    arg = list;
                    list = null;
                }
                //prgtype[iarg] = arg.type;
                //argInfo.prgexpr[iarg] = arg;
                argInfo.ExprList.Add(arg);
                typeArray.Add(arg.TypeSym);
            }
            //DebugUtil.Assert(iarg == argInfo.carg);
            argInfo.ArgumentTypes = Compiler.MainSymbolManager.AllocParams(typeArray);
        }

        //--------------------------------------------------
        // FUNCBREC.BindGrpToParams
        //
        /// <summary>
        /// Given a method group, find one with the correct parameter types.
        /// This does NOT do type argument inferencing.
        /// </summary>
        /// <param name="methPropWI"></param>
        /// <param name="treeNode"></param>
        /// <param name="grpExpr"></param>
        /// <param name="parameterArray"></param>
        /// <param name="reportErrors"></param>
        /// <param name="ambigMethPropWI"></param>
        /// <param name="returnTypeSym"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool BindGrpToParams(
            MethPropWithInst methPropWithInst,
            BASENODE treeNode,
            EXPRMEMGRP grpExpr,
            TypeArray parameterArray,
            bool reportErrors,
            MethPropWithInst ambigMethPropWI,
            TYPESYM returnTypeSym)	//  = null
        {
            DebugUtil.Assert(methPropWithInst != null);
            DebugUtil.Assert(
                grpExpr.SymKind == SYMKIND.METHSYM ||
                grpExpr.SymKind == SYMKIND.PROPSYM);
            DebugUtil.Assert(reportErrors || ambigMethPropWI != null);

            string name = grpExpr.Name;
            TypeArray typeArgs = grpExpr.TypeArguments;
            SYMBMASK mask = (SYMBMASK)((ulong)1 << (int)grpExpr.SymKind);

            // Only methods should have type args.
            DebugUtil.Assert(mask == SYMBMASK.METHSYM || typeArgs.Count == 0);
            TYPESYM qualTypeSym;

            if ((grpExpr.Flags & EXPRFLAG.BASECALL) != 0)
            {
                qualTypeSym = null;
            }
            else if ((grpExpr.Flags & EXPRFLAG.CTOR) != 0)
            {
                qualTypeSym = grpExpr.ParentTypeSym;
            }
            else if (grpExpr.ObjectExpr != null)
            {
                TYPESYM objTypeSym = grpExpr.ObjectExpr.TypeSym;
                qualTypeSym = null;
                switch (objTypeSym.Kind)
                {
                    case SYMKIND.ANONMETHSYM:
                        EXPRANONMETH anonMethExpr = grpExpr.ObjectExpr as EXPRANONMETH;
                        if (anonMethExpr != null)
                        {
                            qualTypeSym = anonMethExpr.AnonymousMethodInfo.ReturnTypeSym;
                        }
                        break;

                    case SYMKIND.LAMBDAEXPRSYM:
                        EXPRLAMBDAEXPR lambdaExpr = grpExpr.ObjectExpr as EXPRLAMBDAEXPR;
                        if (lambdaExpr != null)
                        {
                            qualTypeSym = lambdaExpr.AnonymousMethodInfo.ReturnTypeSym;
                        }
                        break;

                    default:
                        qualTypeSym = grpExpr.ObjectExpr.TypeSym;
                        break;
                }
            }
            else
            {
                qualTypeSym = null;
            }

            TypeArray containingTypeArray = grpExpr.ContainingTypeArray;
            if (containingTypeArray == null)
            {
                containingTypeArray = BSYMMGR.EmptyTypeArray;
            }
            DebugUtil.Assert(
                containingTypeArray.Count > 0 ||
                !grpExpr.ParentTypeSym.IsInterfaceType());

            AGGTYPESYM currentAggTypeSym;
            int itypeCur = 0;

            if (containingTypeArray.Count > 0)
            {
                currentAggTypeSym = containingTypeArray[itypeCur] as AGGTYPESYM;
                // Clear all the hidden flags.
                for (int i = 0; i < containingTypeArray.Count; i++)
                {
                    (containingTypeArray[i] as AGGTYPESYM).AllHidden = false;
                }
            }
            else
            {
                // If the full set of types isn't given, we better be in a class.
                // For the interface and type variable case,
                // MemberLookup.Lookup should have been called.
                DebugUtil.Assert(
                    grpExpr.ParentTypeSym.IsAGGTYPESYM &&
                    !grpExpr.ParentTypeSym.IsInterfaceType());
                currentAggTypeSym = grpExpr.ParentTypeSym as AGGTYPESYM;
            }

            DebugUtil.Assert(
                grpExpr.MethPropSym == null ||
                grpExpr.MethPropSym.ClassSym == currentAggTypeSym.GetAggregate());

            ArgInfos paramArgInfos = new ArgInfos();
            //paramArgInfos.carg = parameterArray.size;
            paramArgInfos.ArgumentTypes = parameterArray;
            paramArgInfos.HasExprs = false;

            MethPropWithInst mpwiFound = new MethPropWithInst(null, null, null);
            MethPropWithInst mpwiInaccess = new MethPropWithInst(null, null, null);
            MethPropWithInst mpwiBogus = new MethPropWithInst(null, null, null);
            MethPropWithInst mpwiAmbig = new MethPropWithInst(null, null, null);
            MethWithType mwtBadArity = new MethWithType(null, null);

            //SymWithType[] wrongSymWTList = new SymWithType[20];
            List<SymWithType> wrongSymWTList = new List<SymWithType>();
            const int wrongSwtMaxCount = 20;
            //int wrongCountCount = 0;
            //int cswtWrongSig = 0;
            bool countWrongSig = false;
            bool isBaseHidden = false;

            // Look for matches.
            for (METHPROPSYM currentMethPropSym = null; ; )
            {
                // Find the next sym.
                currentMethPropSym =
                    (currentMethPropSym == null)
                    ? Compiler.MainSymbolManager.LookupAggMember(
                        name,
                        currentAggTypeSym.GetAggregate(),
                        mask) as METHPROPSYM
                    : BSYMMGR.LookupNextSym(
                        currentMethPropSym,
                        currentAggTypeSym.GetAggregate(),
                        mask) as METHPROPSYM;

                if (currentMethPropSym == null)
                {
                    // Find the next type.
                    if (isBaseHidden)
                    {
                        // Something in the current class has hidden everything
                        // in base classes and interfaces.
                        DebugUtil.Assert(!currentAggTypeSym.IsInterfaceType());
                        break;
                    }
                    if (mpwiFound != null && !mpwiFound.AggTypeSym.IsInterfaceType())
                    {
                        // We've found some applicable methods in a class
                        // so we don't need to look any further.
                        break;
                    }
                    if (containingTypeArray.Count > 0)
                    {
                        for (; ; )
                        {
                            if (++itypeCur >= containingTypeArray.Count)
                            {
                                goto LSearchDone;
                            }
                            currentAggTypeSym = containingTypeArray[itypeCur] as AGGTYPESYM;
                            if (!currentAggTypeSym.AllHidden) break;
                        }
                    }
                    else
                    {
                        DebugUtil.Assert(mpwiFound == null);
                        currentAggTypeSym = currentAggTypeSym.GetBaseClass();
                        if (currentAggTypeSym == null)
                        {
                            break;
                        }
                    }
                    continue;
                }

                if (grpExpr.MethPropSym != null && currentMethPropSym != grpExpr.MethPropSym)
                {
                    continue;
                }

                // Make sure that whether we're seeing a ctor is consistent with the flag.
                // The only properties we handle are indexers.
                if (mask == SYMBMASK.METHSYM && (
                        ((grpExpr.Flags & EXPRFLAG.CTOR) == 0) == (currentMethPropSym as METHSYM).IsCtor ||
                        ((grpExpr.Flags & EXPRFLAG.OPERATOR) == 0) == (currentMethPropSym as METHSYM).IsOperator) ||
                    mask == SYMBMASK.PROPSYM && !(currentMethPropSym as PROPSYM).IsIndexer)
                {
                    // Get the next symbol.
                    continue;
                }

                if (!IsMethPropCallable(currentMethPropSym, (grpExpr.Flags & EXPRFLAG.USERCALLABLE) != 0))
                {
                    continue;
                }

                if (parameterArray.Count != currentMethPropSym.ParameterTypes.Count)
                {
                    //if (cswtWrongCount < cswtMaxWrong && cswtWrongSig == 0)
                    //    wrongSymWTList[cswtWrongCount++].Set(currentMethPropSym, currentAggTypeSym);
                    if (wrongSymWTList.Count < wrongSwtMaxCount && !countWrongSig)
                    {
                        wrongSymWTList.Add(new SymWithType(currentMethPropSym, currentAggTypeSym));
                    }
                    continue;
                }

                if (currentMethPropSym.IsMETHSYM &&
                    (currentMethPropSym as METHSYM).TypeVariables.Count != typeArgs.Count)
                {
                    if (mwtBadArity == null)
                    {
                        mwtBadArity.Set(currentMethPropSym as METHSYM, currentAggTypeSym);
                    }
                    continue;
                }

                if (!Compiler.MainSymbolManager.SubstEqualTypeArrays(
                        parameterArray,
                        currentMethPropSym.ParameterTypes,
                        currentAggTypeSym,
                        typeArgs))
                {
                    if (!countWrongSig)
                    {
                        wrongSymWTList.Clear();
                        countWrongSig = true;
                    }
                    if (wrongSymWTList.Count < wrongSwtMaxCount)
                    {
                        wrongSymWTList.Add(new SymWithType(currentMethPropSym, currentAggTypeSym));
                    }
                    continue;
                }

                if (returnTypeSym != null &&
                    returnTypeSym != Compiler.MainSymbolManager.SubstType(
                    currentMethPropSym.ReturnTypeSym, currentAggTypeSym, typeArgs))
                {
                    if (!countWrongSig)
                    {
                        wrongSymWTList.Clear();
                        countWrongSig = true;
                    }
                    if (wrongSymWTList.Count < wrongSwtMaxCount)
                    {
                        wrongSymWTList.Add(new SymWithType(currentMethPropSym, currentAggTypeSym));
                    }
                    continue;
                }


                if (!Compiler.ClsDeclRec.CheckAccess(currentMethPropSym, currentAggTypeSym, this.parentDeclSym, qualTypeSym))
                {
                    if (mpwiInaccess == null && mpwiFound == null)
                    {
                        mpwiInaccess.Set(currentMethPropSym, currentAggTypeSym, typeArgs);
                    }
                    continue;
                }
                if (Compiler.CheckBogus(currentMethPropSym))
                {
                    if (mpwiBogus == null && mpwiFound == null)
                    {
                        mpwiBogus.Set(currentMethPropSym, currentAggTypeSym, typeArgs);
                    }
                    continue;
                }

                if (mpwiFound.IsNull)
                {
                    mpwiFound.Set(currentMethPropSym, currentAggTypeSym, typeArgs);
                    DebugUtil.Assert(mpwiAmbig.IsNull);
                }
                else if (mpwiFound.MethPropSym.CModifierCount != currentMethPropSym.CModifierCount)
                {
                    if (mpwiFound.MethPropSym.CModifierCount > currentMethPropSym.CModifierCount)
                    {
                        // currentMethPropSym is better.
                        mpwiFound.Set(currentMethPropSym, currentAggTypeSym, typeArgs);
                        mpwiAmbig.Clear();
                    }
                }
                else if (mpwiAmbig == null)
                {
                    // Ambiguous.
                    mpwiAmbig.Set(currentMethPropSym, currentAggTypeSym, typeArgs);
                }

                if (!currentAggTypeSym.IsInterfaceType())
                {
                    // This one hides all possibilities in base classes and in all interfaces.
                    isBaseHidden = true;
                }
                else
                {
                    // This one hides all possibilities in base interfaces so mark them.
                    TypeArray ifaces = currentAggTypeSym.GetIfacesAll();
                    for (int i = 0; i < ifaces.Count; i++)
                    {
                        AGGTYPESYM type = ifaces[i] as AGGTYPESYM;
                        DebugUtil.Assert(type.IsInterfaceType());
                        type.AllHidden = true;
                    }

                    // Mark object.
                    AGGTYPESYM typeObject = this.GetRequiredPredefinedType(PREDEFTYPE.OBJECT);
                    typeObject.AllHidden = true;
                }
            }

        LSearchDone:
            if (ambigMethPropWI != null)
            {
                ambigMethPropWI = mpwiAmbig;
            }

            if (reportErrors)
            {
                if (mpwiFound == null)
                {
                    DebugUtil.Assert(mpwiAmbig == null);
                    if (mpwiInaccess != null)
                    {
                        // We might have called this, but it is inaccesible...
                        Compiler.ClsDeclRec.ReportAccessError(
                            treeNode,
                            mpwiInaccess,
                            this.parentDeclSym,
                            qualTypeSym);
                    }
                    else if (mpwiBogus != null)
                    {
                        // We might have called this, but it is bogus...
                        Compiler.ErrorRef(
                            treeNode,
                            CSCERRID.ERR_BindToBogus,
                            new ErrArgRef(mpwiBogus));
                    }
                    else if (mwtBadArity != null && !countWrongSig)
                    {
                        int cvar = mwtBadArity.MethSym.TypeVariables.Count;
                        Compiler.ErrorRef(
                            treeNode,
                            cvar > 0 ? CSCERRID.ERR_BadArity : CSCERRID.ERR_HasNoTypeVars,
                            new ErrArgRef(mwtBadArity),
                            new ErrArgSymKind(mwtBadArity.MethSym),
                            new ErrArgRef(cvar));
                    }
                    else
                    {
                        CError err = Compiler.MakeError(
                            treeNode,
                            countWrongSig  ? CSCERRID.ERR_WrongSignature : CSCERRID.ERR_BadArgCount,
                            new ErrArg(name),
                            new ErrArg(parameterArray.Count));

                        int cswt = wrongSymWTList.Count;

                        // Report possible matches (same name and is accesible).
                        for (int i = 0; i < cswt; i++)
                        {
                            if (Compiler.ClsDeclRec.CheckAccess(
                                    wrongSymWTList[i].Sym,
                                    wrongSymWTList[i].AggTypeSym,
                                    this.parentDeclSym,
                                    qualTypeSym))
                            {
                                Compiler.AddRelatedSymLoc(err, wrongSymWTList[i].Sym);
                            }
                        }
                        Compiler.SubmitError(err);
                    }
                }
                else if (mpwiAmbig != null && mpwiAmbig.IsNotNull)
                {
                    Compiler.Error(
                        treeNode,
                        CSCERRID.ERR_AmbigMember,
                        new ErrArg(mpwiFound),
                        new ErrArg(mpwiAmbig));
                    // Return one of them.
                }
            }

            methPropWithInst.Set(mpwiFound);
            return (mpwiFound != null && mpwiFound.IsNotNull);
        }

        //------------------------------------------------------------
        // bool FUNCBREC::BindGrpConversion(
        //     BASENODE * tree, EXPRMEMGRP * grp, TYPESYM * typeDst, EXPR ** pexprDst, bool fReportErrors)
        //
        // Convert a method group to a delegate type.
        // 
        // NOTE: Currently it is not well defined when there is an implicit conversion from a method
        // group to a delegate type. There are several possibilities. On the two extremes are:
        // 
        // (1) (Most permissive) When there is at least one applicable method in the method group.
        // 
        // (2) (Most restrictive) When all of the following are satisified:
        //     * Overload resolution does not produce an error
        //     * The method's parameter types don't require any conversions other than implicit reference
        //       conversions.
        //     * The method's return type is compatible.
        //     * The method's constraints are satisified.
        //     * The method is not conditional.
        // 
        // For (1), it may be the case that an error is produced whenever the conversion is actually used.
        // For example, if the result of overload resolution is ambiguous or if the result of overload
        // resolution is a method with the wrong return result or with unsatisfied constraints.
        // 
        // For (2), the intent is that if the answer is yes, then an error is never produced.
        // 
        // Note that (2) is not monotone: adding a method to the method group may cause the answer
        // to go from yes to no. This has a very odd effect in certain situations:
        // 
        // Suppose:
        //     * I1 and J1 are interfaces with I1 : J1.
        //     * I2, J2 and K2 are interfaces with I2 : J2, K2.
        //     * Di is a delegate type with signature void Di(Ii).
        //     * A method group named F contains F(D1(I1)) and F(D2(I2)).
        //     * There is another method group named M containing a subset of:
        //         void M(J1)
        //         void M(J2)
        //         void M(K2)
        // 
        // Under any of the definitions we're considering:
        // 
        //     * If M is { M(J1), M(J2) } then F(M) is an error (ambiguous between F(D1) and F(D2)).
        //     * If M is { M(J1), M(K2) } then F(M) is an error (ambiguous between F(D1) and F(D2)).
        //     * If M is { M(J2), M(K2) } then F(M) is an error (M -> D2 is ambiguous).
        // 
        // If M is { M(J1), M(J2), M(K2) } what should F(M) be? It seems logical for F(M) to be ambiguous
        // in this case as well. However, under definition (2), there is no implicit conversion from M
        // to D2 (since overload resolution is ambiguous). Thus F(M) is unambiguously taken to mean
        // F(D1) applied to M(J1). Note that the user has just made the situation more ambiguous by having
        // all three methods in the method group, but we ignore this additional ambiguity and pick a
        // winner (rather arbitrarily).
        // 
        // We currently implement (1). The spec needs to be tightened up.
        // REVIEW ShonK: Fix the spec.
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindGrpConversion
        //
        /// <summary>
        /// Convert a method group to a delegate type.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="grpExpr"></param>
        /// <param name="dstTypeSym"></param>
        /// <param name="dstExpr"></param>
        /// <param name="reportErrors"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private bool BindGrpConversion(
            BASENODE treeNode,
            EXPRMEMGRP grpExpr,
            TYPESYM dstTypeSym,
            ref EXPR dstExpr,
            bool reportErrors)
        {
            //dstExpr = null;

            if (!dstTypeSym.IsDelegateType())
            {
                if (reportErrors)
                {
                    Compiler.Error(
                        treeNode,
                        CSCERRID.ERR_MethGrpToNonDel,
                        new ErrArg(grpExpr.Name),
                        new ErrArg(dstTypeSym));
                }
                return false;
            }

            AGGTYPESYM aggTypeSym = dstTypeSym as AGGTYPESYM;

            METHSYM ctorMethSym = null;
            METHSYM invokeMethSym = null;

            ctorMethSym = FindDelegateCtor(aggTypeSym, treeNode, reportErrors);
            if (ctorMethSym == null)
            {
                return false;
            }

            // Now, find the invoke function on the delegate.
            invokeMethSym = Compiler.MainSymbolManager.LookupInvokeMeth(aggTypeSym.GetAggregate());
            DebugUtil.Assert(invokeMethSym != null && invokeMethSym.IsInvoke);

            TypeArray paramTypes = Compiler.MainSymbolManager.SubstTypeArray(
                invokeMethSym.ParameterTypes,
                aggTypeSym,
                null);

            TYPESYM returnTypeSym = Compiler.MainSymbolManager.SubstType(
                invokeMethSym.ReturnTypeSym,
                aggTypeSym,
                null);

            ArgInfos argInfos = new ArgInfos();
            //argInfos.carg = typeParams.size;
            argInfos.ArgumentTypes = paramTypes;
            argInfos.HasExprs = false;

            // Next, verify that the function has a suitable ty^pe for the invoke method.
            MethWithInst wrapMwi = new MethWithInst();
            MethWithInst ambigMwi = new MethWithInst();

            if (Compiler.OptionManager.IsLangVersionECMA1)
            {
                if (!BindGrpToParams(
                    wrapMwi,
                    treeNode,
                    grpExpr,
                    paramTypes,
                    reportErrors,
                    ambigMwi,
                    returnTypeSym))
                {
                    return false;
                }
            }
            else
            {
                if (!BindGrpToArgsCore(
                    wrapMwi,
                    treeNode,
                    BindFlagsEnum.NoParams,
                    grpExpr,
                    argInfos,
                    aggTypeSym,
                    reportErrors,
                    ambigMwi))
                {
                    return false;
                }
            }

            // From here on we should only return true.
            //if (!reportErrors && !dstExpr)
            //    return true;

            // Note: We report errors below even if reportErrors is false. Note however that we only
            // get here if dstExpr is non-null and we'll return true even if we report an error, so this
            // is really the only chance we'll get to report the error.
            bool isError = (ambigMwi != null && ambigMwi.IsNotNull);

            if (ambigMwi != null && ambigMwi.IsNotNull && !reportErrors)
            {
                // Report the ambiguity, since BindGrpToArgsCore didn't.
                Compiler.Error(treeNode, CSCERRID.ERR_AmbigCall, new ErrArg(wrapMwi), new ErrArg(ambigMwi));
            }

            TYPESYM realReturnTypeSym = Compiler.MainSymbolManager.SubstType(
                wrapMwi.MethSym.ReturnTypeSym,
                wrapMwi.AggTypeSym,
                wrapMwi.TypeArguments);
            if (returnTypeSym != realReturnTypeSym &&
                !FImpRefConv(realReturnTypeSym, returnTypeSym))
            {
                Compiler.ErrorRef(
                    treeNode,
                    CSCERRID.ERR_BadRetType,
                    new ErrArgRef(wrapMwi),
                    new ErrArgRef(realReturnTypeSym));
                isError = true;
            }

            TypeArray realParamTypes = Compiler.MainSymbolManager.SubstTypeArray(
                wrapMwi.MethSym.ParameterTypes,
                wrapMwi.AggTypeSym,
                wrapMwi.TypeArguments);

            if (realParamTypes != paramTypes)
            {
                for (int i = 0; i < realParamTypes.Count; i++)
                {
                    TYPESYM param = paramTypes[i];
                    TYPESYM paramReal = realParamTypes[i];

                    if (param != paramReal && !FImpRefConv(param, paramReal))
                    {
                        Compiler.ErrorRef(
                            treeNode,
                            CSCERRID.ERR_MethDelegateMismatch,
                            new ErrArgRef(wrapMwi),
                            new ErrArgRef(dstTypeSym));
                        isError = true;
                        break;
                    }
                }
            }

            EXPR expr = grpExpr.ObjectExpr;
            bool isConstrained = false; // dummy

            PostBindMeth(
                treeNode,
                (grpExpr.Flags & EXPRFLAG.BASECALL) != 0,
                wrapMwi,
                ref expr,
                ref isConstrained);
            DebugUtil.Assert(wrapMwi.MethSym.Kind == SYMKIND.METHSYM);

            if (wrapMwi.TypeArguments.Count > 0)
            {
                // Check method ty^pe variable constraints.
                TypeBind.CheckMethConstraints(Compiler, treeNode, wrapMwi);
            }

            if (Compiler.ClsDeclRec.GetConditionalSymbols(wrapMwi.MethSym) != null)
            {
                Compiler.ErrorRef(treeNode, CSCERRID.ERR_DelegateOnConditional, new ErrArgRef(wrapMwi));
            }

            // Warn if the new binding rules found something different from the old binding rules.
            // Again we specifically ignore reportErrors because we need to report the warning
            // if we're going to succeed the bind
            if (realParamTypes != paramTypes &&
                !isError &&
                !Compiler.OptionManager.IsLangVersionECMA1)
            {
                MethWithInst oldMwi = new MethWithInst();
                MethWithInst tempMwi = new MethWithInst();

                if (BindGrpToParams(
                    oldMwi,
                    treeNode,
                    grpExpr,
                    paramTypes,
                    false,
                    tempMwi,
                    null))
                {
                    Compiler.Error(
                        treeNode,
                        CSCERRID.WRN_DelegateNewMethBind,
                        new ErrArg(dstTypeSym),
                        new ErrArgRef(wrapMwi),
                        new ErrArgRef(oldMwi));
                }
            }

            //if (!dstExpr)
            //    return true;

            EXPRFUNCPTR funcPtrExpr = NewExpr(grpExpr.TreeNode, EXPRKIND.FUNCPTR, GetVoidType()) as EXPRFUNCPTR;
            funcPtrExpr.MethWithInst = wrapMwi;
            funcPtrExpr.Flags |= (grpExpr.Flags & EXPRFLAG.BASECALL);

            if (!wrapMwi.MethSym.IsStatic)
            {
                if (wrapMwi.MethSym.ClassSym.IsPredefAgg(PREDEFTYPE.G_OPTIONAL))
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_DelegateOnNullable, new ErrArg(wrapMwi));
                }
                funcPtrExpr.ObjectExpr = expr;
                if (expr != null && expr.TypeSym.FundamentalType() != FUNDTYPE.REF)
                {
                    // Must box the object before creating a delegate to it.
                    expr = MustConvert(expr, GetRequiredPredefinedType(PREDEFTYPE.OBJECT), 0);
                }
            }
            else
            {
                funcPtrExpr.ObjectExpr = null;
                expr = BindNull(null);
            }

            EXPRCALL callExpr = NewExpr(grpExpr.TreeNode, EXPRKIND.CALL, aggTypeSym) as EXPRCALL;
            callExpr.ArgumentsExpr = NewExprBinop(null, EXPRKIND.LIST, GetVoidType(), expr, funcPtrExpr);
            callExpr.ObjectExpr = null;
            callExpr.MethodWithInst.Set(ctorMethSym, aggTypeSym, null);
            callExpr.Flags |= EXPRFLAG.NEWOBJCALL | EXPRFLAG.CANTBENULL;

            dstExpr = callExpr;

            // If we actually create the destination ex^pr, then set the node sym and ex^pr.
            if ((grpExpr.Flags & EXPRFLAG.DELEGATE) == 0)
            {
                SetNodeExpr(grpExpr.TreeNode, callExpr);
            }
            return true;
        }

        //------------------------------------------------------------
        // FUNCBREC.PostBindMeth
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="isBaseCall"></param>
        /// <param name="methWithInst"></param>
        /// <param name="expr"></param>
        /// <param name="isConstrained"></param>
        //------------------------------------------------------------
        private void PostBindMeth(
            BASENODE treeNode,
            bool isBaseCall,
            MethWithInst methWithInst,
            ref EXPR objectExpr,
            ref bool isConstrained)
        {
            MethWithInst origMwi = methWithInst;
            EXPR origExpr = objectExpr;

            // If it is virtual, find a remap of the method to something more specific.
            // This may alter where the method is found.
            if (objectExpr != null &&
                (isBaseCall || objectExpr.TypeSym.IsSimpleType() || objectExpr.TypeSym.IsSpecialByRefType()))
            {
                RemapToOverride(methWithInst, objectExpr.TypeSym);
            }

            AdjustMemberObj(treeNode, methWithInst, ref objectExpr, ref isConstrained);
            CheckFieldUse(origExpr, true);

            if (isBaseCall && methWithInst.MethSym.IsAbstract)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_AbstractBaseCall, new ErrArg(methWithInst));
            }

            if (origMwi.MethSym.IsDeprecated())
            {
                ReportDeprecated(treeNode, origMwi);
            }
            else if (methWithInst.MethSym.IsDeprecated())
            {
                ReportDeprecated(treeNode, methWithInst);
            }

            if (methWithInst.MethSym.ReturnTypeSym != null)
            {
                Compiler.EnsureState(methWithInst.MethSym.ReturnTypeSym, AggStateEnum.Prepared);
                CheckUnsafe(treeNode, methWithInst.MethSym.ReturnTypeSym, CSCERRID.ERR_UnsafeNeeded, null);
                bool checkParams = false;

                if (methWithInst.MethSym.IsExternal)
                {
                    checkParams = true;
                    SetExternalRef(methWithInst.MethSym.ReturnTypeSym);
                }

                // We need to check unsafe on the parameters as well, since we cannot check in conversion.
                TypeArray paramArray = methWithInst.MethSym.ParameterTypes;
                Compiler.EnsureState(paramArray, AggStateEnum.Prepared);

                for (int i = 0; i < paramArray.Count; i++)
                {
                    // This is an optimization: don't call this in the vast majority of cases
                    TYPESYM typeSym = paramArray[i];

                    if (typeSym.IsUnsafe())
                    {
                        CheckUnsafe(treeNode, typeSym, CSCERRID.ERR_UnsafeNeeded, null);
                    }
                    if (checkParams && typeSym.IsPARAMMODSYM)
                    {
                        SetExternalRef(typeSym);
                    }
                }
            }
        }

        //------------------------------------------------------------
        // FUNCBREC.PostBindProp
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="isBaseCall"></param>
        /// <param name="propWithType"></param>
        /// <param name="expr"></param>
        /// <param name="isConstrained"></param>
        /// <param name="getMethWithType"></param>
        /// <param name="setMethWithType"></param>
        //------------------------------------------------------------
        private void PostBindProp(
            BASENODE tree,
            bool isBaseCall,
            PropWithType propWithType,
            ref EXPR expr,
            ref bool isConstrained,
            MethWithType getMethWithType,
            MethWithType setMethWithType)
        {
            DebugUtil.Assert(getMethWithType != null);
            DebugUtil.Assert(setMethWithType != null);
            EXPR origExpr = expr;

            // Get the accessors.
            if (propWithType.PropSym.GetMethodSym != null)
            {
                getMethWithType.Set(propWithType.PropSym.GetMethodSym, propWithType.AggTypeSym);
            }
            else
            {
                getMethWithType.Clear();
            }
            if (propWithType.PropSym.SetMethodSym != null)
            {
                setMethWithType.Set(propWithType.PropSym.SetMethodSym, propWithType.AggTypeSym);
            }
            else
            {
                setMethWithType.Clear();
            }

            // If it is virtual, find a remap of the method to something more specific.  This
            // may alter where the accessors are found.
            if (isBaseCall && expr != null)
            {
                if (getMethWithType.IsNotNull)
                {
                    RemapToOverride(getMethWithType, expr.TypeSym);
                }
                if (setMethWithType.IsNotNull)
                {
                    RemapToOverride(setMethWithType, expr.TypeSym);
                }
            }

            if (getMethWithType.IsNotNull &&
                (setMethWithType.IsNull ||
                setMethWithType.AggTypeSym == getMethWithType.AggTypeSym ||
                Compiler.IsBaseType(getMethWithType.AggTypeSym, setMethWithType.AggTypeSym)))
            {
                AdjustMemberObj(tree, getMethWithType, ref expr, ref isConstrained);
            }
            else if (setMethWithType.IsNotNull)
            {
                AdjustMemberObj(tree, setMethWithType, ref expr, ref isConstrained);
            }
            else
            {
                AdjustMemberObj(tree, propWithType, ref expr, ref isConstrained);
            }

            CheckFieldUse(origExpr, true);

            if (propWithType.PropSym.IsDeprecated())
            {
                ReportDeprecated(tree, propWithType);
            }
            else if (getMethWithType.IsNotNull && getMethWithType.MethSym.PropertySym.IsDeprecated())
            {
                ReportDeprecated(
                    tree,
                    new PropWithType(getMethWithType.MethSym.PropertySym, getMethWithType.AggTypeSym));
            }
            else if (setMethWithType.IsNotNull && setMethWithType.MethSym.PropertySym.IsDeprecated())
            {
                ReportDeprecated(
                    tree,
                    new PropWithType(setMethWithType.MethSym.PropertySym, setMethWithType.AggTypeSym));
            }

            if (propWithType.PropSym.ReturnTypeSym != null)
            {
                Compiler.EnsureState(propWithType.PropSym.ReturnTypeSym, AggStateEnum.Prepared);
                CheckUnsafe(tree, propWithType.PropSym.ReturnTypeSym, CSCERRID.ERR_UnsafeNeeded, null);
            }
        }

        //------------------------------------------------------------
        // FUNCBREC.SetExternalRef
        //
        /// <summary>
        /// Set HasExternReference flags of the AGGSYM of argument TYPESYM
        /// and its children.
        /// </summary>
        /// <param name="typeSym"></param>
        //------------------------------------------------------------
        private void SetExternalRef(TYPESYM typeSym)
        {
            AGGSYM aggSym = typeSym.GetNakedAgg(false);
            if (aggSym == null || aggSym.HasExternReference) return;

            aggSym.HasExternReference = true;
            for (SYM sym = aggSym.FirstChildSym; sym != null; sym = sym.NextSym)
            {
                if (sym.IsMEMBVARSYM)
                {
                    SetExternalRef((sym as MEMBVARSYM).TypeSym);
                }
            }
        }

        //------------------------------------------------------------
        // FUNCBREC.RemapToOverride
        //
        /// <summary>
        /// <para>For a base call we need to remap from the virtual to the specific override to invoke.</para>
        /// <para>This is also used to map a virtual on object (like ToString) to the specific override
        /// when the object is a simple type (int, bool, char, etc).</para>
        /// <para>In these cases it is safe to assume that any override won't later be removed....</para>
        /// <para>We start searching from "typeObj" up the superclass hierarchy
        /// until we find a method with an exact signature match.</para>
        /// <para>Examine that symWithType.Sym is overrided.
        /// If overrided, replace symWithType.Sym with the overriding sym.</para>
        /// </summary>
        /// <param name="symWithType"></param>
        /// <param name="exprTypeSym"></param>
        //------------------------------------------------------------
        private void RemapToOverride(SymWithType symWithType, TYPESYM objectTypeSym)
        {
            // For a property/indexer we remap the accessors, not the property/indexer.
            // Since every event has both accessors we remap the event instead of the accessors.
            DebugUtil.Assert(
                symWithType != null &&
                symWithType.IsNotNull &&
                (symWithType.Sym.IsMETHSYM || symWithType.Sym.IsEVENTSYM));
            DebugUtil.Assert(objectTypeSym != null);

            // Don't remap static or interface methods.
            if (objectTypeSym.IsNUBSYM)
            {
                objectTypeSym = (objectTypeSym as NUBSYM).GetAggTypeSym();
                if (objectTypeSym == null)
                {
                    DebugUtil.Assert(false, "Why did GetAts return null?");
                    return;
                }
            }
            else if (!objectTypeSym.IsAGGTYPESYM || objectTypeSym.IsInterfaceType())
            {
                return;
            }
            DebugUtil.Assert(objectTypeSym.IsAGGTYPESYM);

            // Don't remap non-virtual methods or events.
            if (!symWithType.Sym.IsVirtual())
            {
                return;
            }

            SYMBMASK mask = symWithType.Sym.Mask;

            AGGTYPESYM objectAts = objectTypeSym as AGGTYPESYM;

            while (objectAts != null && objectAts.GetAggregate() != symWithType.Sym.ParentSym)
            {
                for (SYM symT = Compiler.MainSymbolManager.LookupAggMember(
                    symWithType.Sym.Name, objectAts.GetAggregate(), mask);
                    symT != null;
                    symT = BSYMMGR.LookupNextSym(symT, objectAts.GetAggregate(), mask))
                {
                    if (symT.IsOverride() &&
                        (symT.SymBaseVirtual() == symWithType.Sym ||
                        symT.SymBaseVirtual() == symWithType.Sym.SymBaseVirtual()))
                    {
                        symWithType.Set(symT, objectAts);
                        return;
                    }
                }
                objectAts = objectAts.GetBaseClass();
            }

            DebugUtil.Assert(
                objectAts != null &&
                (symWithType.AggTypeSym == null || objectAts == symWithType.AggTypeSym));
        }

        //------------------------------------------------------------
        // FUNCBREC.FindBestMethod
        //
        /// <summary>
        /// Determine best method for overload resolution.
        /// Returns NULL if no best method,
        /// in which case two tying methods are returned for error reporting.
        /// </summary>
        /// <param name="list"></param>
        /// <param name="args"></param>
        /// <param name="methAmbig1"></param>
        /// <param name="methAmbig2"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private METHLIST FindBestMethod(
            METHLIST list,
            ArgInfos args,
            out METHLIST methAmbig1,
            out METHLIST methAmbig2)
        {
            methAmbig1 = null;
            methAmbig2 = null;
            DebugUtil.Assert(list != null && list.MethPropWithInst != null);

            // select the best method:

            // Effectively, we pick the best item from a set using a non-transitive ranking function
            // So, pick the first item (candidate) and compare against next (contender), if there is
            //     no next, goto phase 2
            // If first is better, move to next contender, if none proceed to phase 2
            // If second is better, make the contender the candidate and make the item following
            //     contender into the new contender, if there is none, goto phase 2
            // If neither, make contender+1 into candidate and contender+2 into contender, if possible,
            //     otherwise, if contender was last, return null, otherwise if new condidate is last,
            //     goto phase 2
            // Phase 2: compare all items before candidate to candidate
            //     If candidate always better, return it, otherwise return null

            // Record two method that are ambiguous for error reporting.
            METHLIST ambig1 = null;
            METHLIST ambig2 = null;

            METHLIST candidate = list;
            for (METHLIST contender = list.Next; contender != null; contender = contender.Next)
            {
                DebugUtil.Assert(candidate != contender);

                int result = WhichMethodIsBetter(candidate, contender, args);
                if (result > 0)
                {
                    continue;  // (meaning m1 is better...)
                }

                // so m2 is better, or a tie...
                if (result == 0)
                {
                    // in case of tie we don't want to bother with the contender who tied...
                    ambig1 = candidate;
                    ambig2 = contender;
                    contender = candidate = contender.Next;
                    if (candidate == null) goto AMBIG;
                }
                else
                {
                    candidate = contender;
                }
            }

            // Now, compare the candidate with items previous to it...
            for (METHLIST contender = list; contender != null; contender = contender.Next)
            {
                if (contender == candidate)
                {
                    // We hit our winner, so its good enough...
                    return candidate;
                }
                int result = WhichMethodIsBetter(contender, candidate, args);
                if (result < 0)
                { // meaning m2 is better
                    continue;
                }
                else if (result == 0)
                {
                    ambig1 = candidate;
                    ambig2 = contender;
                }
                break;
            }

        AMBIG:
            // an ambig call. Return two of the ambiguous set.
            if (ambig1 != null && ambig2 != null)
            {
                methAmbig1 = ambig1; methAmbig2 = ambig2;
            }
            else
            {
                // For some reason, we have an ambiguity but never had a tie.
                // This can easily happen in a circular graph of candidate methods.
                methAmbig1 = list; methAmbig2 = list.Next;
            }

            return null;
        }

        //------------------------------------------------------------
        // FUNCBREC.VerifyMethodArgs
        //
        /// <summary>
        /// <para>Convert arguments.</para>
        /// </summary>
        /// <param name="callExpr"></param>
        //------------------------------------------------------------
        private void VerifyMethodArgs(EXPR callExpr)
        {
            DebugUtil.Assert(callExpr.Kind == EXPRKIND.CALL || callExpr.Kind == EXPRKIND.PROP);

            //EXPR **argsPtr = callExpr.getArgsPtr();
            EXPR argsExpr1 = callExpr;
            EXPR argsExpr2;
            bool isCall = false;
            // argsExpr1 is the EXPR including *argsPtr.
            // argsExpr2 points the Expr which *argsPtr (or argsPtr[0]) points.

            if (callExpr.Kind == EXPRKIND.CALL)
            {
                argsExpr2 = (callExpr as EXPRCALL).ArgumentsExpr;
                isCall = true;
            }
            else // EXPRKIND.PROP
            {
                argsExpr2 = (callExpr as EXPRPROP).ArgumentsExpr;
                isCall = false;
            }

            SymWithType symWithType = callExpr.GetSymWithType();
            METHPROPSYM methPropSym = symWithType.Sym as METHPROPSYM;
            DebugUtil.Assert(methPropSym != null);

            TypeArray typeArgs =
                isCall ? (callExpr as EXPRCALL).MethodWithInst.TypeArguments : null;
            TypeArray paramArray = methPropSym.ParameterTypes;
            int paramCount = paramArray.Count;
            int iDst = 0;
            bool markTypeFromExternCall = methPropSym.IsFMETHSYM && methPropSym.AsFMETHSYM.IsExternal;

            if (methPropSym.IsFMETHSYM && methPropSym.AsFMETHSYM.IsVarargs)
            {
                paramCount--; // we don't care about the vararg sentinel
            }

            bool argListSeen = false;

            //EXPR ** indir = null;
            EXPR indir1 = null;
            EXPR indir2 = null;

            // If no argument, return or create a empty array for "params".
            //if (!*argsPtr)
            if (argsExpr2 == null)
            {
                if (methPropSym.IsParameterArray)
                {
                    goto FIXUPPARAMLIST;
                }
                return;
            }

            //while (true)
            while (argsExpr1 != null)
            {
                //----------------------------------------------------
                // this will splice the optional arguments into the list
                //----------------------------------------------------
                //if (argsPtr[0].kind == EXPRKIND.ARGLIST)
                if (argsExpr2.Kind == EXPRKIND.ARGLIST)
                {
                    if (argListSeen)
                    {
                        //Compiler.Error(argsPtr[0].tree, CSCERRID.ERR_IllegalArglist);
                        Compiler.Error(argsExpr2.TreeNode, CSCERRID.ERR_IllegalArglist);
                    }

                    //argsPtr[0] = argsPtr[0].AsBIN.p1;
                    if (argsExpr1.Kind == EXPRKIND.CALL)
                    {
                        (argsExpr1 as EXPRCALL).ArgumentsExpr = argsExpr2.AsBIN.Operand1;
                        argsExpr2 = (argsExpr1 as EXPRCALL).ArgumentsExpr;
                    }
                    else if (argsExpr1.Kind == EXPRKIND.LIST)
                    {
                        argsExpr1.AsBIN.Operand2 = argsExpr2.AsBIN.Operand1;
                        argsExpr2 = argsExpr1.AsBIN.Operand2;
                    }
                    else
                    {
                        DebugUtil.Assert(false, "VerifyMethodArgs (1)");
                    }

                    argListSeen = true;
                    //if (!argsPtr[0]) break;
                    if (argsExpr2 == null)
                    {
                        break;
                    }
                    continue;
                }

                //----------------------------------------------------
                // Not ARGLIST
                //----------------------------------------------------
                //if (argsPtr[0].kind == EXPRKIND.LIST)
                if (argsExpr2.Kind == EXPRKIND.LIST)
                {
                    //indir = &(argsPtr[0].AsBIN.p1);
                    indir1 = argsExpr2;
                    indir2 = (indir1 as EXPRBINOP).Operand1;
                }
                else
                {
                    //indir = argsPtr;
                    indir1 = argsExpr1;
                    indir2 = argsExpr2;
                }
                // indir2 points the actual arguments.

                //if (indir[0].type.IsPARAMMODSYM)
                if (indir2.TypeSym.IsPARAMMODSYM)
                {
                    callExpr.Flags |= EXPRFLAG.HASREFPARAM;
                    if (paramCount > 0) paramCount--;
                    if (markTypeFromExternCall)
                    {
                        //SetExternalRef(indir[0].type);
                        SetExternalRef(indir2.TypeSym);
                    }
                }
                else if (paramCount > 0)
                {
                    //if (paramCount == 1 && indir != argsPtr && methPropSym.isParamArray)
                    if (paramCount == 1 && indir1 != argsExpr1 && methPropSym.IsParameterArray)
                    {
                        // we arrived at the last formal, and we have more than one actual, so
                        // we need to put the rest in an array...
                        goto FIXUPPARAMLIST;
                    }

                    TYPESYM substDestType = Compiler.MainSymbolManager.SubstType(
                        paramArray[iDst],
                        symWithType.AggTypeSym,
                        typeArgs);

                    //EXPR rval = TryConvert(indir[0], substDestType);
                    EXPR rval = TryConvert(indir2, substDestType, 0);

                    if (rval == null)
                    {
                        // the last arg failed to fix up, so it must fixup into the array element
                        // (we will be passing a 1 element array...)
                        DebugUtil.Assert(methPropSym.IsParameterArray);
                        goto FIXUPPARAMLIST;
                    }
                    DebugUtil.Assert(rval != null);

                    //indir[0] = rval;
                    if (indir1 == callExpr)
                    {
                        if (callExpr.Kind == EXPRKIND.CALL)
                        {
                            (callExpr as EXPRCALL).ArgumentsExpr = rval;
                        }
                        else
                        {
                            (callExpr as EXPRPROP).ArgumentsExpr = rval;
                        }
                    }
                    else if (indir1 == argsExpr1)
                    {
                        (indir1 as EXPRBINOP).Operand2 = rval;
                    }
                    else
                    {
                        (indir1 as EXPRBINOP).Operand1 = rval;
                    }

                    paramCount--;
                }
                // note that destype might not be valid if we are in varargs, but then we won't ever use it...
                iDst++;

                //if (indir == argsPtr)
                if (indir1 == argsExpr1)
                {
                    if (paramCount > 0 && methPropSym.IsParameterArray)
                    {
                        // we run out of actuals, but we still have formals, so this is an empty array being passed
                        // into the last param...
                        indir1 = null;
                        goto FIXUPPARAMLIST;
                    }
                    break;
                }

                //argsPtr = &(argsPtr[0].AsBIN.p2);
                argsExpr1 = argsExpr2;
                argsExpr2 = argsExpr1.AsBIN.Operand2;
            } // while (true)

            return;

            //----------------------------------------------------
            // params
            //----------------------------------------------------
        FIXUPPARAMLIST:

            // we need to create an array and put it as the last arg...
            TYPESYM arrayType = Compiler.MainSymbolManager.SubstType(
                methPropSym.ParameterTypes[methPropSym.ParameterTypes.Count - 1],
                symWithType.AggTypeSym,
                typeArgs);
            TYPESYM elemType = (arrayType as ARRAYSYM).ElementTypeSym;

            // Use an EXPRKIND.ARRINIT even in the empty case so empty param arrays in attributes work.
            EXPRARRINIT arrayInit = NewExpr(null, EXPRKIND.ARRINIT, arrayType) as EXPRARRINIT;
            //arrayInit.DimSizes = &(arrayInit.dimSize);
            arrayInit.DimSizes = new List<int>();

            //--------------------------------------------------------
            // no params argument
            //--------------------------------------------------------
            //if (!argsPtr[0] || !indir)
            if (argsExpr2 == null || indir1 == null)
            {
                arrayInit.DimSizes.Add(0);
                arrayInit.ArgumentsExpr = null;
                //if (!argsPtr[0])
                if (argsExpr2 == null)
                {
                    //argsPtr[0] = arrayInit;
                    if (argsExpr1.Kind == EXPRKIND.LIST)
                    {
                        argsExpr1.AsBIN.Operand2 = arrayInit;
                    }
                    else if (isCall)  // argsExpr1.Kind == EXPRKIND.CALL)
                    {
                        (argsExpr1 as EXPRCALL).ArgumentsExpr = arrayInit;
                    }
                    else // argsExpr1.Kind == EXPRKIND.PROP
                    {
                        (argsExpr1 as EXPRPROP).ArgumentsExpr = arrayInit;
                    }
                }
                else
                {
                    //argsPtr[0] = newExprBinop(null, EXPRKIND.LIST, null, argsPtr[0], arrayInit);
                    if (argsExpr1.Kind == EXPRKIND.LIST)
                    {
                        argsExpr1.AsBIN.Operand2 =
                            NewExprBinop(null, EXPRKIND.LIST, null, argsExpr2, arrayInit);
                    }
                    else if (isCall)  // argsExpr1.Kind == EXPRKIND.CALL)
                    {
                        (argsExpr1 as EXPRCALL).ArgumentsExpr =
                            NewExprBinop(null, EXPRKIND.LIST, null, argsExpr2, arrayInit);
                    }
                    else // argsExpr1.Kind == EXPRKIND.PROP
                    {
                        (argsExpr1 as EXPRPROP).ArgumentsExpr =
                            NewExprBinop(null, EXPRKIND.LIST, null, argsExpr2, arrayInit);
                    }
                }
            }
            //--------------------------------------------------------
            // There are one or more argument of "params"
            //--------------------------------------------------------
            else // if (argsExpr2 == null || indir1 == null)
            {
                //EXPR ** lastArg = argsPtr;
                EXPR lastArgsExpr1 = argsExpr1;
                EXPR lastArgsExpr2 = argsExpr2;
                int count = 0;

                while (true)
                {
                    //if (argsPtr[0].kind == EXPRKIND.LIST)
                    if (argsExpr2.Kind == EXPRKIND.LIST)
                    {
                        //indir = &(argsPtr[0].AsBIN.p1);
                        indir1 = argsExpr2;
                        indir2 = indir1.AsBIN.Operand1;
                    }
                    else
                    {
                        //indir = argsPtr;
                        indir1 = argsExpr1;
                        indir2 = argsExpr2;
                    }

                    count++;
                    //EXPR  rval = TryConvert(indir[0], elemType);
                    EXPR rval = TryConvert(indir2, elemType, 0);
                    DebugUtil.Assert(rval != null);

                    //indir[0] = rval;
                    if (argsExpr2.Kind == EXPRKIND.LIST)
                    {
                        indir1.AsBIN.Operand1 = rval;
                    }
                    else
                    {
                        if (indir1.Kind == EXPRKIND.LIST)
                        {
                            indir1.AsBIN.Operand2 = rval;
                        }
                        else if (isCall)
                        {
                            (indir1 as EXPRCALL).ArgumentsExpr = rval;
                        }
                        else
                        {
                            (indir1 as EXPRPROP).ArgumentsExpr = rval;
                        }
                    }

                    if (indir1 == argsExpr1)
                    {
                        break;
                    }

                    //argsPtr = &(argsPtr[0].AsBIN.p2);
                    argsExpr1 = argsExpr2;
                    argsExpr2 = argsExpr1.AsBIN.Operand2;
                }

                arrayInit.DimSizes.Add(count);
                //arrayInit.ArgumentsExpr = lastArg[0];
                //lastArg[0] = arrayInit;
                arrayInit.ArgumentsExpr = lastArgsExpr2;
                if (lastArgsExpr1.Kind == EXPRKIND.LIST)
                {
                    lastArgsExpr1.AsBIN.Operand2 = arrayInit;
                }
                else if (isCall)    //lastArgsExpr1.Kind == EXPRKIND.CALL)
                {
                    (lastArgsExpr1 as EXPRCALL).ArgumentsExpr = arrayInit;
                }
                else
                {
                    (lastArgsExpr1 as EXPRPROP).ArgumentsExpr = arrayInit;
                }
            }
        }

        //--------------------------------------------------
        // FUNCBREC.WhichMethodIsBetter
        //
        /// <summary></summary>
        /// <param name="node1"></param>
        /// <param name="node2"></param>
        /// <param name="argInfos"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private int WhichMethodIsBetter(METHLIST node1, METHLIST node2, ArgInfos argInfos)
        {
            MethPropWithInst mpwi1 = node1.MethPropWithInst;
            MethPropWithInst mpwi2 = node2.MethPropWithInst;

            // 2016/04/23 hirano567@hotmail.co.jp
            if (mpwi1.MethSym == mpwi2.MethSym)
            {
                return +1;
            }

            // Substitutions should have already been done on these!
            TypeArray paramTypes1 = node1.ParameterTypes;
            TypeArray paramTypes2 = node2.ParameterTypes;
            DebugUtil.Assert(
                paramTypes1.Count == paramTypes2.Count &&
                argInfos.ArgumentCount == paramTypes1.Count);

            if (paramTypes1 == paramTypes2)
            {
                // Same signatures. If the have different lifting numbers, the smaller number wins.
                // Otherwise, if one is generic and the other isn't then the non-generic wins.
                // Otherwise, if one is expanded and the other isn't then the non-expanded wins.
                // Otherwise, if one has fewer modopts than the other then it wins.

                if (node1.LiftedTypeCount != node2.LiftedTypeCount)
                {
                    return node1.LiftedTypeCount < node2.LiftedTypeCount ? +1 : -1;
                }

                // Non-generic wins.
                if (mpwi1.TypeArguments.Count != 0)
                {
                    if (mpwi2.TypeArguments.Count == 0)
                    {
                        return -1;
                    }
                }
                else if (mpwi2.TypeArguments.Count != 0)
                {
                    return +1;
                }

                // Non-expanded wins
                if (node1.IsExpanded)
                {
                    if (!node2.IsExpanded)
                    {
                        return -1;
                    }
                }
                else if (node2.IsExpanded)
                {
                    return +1;
                }

                // See if one's parameter types (un-instantiated) are more specific.
                int nT = Compiler.MainSymbolManager.CompareTypes(
                    mpwi1.MethPropSym.ParameterTypes,
                    mpwi2.MethPropSym.ParameterTypes);
                if (nT != 0) return nT;

                // Fewer modopts wins.
                if (mpwi1.MethPropSym.CModifierCount != mpwi2.MethPropSym.CModifierCount)
                {
                    return mpwi1.MethPropSym.CModifierCount < mpwi2.MethPropSym.CModifierCount ? +1 : -1;
                }

                METHSYM meth1 = mpwi1.MethSym;
                METHSYM meth2 = mpwi2.MethSym;

                // (CS3) Extension methods loses.
                if (meth1 != null && meth2 != null)
                {
                    if (meth1.IsInstanceExtensionMethod)
                    {
                        if (!meth2.IsInstanceExtensionMethod)
                        {
                            return -1;
                        }
                    }
                    else if (meth2.IsInstanceExtensionMethod)
                    {
                        return +1;
                    }
                }

                // (CS3) Partial methods. the method with the implementation wins.
                if (meth1 != null && meth2 != null && meth1.IsPartialMethod)
                {
                    DebugUtil.Assert(meth2.IsPartialMethod);
                    if (meth1.HasNoBody && !meth2.HasNoBody)
                    {
                        return -1;
                    }
                    return +1;
                }

                // Bona-fide tie.
                return 0;
            }

            bool a2b, b2a;
            int better = 0;

            for (int i = 0; i < argInfos.ArgumentCount; i++)
            {
                TYPESYM arg = argInfos.ArgumentTypes[i];
                TYPESYM p1 = paramTypes1[i];
                TYPESYM p2 = paramTypes2[i];

                if (p1 == p2)
                {
                    continue;
                }

                // Check exact matches:
                if (arg == p1)
                {
                    goto BETM1;
                }
                if (arg == p2)
                {
                    goto BETM2;
                }

                a2b = CanConvert(p1, p2, 0);
                b2a = CanConvert(p2, p1, 0);

                if (!(a2b ^ b2a) &&
                    p1.IsPredefined() &&
                    p2.IsPredefined() &&
                    p1.GetPredefType() <= PREDEFTYPE.OBJECT && p2.GetPredefType() <= PREDEFTYPE.OBJECT)
                {
                    // See CLR section 7.4.1.3
                    int c = betterConversionTable[(int)p1.GetPredefType(), (int)p2.GetPredefType()];
                    if (c == 1)
                    {
                        goto BETM1;
                    }
                    else if (c == 2)
                    {
                        goto BETM2;
                    }
                }

                if (a2b && !b2a)
                {
                    goto BETM1;
                }
                if (b2a && !a2b)
                {
                    goto BETM2;
                }
                continue;

            BETM1:
                if (better < 0)
                {
                    return 0;
                }
                else
                {
                    better = 1;
                    continue;
                }

            BETM2:
                if (better > 0)
                {
                    return 0;
                }
                else
                {
                    better = -1;
                }
                continue;
            }

            return better;
        }

        //--------------------------------------------------
        // FUNCBREC.CreateNewScope
        //
        /// <summary>
        /// <para>Creates a new scope as a child of the current scope.
        /// and set this new scope to the current scope.</para>
        /// <para>You should always call this instead of creating the scope by hand
        /// as this correctly increments the scope nesting order...</para>
        /// </summary>
        //--------------------------------------------------
        private void CreateNewScope()
        {
            SCOPESYM newScopeSym = Compiler.LocalSymbolManager.CreateLocalSym(
                SYMKIND.SCOPESYM,
                null,
                this.currentScopeSym) as SCOPESYM;
            newScopeSym.NestingOrder = this.currentScopeSym.NestingOrder + 1;
            this.currentScopeSym = newScopeSym;
        }

        //--------------------------------------------------
        // FUNCBREC.CloseScope
        //
        /// <summary></summary>
        //--------------------------------------------------
        private void CloseScope()
        {
            this.currentScopeSym.TreeNode = this.lastNode;
            this.currentScopeSym = this.currentScopeSym.ParentSym as SCOPESYM;
        }

        //--------------------------------------------------
        // FUNCBREC.CompareSwitchLabels (static)
        //
        /// <summary></summary>
        /// <param name="e1"></param>
        /// <param name="e2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        static internal int CompareSwitchLabels(EXPRSWITCHLABEL e1, EXPRSWITCHLABEL e2)
        {
            // Eveything coming through here should have a type,
            // and should either be a null or an integral constant.
            DebugUtil.Assert(e1 != null && e2 != null);
            DebugUtil.Assert(
                e1.KeyExpr == null ||
                e1.KeyExpr.Kind == EXPRKIND.CONSTANT && e1.KeyExpr.TypeSym != null);
            DebugUtil.Assert(
                e2.KeyExpr == null ||
                e2.KeyExpr.Kind == EXPRKIND.CONSTANT && e2.KeyExpr.TypeSym != null);

            if (e1 == e2)
            {
                return 0;
            }

            // default goes last and null goes 2nd to last.
            if (e1.KeyExpr == null)
            {
                return (e2.KeyExpr != null ? 1 : 0);
            }
            if (e2.KeyExpr == null)
            {
                return -1;
            }

            if (e1.KeyExpr.IsNull())
            {
                return (e2.KeyExpr.IsNull() ? 0 : 1);
            }
            if (e2.KeyExpr.IsNull())
            {
                return -1;
            }

            long v1 = (e1.KeyExpr as EXPRCONSTANT).GetI64Value();
            long v2 = (e2.KeyExpr as EXPRCONSTANT).GetI64Value();

            if (v1 < v2)
            {
                return -1;
            }
            if (v2 < v1)
            {
                return 1;
            }
            return 0;
        }

        //--------------------------------------------------
        // FUNCBREC.AdjustMemberObj
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="symWithType"></param>
        /// <param name="expr"></param>
        /// <param name="isConstrained"></param>
        //--------------------------------------------------
        private void AdjustMemberObj(
            BASENODE treeNode,
            SymWithType symWithType,
            ref EXPR objectExpr,
            ref bool isConstrained)
        {
            // Assert that the type is present and is an instantiation of the member's parent.
            DebugUtil.Assert(
                symWithType != null &&
                symWithType.IsNotNull &&
                symWithType.AggTypeSym != null &&
                symWithType.AggTypeSym.GetAggregate() == symWithType.Sym.ParentSym as AGGSYM);

            isConstrained = false;
            bool isStatic;

            switch (symWithType.Sym.Kind)
            {
                case SYMKIND.MEMBVARSYM:
                    isStatic = symWithType.FieldSym.IsStatic;
                    break;

                case SYMKIND.EVENTSYM:
                    isStatic = symWithType.EventSym.IsStatic;
                    break;

                default:
                    isStatic = symWithType.MethPropSym.IsStatic;
                    break;
            }

            if (isStatic)
            {
                // Generate an error iff:
                // * There is an object.
                // * The object isn't implicit this.
                // * We're not in the weird E.M case
                //   where the object could be substituted with the type.

                if (objectExpr == null ||
                    ((objectExpr.Flags & EXPRFLAG.IMPLICITTHIS) != 0 &&
                        objectExpr.Kind == EXPRKIND.LOCAL))
                {
                    ;
                }
                else if ((objectExpr.Flags & EXPRFLAG.SAMENAMETYPE) != 0)
                {
                    ;
                }
                else
                {
                    // Static member cannot be accessed with an instance reference;
                    // qualify it with a type name instead
                    Compiler.ErrorRef(
                        treeNode,
                        CSCERRID.ERR_ObjectProhibited,
                        new ErrArgRef(symWithType));
                }
                objectExpr = null;
                return;
            }

            if (symWithType.Sym.IsMETHSYM && symWithType.MethSym.IsCtor)
            {
                return;
            }

            if (objectExpr == null)
            {
                if (this.evaluatingFieldInitializer &&
                    !this.methodSym.IsStatic &&
                    this.parentAggSym == symWithType.Sym.ParentSym)
                {
                    // A field initializer cannot reference
                    // the nonstatic field, method, or property
                    Compiler.ErrorRef(
                        treeNode,
                        CSCERRID.ERR_FieldInitRefNonstatic,
                        new ErrArgRef(symWithType));
                    // give better error message for common mistake
                }
                else if (
                    this.currentAnonymousMethodInfo != null &&
                    !this.methodSym.IsStatic &&
                    this.parentAggSym == symWithType.Sym.ParentSym &&
                    this.parentAggSym.IsStruct)
                {
                    // Anonymous methods inside structs
                    // cannot access instance members of 'this'.
                    Compiler.Error(treeNode, CSCERRID.ERR_ThisStructNotInAnonMeth);
                }
                else
                {
                    // An object reference is required
                    // for the nonstatic field, method, or property
                    Compiler.ErrorRef(
                        treeNode,
                        CSCERRID.ERR_ObjectRequired,
                        new ErrArgRef(symWithType));
                }
                return;
            }

            TYPESYM objectTypeSym = objectExpr.TypeSym;
            TYPESYM tmpTypeSym;

            if (objectTypeSym.IsNUBSYM)
            {
                tmpTypeSym = (objectTypeSym as NUBSYM).GetAggTypeSym();
                if (tmpTypeSym != null && tmpTypeSym != symWithType.AggTypeSym)
                {
                    objectTypeSym = tmpTypeSym;
                }
            }

            if (objectTypeSym.IsTYVARSYM || objectTypeSym.IsAGGTYPESYM)
            {
                AGGSYM calledAggSym = null;
                calledAggSym = symWithType.Sym.ParentSym as AGGSYM;
                DebugUtil.Assert(symWithType.AggTypeSym.GetAggregate() == calledAggSym);

                if (objectExpr.Kind == EXPRKIND.FIELD &&
                    !(objectExpr as EXPRFIELD).FieldWithType.FieldSym.IsAssigned &&
                    !symWithType.Sym.IsMEMBVARSYM &&
                    objectTypeSym.IsStructType() &&
                    !objectTypeSym.IsPredefined())
                {
                    (objectExpr as EXPRFIELD).FieldWithType.FieldSym.IsAssigned = true;
                }

                if (objectTypeSym.IsTYVARSYM ||
                    objectTypeSym.IsStructType() &&
                    symWithType.AggTypeSym.IsReferenceType() &&
                    symWithType.Sym.IsVirtual())
                {
                    // For calls on type parameters or virtual calls on struct types (not enums),
                    // use the constrained prefix.
                    isConstrained = true;
                }

                EXPR newExpr = TryConvert(objectExpr, symWithType.AggTypeSym, ConvertTypeEnum.NOUDC);

                // This check ensures that we do not bind to methods in an outerclass
                // which are visible, but whose this pointer is of an incorrect type...
                // ... also handles case of calling an object method on a RefAny value.
                // WE don't give a great message for this, but it'll do.
                if (newExpr == null)
                {
                    if (!objectExpr.TypeSym.IsSpecialByRefType())
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_WrongNestedThis,
                            new ErrArg(symWithType.AggTypeSym), new ErrArg(objectExpr.TypeSym));
                    }
                    else
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_NoImplicitConv,
                            new ErrArg(objectExpr.TypeSym), new ErrArg(symWithType.AggTypeSym));
                    }
                }
                objectExpr = newExpr;
            }
        }

        //--------------------------------------------------
        // FUNCBREC.ObjectIsLvalue
        //
        /// <summary>
        /// this determines whether the expression as an object of a prop or field is an lvalue
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool ObjectIsLvalue(EXPR expr)
        {
            return (
                // statics are always lvalues
                expr == null ||

                // the this pointer's fields or props are lvalues
                IsThisPointer(expr) ||

                // things marked as lvalues have props/fields which are lvalues, with one exception:
                // props of structs do not have fields/structs as lvalues
                ((expr.Flags & EXPRFLAG.LVALUE) != 0 && (expr.Kind != EXPRKIND.PROP)) ||

                // non-struct types are lvalues (such as non-struct method returns)
                !expr.TypeSym.IsStructOrEnum()
                );
        }

        //--------------------------------------------------
        // FUNCBREC.HasCorrectType
        //
        //--------------------------------------------------
        //    bool __fastcall HasCorrectType(SYM ** sym, symbmask_t mask);

        //--------------------------------------------------
        // FUNCBREC.BindPatternToMethod
        //
        /// <summary>
        /// Searches for a valid method to match either the GetEnumerator or Dispose patterns
        /// This will not report errors, but will give warnings if the pattern is not matched.
        /// </summary>
        /// <param name="treeNode">the parse-tree for error reporting</param>
        /// <param name="predefName">id to match (either PN_GETENUMERATOR or PN_DISPOSE</param>
        /// <param name="typeSym">the type to look in</param>
        /// <param name="objectExpr">the object</param>
        /// <param name="returnTypeSym">the return type to match (may be NULL)</param>
        /// <param name="patternStrId">a string resource id for the pattern name
        /// (for error messages)</param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRCALL BindPatternToMethod(
            BASENODE treeNode,
            PREDEFNAME predefName,
            TYPESYM typeSym,
            EXPR objectExpr,
            TYPESYM returnTypeSym,
            ResNo patternResNo)
        {
            DebugUtil.Assert(typeSym != null);
            string name = compiler.NameManager.GetPredefinedName(predefName);

            // First check if the object has a public dispose method,
            // if so use the method directly instead of casting to an interface...
            MemberLookup mem = new MemberLookup();
            if (!typeSym.IsAGGTYPESYM && !typeSym.IsTYVARSYM)
            {
                return null;
            }

            if (!mem.Lookup(
                    compiler,
                    typeSym,
                    objectExpr,
                    this.parentDeclSym,
                    name,
                    0,
                    MemLookFlagsEnum.UserCallable) ||
                    !mem.FirstSym.IsMETHSYM)
            {
                if (mem.FirstSym != null)
                {
                    compiler.Error(
                        treeNode,
                        CSCERRID.WRN_PatternBadSignature,
                        new ErrArg(typeSym),
                        new ErrArgResNo(patternResNo),
                        new ErrArgRef(mem.FirstSym));
                }
                return null;
            }
            mem.ReportWarnings(treeNode);

            EXPRMEMGRP grpExpr = NewExprMemGrp(treeNode, null, mem);
            DebugUtil.Assert(grpExpr.SymKind == SYMKIND.METHSYM);	// must be a method

            MethWithInst ambigMwi = new MethWithInst();
            MethWithInst resMwi = new MethWithInst();

            if (!BindGrpToParams(
                resMwi,
                treeNode,
                grpExpr,
                BSYMMGR.EmptyTypeArray,
                false,
                ambigMwi,
                null))
            {
                compiler.Error(
                    treeNode,
                    CSCERRID.WRN_PatternBadSignature,
                    new ErrArg(typeSym),
                    new ErrArgResNo(patternResNo),
                    new ErrArgRef(mem.FirstSym));
                return null;
            }
            if (ambigMwi != null && ambigMwi.IsNotNull)
            {
                compiler.Error(
                    treeNode,
                    CSCERRID.WRN_PatternIsAmbiguous,
                    new ErrArg(typeSym),
                    new ErrArgResNo(patternResNo),
                    new ErrArgRef(resMwi),
                    new ErrArgRef(ambigMwi));
                return null;
            }
            if (returnTypeSym != null &&
                resMwi.MethSym.ReturnTypeSym != returnTypeSym)
            {
                compiler.Error(
                    treeNode,
                    CSCERRID.WRN_PatternBadSignature,
                    new ErrArg(typeSym),
                    new ErrArgResNo(patternResNo),
                    new ErrArgRef(resMwi));
                return null;
            }

            METHSYM methodSym = resMwi.MethSym;
            DebugUtil.Assert(
                methodSym.ParameterTypes.Count == 0 &&
                methodSym.TypeVariables.Count == 0);

            if (methodSym.IsStatic || methodSym.Access != ACCESS.PUBLIC)
            {
                compiler.Error(
                    treeNode,
                    CSCERRID.WRN_PatternStaticOrInaccessible,
                    new ErrArg(typeSym),
                    new ErrArgResNo(patternResNo),
                    new ErrArgRef(resMwi));
                return null;
            }

            EXPR resCallExpr = BindToMethod(
                treeNode,
                grpExpr.ObjectExpr,
                resMwi,
                null,
                MemLookFlagsEnum.None);

            // if the method had conditional symbols on it,
            // then it will get turned into a no-op and a method
            // that does not exist should not meet the pattern.
            // Thus, we need the check to verify this is actually an EXPRCALL
            if (resCallExpr == null || !resCallExpr.IsOK || resCallExpr.Kind != EXPRKIND.CALL)
            {
                return null;
            }

            return resCallExpr as EXPRCALL;
        }

        //--------------------------------------------------
        // FUNCBREC.isConstantInRange
        //
        /// <summary>
        /// Check to see if an integral constant is within range of a integral destination type.
        /// </summary>
        /// <param name="srcConstExpr"></param>
        /// <param name="destTypeSym"></param>
        /// <param name="realsOk"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool IsConstantInRange(
            EXPRCONSTANT srcConstExpr,
            TYPESYM destTypeSym,
            bool realsOk) // = false
        {
            FUNDTYPE ftSrc = srcConstExpr.TypeSym.FundamentalType();
            FUNDTYPE ftDest = destTypeSym.FundamentalType();

            if (ftSrc > FUNDTYPE.LASTINTEGRAL || ftDest > FUNDTYPE.LASTINTEGRAL)
            {
                if (!realsOk)
                {
                    return false;
                }
                else if (ftSrc > FUNDTYPE.LASTNUMERIC || ftDest > FUNDTYPE.LASTNUMERIC)
                {
                    return false;
                }
            }

            // if converting to a float type, this always suceeds...
            if (ftDest > FUNDTYPE.LASTINTEGRAL)
            {
                return true;
            }

            // if converting from float to an integral type, we need to check whether it fits
            if (ftSrc > FUNDTYPE.LASTINTEGRAL)
            {
                double dvalue = (srcConstExpr as EXPRCONSTANT).ConstVal.GetDouble();

                if (!Util.IsFinite(dvalue))
                {
                    return false;
                }

                switch (ftDest)
                {
                    case FUNDTYPE.I1:
                        if (dvalue > -0x81 && dvalue < 0x80) return true;
                        break;

                    case FUNDTYPE.I2:
                        if (dvalue > -0x8001 && dvalue < 0x8000) return true;
                        break;

                    case FUNDTYPE.I4:
                        if (dvalue > (long)(-0x80000001) && dvalue < (long)(0x80000000)) return true;
                        break;

                    case FUNDTYPE.I8:
                        // this code is shared by fjitdef.h
                        if (dvalue < (long)(-0x7000000000000000))
                        {
                            double tmp = dvalue - (long)(-0x7000000000000000);
                            if (tmp > (long)(-0x7000000000000000) &&
                                (long)tmp > (long)(-0x1000000000000001))
                            {
                                return true;
                            }
                        }
                        else
                        {
                            if (dvalue > (long)(0x7000000000000000))
                            {
                                double tmp = dvalue - (long)(0x7000000000000000);
                                if (tmp < (long)(0x7000000000000000) &&
                                    (long)tmp < (long)(0x1000000000000000))
                                {
                                    return true;
                                }
                            }
                            else
                            {
                                return true;
                            }
                        }
                        break;

                    case FUNDTYPE.U1:
                        if (dvalue > -1 && dvalue < 0x800) return true;
                        break;

                    case FUNDTYPE.U2:
                        if (dvalue > -1 && dvalue < 0x80000) return true;
                        break;

                    case FUNDTYPE.U4:
                        if (dvalue > -1 && dvalue < (long)(0x800000000)) return true;
                        break;

                    case FUNDTYPE.U8:
                        // this code is shared by fjitdef.h
                        if (dvalue < (ulong)(0xF000000000000000))
                        {
                            if (dvalue > -1)
                            {
                                return true;
                            }
                        }
                        else
                        {
                            double tmp = dvalue - (ulong)(0xF000000000000000);
                            if (tmp < (long)(0x7000000000000000) &&
                                (long)tmp < (long)(0x1000000000000000))
                            {
                                return true;
                            }
                        }
                        break;
                    default: break;
                }
                return false;
            }

            long value = (srcConstExpr as EXPRCONSTANT).GetI64Value();

            // U8 src is unsigned, so deal with values > MAX_LONG here.
            if (ftSrc == FUNDTYPE.U8)
            {
                if (ftDest == FUNDTYPE.U8)
                {
                    return true;
                }
                if (value < 0)  // actually > MAX_LONG.
                {
                    return false;
                }
            }

            switch (ftDest)
            {
                case FUNDTYPE.I1:
                    if (value >= -128 && value <= 127) return true;
                    break;

                case FUNDTYPE.I2:
                    if (value >= -0x8000 && value <= 0x7fff) return true;
                    break;

                case FUNDTYPE.I4:
                    if (value >= (long)(-0x80000000) && value <= (long)(0x7fffffff)) return true;
                    break;

                case FUNDTYPE.I8:
                    return true;

                case FUNDTYPE.U1:
                    if (value >= 0 && value <= 0xff) return true;
                    break;

                case FUNDTYPE.U2:
                    if (value >= 0 && value <= 0xffff) return true;
                    break;

                case FUNDTYPE.U4:
                    if (value >= 0 && value <= (long)(0xffffffff)) return true;
                    break;

                case FUNDTYPE.U8:
                    if (value >= 0) return true;
                    break;

                default:
                    break;
            }

            return false;
        }

        //--------------------------------------------------
        // FUNCBREC.BindConstantCast
        //
        /// <summary>
        /// Fold a constant cast. Returns true if the constant could be folded.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="srcExpr"></param>
        /// <param name="destTypeSym"></param>
        /// <param name="destExpr"></param>
        /// <param name="checkFailure"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool BindConstantCast(
            BASENODE treeNode,
            EXPR srcExpr,
            TYPESYM destTypeSym,
            ref EXPR destExpr,
            ref bool checkFailure)
        {
            DebugUtil.Assert(srcExpr != null && destTypeSym != null);

            long longValue = 0;
            double doubleValue = 0;
            FUNDTYPE ftSrc = srcExpr.TypeSym.FundamentalType();
            FUNDTYPE ftDest = destTypeSym.FundamentalType();
            bool isSrcIntegral = (ftSrc <= FUNDTYPE.LASTINTEGRAL);

            EXPRCONSTANT srcConstExpr = srcExpr.GetConst() as EXPRCONSTANT;
            DebugUtil.Assert(srcConstExpr != null);
            bool explicitConversion = checkFailure;
            checkFailure = false;

            if (ftSrc == FUNDTYPE.STRUCT || ftDest == FUNDTYPE.STRUCT)
            {
                // Do constant folding involving decimal constants.
                EXPR expr = BindDecimalConstCast(treeNode, destTypeSym, srcExpr.TypeSym, srcConstExpr);

                if (expr == null)
                {
                    return false;
                }
                destExpr = AddSideEffects(treeNode, expr, srcExpr, true, false);
                return true;
            }

            if (explicitConversion &&
                this.CheckedContext.IsConstant &&
                !IsConstantInRange(srcConstExpr, destTypeSym, true))
            {
                checkFailure = true;
                return false;
            }

            //if (!destExpr) return true;

            // Get the source constant value into longValue or doubleValue.
            if (isSrcIntegral)
            {
                longValue = srcConstExpr.GetI64Value();
            }
            else
            {
                doubleValue = srcConstExpr.ConstVal.GetDouble();
            }

            // Convert constant to the destination type, truncating if necessary.
            // longValue or doubleValue contains the result of the conversion.

            // Create a new constant with the value in "longValue" or "doubleValue".
            CONSTVAL tempConstVal = new CONSTVAL();
            
            switch (ftDest)
            {
                case FUNDTYPE.I1:
                    if (!isSrcIntegral)
                    {
                        longValue = (long)doubleValue;
                    }
                    //longValue = (sbyte)(longValue & 0xFF);
                    tempConstVal.SetSByte((sbyte)(longValue & 0xFF));
                    break;

                case FUNDTYPE.I2:
                    if (!isSrcIntegral)
                    {
                        longValue = (long)doubleValue;
                    }
                    //longValue = (short)(longValue & 0xFFFF);
                    tempConstVal.SetShort((short)(longValue & 0xFFFF));
                    break;

                case FUNDTYPE.I4:
                    if (!isSrcIntegral)
                    {
                        longValue = (long)doubleValue;
                    }
                    //longValue = (int)(longValue & 0xFFFFFFFF);
                    tempConstVal.SetInt((int)(longValue & 0xFFFFFFFF));
                    break;

                case FUNDTYPE.I8:
                    if (!isSrcIntegral)
                    {
                        longValue = (long)doubleValue;
                    }
                    tempConstVal.SetLong(longValue);
                    break;

                case FUNDTYPE.U1:
                    if (!isSrcIntegral)
                    {
                        longValue = (long)doubleValue;
                    }
                    //longValue = (byte)(longValue & 0xFF);
                    tempConstVal.SetByte((byte)(longValue & 0xFF));
                    break;

                case FUNDTYPE.U2:
                    if (!isSrcIntegral)
                    {
                        longValue = (long)doubleValue;
                    }
                    //longValue = (ushort)(longValue & 0xFFFF);
                    tempConstVal.SetUShort((ushort)(longValue & 0xFFFF));
                    break;

                case FUNDTYPE.U4:
                    if (!isSrcIntegral)
                    {
                        longValue = (long)doubleValue;
                    }
                    //longValue = (uint)(longValue & 0xFFFFFFFF);
                    tempConstVal.SetUInt((uint)(longValue & 0xFFFFFFFF));
                    break;

                case FUNDTYPE.U8:
                    if (!isSrcIntegral)
                    {
                        longValue = (long)((ulong)doubleValue);
                        // code below stolen from jit...
                        const double two63 = 2147483648.0 * 4294967296.0;
                        // 2147483648.0 * 4294967296.0 = 0x80000000 * 0x100000000 = 2^31 * 2^32
                        if (doubleValue < two63)
                        {
                            longValue = (long)doubleValue;
                        }
                        else
                        {
                            longValue = unchecked(((long)(doubleValue - two63)) + (long)(0x8000000000000000));
                        }
                    }
                    tempConstVal.SetULong((ulong)longValue);
                    break;

                case FUNDTYPE.R4:
                case FUNDTYPE.R8:
                    if (isSrcIntegral)
                    {
                        if (ftSrc == FUNDTYPE.U8)
                        {
                            doubleValue = (double)(ulong)longValue;
                        }
                        else
                        {
                            doubleValue = (double)longValue;
                        }
                    }
                    //if (ftDest == FUNDTYPE.R4)
                    //{
                    //    // Force to R4 precision/range.
                    //    doubleValue = (double)((float)doubleValue);
                    //}
                    if (ftDest == FUNDTYPE.R4)
                    {
                        tempConstVal.SetFloat((float)doubleValue);
                    }
                    else
                    {
                        tempConstVal.SetDouble(doubleValue);
                    }
                    break;

                default:
                    DebugUtil.Assert(false);
                    break;
            }

            //if (ftDest == FUNDTYPE.U4)
            //{
            //    tempConstVal.SetUInt((uint)longValue);
            //}
            //else if (ftDest <= FUNDTYPE.LASTNONLONG)
            //{
            //    tempConstVal.SetInt((int)longValue);
            //}
            //else if (ftDest <= FUNDTYPE.LASTINTEGRAL)
            //{
            //    tempConstVal.SetLong(longValue);
            //}
            //else
            //{
            //    tempConstVal.SetDouble(doubleValue);
            //}

            EXPRCONSTANT tempExpr = NewExprConstant(treeNode, destTypeSym, tempConstVal);
            destExpr = AddSideEffects(treeNode, tempExpr, srcExpr, true, false);
            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.BindSimpleCast
        //
        /// <summary>
        /// <para>Create a cast node with the given expression flags.
        /// Always returns true. If pexprDest is NULL, just return true.</para>
        /// <para>If destExpr does not exist, not need to call this method.</para>
        /// </summary>
        //--------------------------------------------------
        private bool BindSimpleCast(
            BASENODE treeNode,
            EXPR srcExpr,
            TYPESYM destTypeSym,
            ref EXPR destExpr,
            EXPRFLAG exprFlags) // = 0
        {
            //if (!pexprDest)
            //    return true;
            // This statement above is in sscli. This means that if no need to convert, return true.
            // Alternatively, we process in the following way.
            if (srcExpr == null)
            {
                return true;
            }

            // If the source is a constant, and cast is really simple (no change in fundemental
            // type, no flags), then create a new constant node with the new type instead of
            // creating a cast node. This allows compile-time constants to be easily recognized.

            EXPR constExpr = srcExpr.GetConst();

            if (constExpr != null &&
                exprFlags == 0 &&
                srcExpr.TypeSym.FundamentalType() == destTypeSym.FundamentalType() &&
                (!srcExpr.TypeSym.IsPredefType(PREDEFTYPE.STRING) || (constExpr as EXPRCONSTANT).GetStringValue() == null))
            {
                EXPRCONSTANT expr = NewExprConstant(treeNode, destTypeSym, (constExpr as EXPRCONSTANT).ConstVal);
                destExpr = AddSideEffects(treeNode, expr, srcExpr, true, false);
                return true;
            }

            // Just alloc a new node and fill it in.
            EXPRCAST castExpr = NewExpr(treeNode, EXPRKIND.CAST, destTypeSym) as EXPRCAST;
            castExpr.Operand = srcExpr;
            castExpr.Flags = exprFlags;
            if (this.CheckedContext.IsNormal)
            {
                castExpr.Flags |= EXPRFLAG.CHECKOVERFLOW;
            }

            destExpr = castExpr;
            DebugUtil.Assert(castExpr.Operand != null);
            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.BindUserDefinedConversion
        //
        /// <summary>
        /// <para>Binds a user-defined conversion.</para>
        /// <para>The parameters to this procedure are the same as bindImplicitConversion,
        /// except the last: implicitOnly - only consider implicit conversions.</para>
        /// <para>This is a helper routine for bindImplicitConversion and bindExplicitConversion.</para>
        /// </summary>
        /// <remarks>
        /// It's non trivial to get this right in the presence of generics. e.g.
        ///
        /// class D$lt;B,C$gt; {
        /// static implicit operator B (D$lt;B,C$gt; x) { ... }
        /// }
        ///
        /// class E$lt;A$gt; : D$lt;List$lt;A$gt;, A$gt; { }
        ///
        /// E$lt;int$gt; x;
        /// List$lt;int$gt; y = x;
        ///
        /// The locals below would have the following values:
        ///
        /// typeList-$gt;sym: D$lt;List$lt;A$gt;, A$gt;
        /// typeCur: E$lt;int$gt;
        /// typeConv = subst(typeList-$gt;sym, typeCur)
        /// = subst(D$lt;List$lt;!0$gt;, !0$gt;, $lt;int$gt;) = D$lt;List$lt;int$gt;, int$gt;
        ///
        /// retType: B
        /// typeTo = subst(retType, typeConv)
        /// = subst(!0, $lt;List$lt;int$gt;, int$gt;) = List$lt;int$gt;
        /// params-$gt;Item(0): D$lt;B,C$gt;
        /// typeFrom = subst(params-$gt;Item(0), typeConv)
        /// = subst(D$lt;!0,!1$gt;, $lt;List$lt;int$gt;, int$gt;)
        /// = D$lt;List$lt;int$gt;, int$gt; = typeConv
        ///
        /// REVIEW ShonK: Consider caching the results of this. Performing this over and over again
        /// could be a big time waster.
        ///
        /// For lifting over nullable:
        /// * Look in the most base types for the conversions (not in System.Nullable).
        /// * We only lift if both the source type and destination type are nullable and the input
        /// or output of the conversion is not a nullable.
        /// * When we lift we count the number of types (0, 1, 2) that need to be lifted.
        /// A conversion that needs fewer lifts is better than one that requires more (if the lifted
        /// forms have identical signatures).
        /// </remarks>
        /// 
        /// <param name="treeNode"></param>
        /// <param name="srcExpr"></param>
        /// <param name="srcTypeSym"></param>
        /// <param name="dstTypeSym"></param>
        /// <param name="dstExpr"></param>
        /// <param name="implicitOnly"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool BindUserDefinedConversion(
            BASENODE treeNode,
            EXPR srcExpr,
            TYPESYM srcTypeSym,
            TYPESYM dstTypeSym,
            ref EXPR dstExpr, //EXPR ** dstExpr,
            bool implicitOnly)
        {
            DebugUtil.Assert(srcExpr == null || srcExpr.TypeSym == srcTypeSym);

            // If either type is an interface we should never employ a UD conversion.
            if (srcTypeSym == null ||
                dstTypeSym == null ||
                srcTypeSym.IsInterfaceType() ||
                dstTypeSym.IsInterfaceType())
            {
                return false;
            }

            TYPESYM srcBaseTypeSym = srcTypeSym.StripNubs();
            TYPESYM dstBaseTypeSym = dstTypeSym.StripNubs();

            bool isSrcLifted = (srcBaseTypeSym != srcTypeSym);
            bool isDstLifted = (dstBaseTypeSym != dstTypeSym);
            bool dstHasNull = (isDstLifted || dstTypeSym.IsReferenceType() || dstTypeSym.IsPTRSYM);

            //AGGTYPESYM * atsArray[2];
            AGGTYPESYM[] atsArray = { null, null };
            int atsCount = 0;

            // This will be true if it must be the case that either the operator is implicit
            // or the from-type of the operator must be the same as the source type.
            // This is true when the source type is a type variable.
            bool isImplicitOrExactSrc = implicitOnly;

            // This flag will be true if we should ignore the IntPtr/UIntPtr . int/uint conversion
            // in favor of the IntPtr/UIntPtr . long/ulong conversion.
            bool isIntPtrOverride2 = false;

            // Get the list of operators from the source.
            if (srcBaseTypeSym.IsTYVARSYM)
            {
                AGGTYPESYM baseAggTypeSym = (srcBaseTypeSym as TYVARSYM).BaseClassSym;
                if (baseAggTypeSym.GetAggregate().HasConversion)
                {
                    atsArray[atsCount++] = baseAggTypeSym;
                }

                // If an implicit conversion exists from the class bound to dstTypeSym, then
                // an implicit conversion exists from srcTypeSym to dstTypeSym. An explicit from
                // the class bound to dstTypeSym doesn't buy us anything.
                // We can still use an explicit conversion that has this type variable (or
                // nullable of it) as its from-type.
                isImplicitOrExactSrc = true;
            }
            else if (srcBaseTypeSym.IsAGGTYPESYM && srcBaseTypeSym.GetAggregate().HasConversion)
            {
                atsArray[atsCount++] = srcBaseTypeSym as AGGTYPESYM;
                isIntPtrOverride2 = (
                    srcBaseTypeSym.IsPredefType(PREDEFTYPE.INTPTR) ||
                    srcBaseTypeSym.IsPredefType(PREDEFTYPE.UINTPTR));
            }

            // Get the list of operators from the destination.
            if (dstBaseTypeSym.IsTYVARSYM)
            {
                // If an explicit conversion exists from srcTypeSym to the class bound, then
                // an explicit conversion exists from srcTypeSym to dstTypeSym. An implicit is no better
                // than an explicit.
                AGGTYPESYM baseAggTypeSym;
                if (!implicitOnly &&
                    (baseAggTypeSym = (dstBaseTypeSym as TYVARSYM).BaseClassSym).GetAggregate().HasConversion)
                {
                    atsArray[atsCount++] = baseAggTypeSym;
                }
            }
            else if (dstBaseTypeSym.IsAGGTYPESYM)
            {
                if (dstBaseTypeSym.GetAggregate().HasConversion)
                {
                    atsArray[atsCount++] = dstBaseTypeSym as AGGTYPESYM;
                }
                if (isIntPtrOverride2 &&
                    !dstBaseTypeSym.IsPredefType(PREDEFTYPE.LONG) &&
                    !dstBaseTypeSym.IsPredefType(PREDEFTYPE.ULONG))
                {
                    isIntPtrOverride2 = false;
                }
            }
            else
            {
                isIntPtrOverride2 = false;
            }

            // If there are no user defined conversions, we're done.
            if (atsCount == 0)
            {
                return false;
            }

            //UdConvInfo rguciRaw[8];
            //UdConvInfo * prguci = rguciRaw;
            //int cuciMax = lengthof(rguciRaw);
            List<UdConvInfo> udConvInfoList = new List<UdConvInfo>();
            //int cuci = 0;

            TYPESYM srcBestTypeSym = null;
            TYPESYM dstBestTypeSym = null;
            bool isBestSrcExact = false;
            bool isBestDstExact = false;
            int iuciBestSrc = -1;
            int iuciBestDst = -1;

            TYPESYM fromTypeSym;
            TYPESYM toTypeSym;

            // In the first pass if we find types that are non-comparable, keep one of the types and keep going.
            // In the second pass, we verify that the types we ended up with are indeed minimal and
            // find the one valid conversion.

            for (int iats = 0; iats < atsCount; iats++)
            {
                for (AGGTYPESYM currentAts = atsArray[iats];
                    currentAts != null && currentAts.GetAggregate().HasConversion;
                    currentAts = currentAts.GetBaseClass())
                {
                    AGGSYM currentAggSym = currentAts.GetAggregate();

                    // We need to ship with an RTM bug that allows non-standard conversions with these guys.
                    bool isIntPtrStandard = (
                        currentAggSym.IsPredefinedType &&
                        (currentAggSym.PredefinedTypeID == PREDEFTYPE.INTPTR ||
                        currentAggSym.PredefinedTypeID == PREDEFTYPE.UINTPTR ||
                        currentAggSym.PredefinedTypeID == PREDEFTYPE.DECIMAL));

                    for (METHSYM currentConvSym = currentAggSym.FirstConversionMethSym;
                        currentConvSym != null;
                        currentConvSym = currentConvSym.NextConvertMethSym)
                    {
                        DebugUtil.Assert(currentConvSym.ParameterTypes.Count == 1);
                        DebugUtil.Assert(currentConvSym.ClassSym == currentAggSym);

                        if (implicitOnly && !currentConvSym.IsImplicit)
                        {
                            continue;
                        }
                        if (Compiler.CheckBogus(currentConvSym))
                        {
                            continue;
                        }

                        // Get the substituted src and dst types.
                        fromTypeSym = Compiler.MainSymbolManager.SubstType(
                            currentConvSym.ParameterTypes[0],
                            currentAts,
                            null);
                        toTypeSym = Compiler.MainSymbolManager.SubstType(
                            currentConvSym.ReturnTypeSym,
                            currentAts,
                            null);

                        bool needImplicit = implicitOnly;

                        // If isImplicitOrExactSrc is set then it must be the case that either the conversion
                        // is implicit or the from-type must be the src type (modulo nullables).

                        if (isImplicitOrExactSrc && !needImplicit && fromTypeSym.StripNubs() != srcBaseTypeSym)
                        {
                            if (!currentConvSym.IsImplicit)
                            {
                                continue;
                            }
                            needImplicit = true;
                        }

                        FUNDTYPE fromFundType;
                        FUNDTYPE toFundType;

                        if ((toFundType = toTypeSym.FundamentalType()) <= FUNDTYPE.LASTNUMERIC &&
                            toFundType > FUNDTYPE.NONE &&
                            (fromFundType = fromTypeSym.FundamentalType()) <= FUNDTYPE.LASTNUMERIC &&
                            fromFundType > FUNDTYPE.NONE)
                        {
                            continue;
                        }

                        // Ignore the IntPtr/UIntPtr . int/uint conversion in favor of
                        // the IntPtr/UIntPtr . long/ulong conversion.
                        if (isIntPtrOverride2 &&
                            (toTypeSym.IsPredefType(PREDEFTYPE.INT) || toTypeSym.IsPredefType(PREDEFTYPE.UINT)))
                        {
                            continue;
                        }

                        // Lift the conversion if needed.
                        if ((isSrcLifted & (dstHasNull | !needImplicit)) && fromTypeSym.IsNonNullableValueType())
                        {
                            fromTypeSym = Compiler.MainSymbolManager.GetNubType(fromTypeSym);
                        }
                        if (isDstLifted && toTypeSym.IsNonNullableValueType())
                        {
                            toTypeSym = Compiler.MainSymbolManager.GetNubType(toTypeSym);
                        }

                        // Check for applicability.
                        bool isFromImplicit = (srcExpr != null ?
                            CanConvert(srcExpr, fromTypeSym, ConvertTypeEnum.STANDARDANDNOUDC) :
                            CanConvert(srcTypeSym, fromTypeSym, ConvertTypeEnum.STANDARDANDNOUDC));

                        if (!isFromImplicit
                            &&
                            (   needImplicit
                                ||
                                !CanConvert(fromTypeSym, srcTypeSym, ConvertTypeEnum.STANDARDANDNOUDC)
                                &&
                                    // We allow IntPtr and UIntPtr to use non-standard explicit casts
                                    // as long as they don't involve pointer types.
                                    // This is because the framework uses it and RTM allowed it.
                                (   !isIntPtrStandard ||
                                    srcTypeSym.IsPTRSYM ||
                                    fromTypeSym.IsPTRSYM ||
                                    !CanCast(srcTypeSym, fromTypeSym, ConvertTypeEnum.NOUDC))
                            )
                        )
                        {
                            continue;
                        }

                        bool isToImplicit = CanConvert(toTypeSym, dstTypeSym, ConvertTypeEnum.STANDARDANDNOUDC);

                        if (!isToImplicit
                            &&
                            (   needImplicit
                                ||
                                !CanConvert(dstTypeSym, toTypeSym, ConvertTypeEnum.STANDARDANDNOUDC)
                                &&
                                    // We allow IntPtr and UIntPtr to use non-standard explicit casts
                                    // as long as they don't involve pointer types.
                                    // This is because the framework uses it and RTM allowed it.
                                (   !isIntPtrStandard ||
                                    dstTypeSym.IsPTRSYM ||
                                    toTypeSym.IsPTRSYM ||
                                    !CanCast(toTypeSym, dstTypeSym, ConvertTypeEnum.NOUDC))
                            )
                        )
                        {
                            continue;
                        }

                        // The conversion is applicable so it affects the best types.
                        //if (cuci >= cuciMax)
                        //{
                        //    DebugUtil.Assert(cuci == cuciMax);
                        //    UdConvInfo * prguciNew = STACK_ALLOC(UdConvInfo, cuciMax + cuciMax);
                        //    memcpy(prguciNew, prguci, cuci * sizeof(UdConvInfo));
                        //    cuciMax += cuciMax;
                        //    prguci = prguciNew;
                        //}
                        //DebugUtil.Assert(cuci < cuciMax);
                        //int iuciCur = cuci++;
                        int iuciCur = udConvInfoList.Count;

                        UdConvInfo uci = new UdConvInfo();
                        uci.MethWithType.Set(currentConvSym, currentAts);
                        uci.IsSrcImplicit = isFromImplicit;
                        uci.IsDstImplicit = isToImplicit;
                        udConvInfoList.Add(uci);

                        if (!isBestSrcExact)
                        {
                            if (fromTypeSym == srcTypeSym)
                            {
                                DebugUtil.Assert((srcBestTypeSym == null) == (dstBestTypeSym == null));
                                // If srcBestTypeSym is null then dstBestTypeSym should be null.
                                DebugUtil.Assert(isFromImplicit);

                                srcBestTypeSym = fromTypeSym;
                                iuciBestSrc = iuciCur;
                                isBestSrcExact = true;
                            }
                            else if (srcBestTypeSym == null)
                            {
                                DebugUtil.Assert(iuciBestSrc == -1);
                                srcBestTypeSym = fromTypeSym;
                                iuciBestSrc = iuciCur;
                            }
                            else if (srcBestTypeSym != fromTypeSym)
                            {
                                DebugUtil.Assert(0 <= iuciBestSrc && iuciBestSrc < iuciCur);

                                int n = CompareSrcTypesBased(
                                    srcBestTypeSym,
                                    udConvInfoList[iuciBestSrc].IsSrcImplicit,
                                    fromTypeSym, isFromImplicit);
                                if (n > 0)
                                {
                                    srcBestTypeSym = fromTypeSym;
                                    iuciBestSrc = iuciCur;
                                }
                            }
                        }

                        if (!isBestDstExact)
                        {
                            if (toTypeSym == dstTypeSym)
                            {
                                DebugUtil.Assert(isToImplicit);

                                dstBestTypeSym = toTypeSym;
                                iuciBestDst = iuciCur;
                                isBestDstExact = true;
                            }
                            else if (dstBestTypeSym == null)
                            {
                                DebugUtil.Assert(iuciBestDst == -1);
                                dstBestTypeSym = toTypeSym;
                                iuciBestDst = iuciCur;
                            }
                            else if (dstBestTypeSym != toTypeSym)
                            {
                                DebugUtil.Assert(0 <= iuciBestDst && iuciBestDst < iuciCur);

                                int n = CompareDstTypesBased(
                                    dstBestTypeSym,
                                    udConvInfoList[iuciBestDst].IsDstImplicit,
                                    toTypeSym,
                                    isToImplicit);
                                if (n > 0)
                                {
                                    dstBestTypeSym = toTypeSym;
                                    iuciBestDst = iuciCur;
                                }
                            }
                        }
                    }
                }
            }

            DebugUtil.Assert((srcBestTypeSym == null) == (dstBestTypeSym == null));
            if (srcBestTypeSym == null)
            {
                DebugUtil.Assert(iuciBestSrc == -1 && iuciBestDst == -1);
                return false;
            }

            DebugUtil.Assert(0 <= iuciBestSrc && iuciBestSrc < udConvInfoList.Count);   // cuci);
            DebugUtil.Assert(0 <= iuciBestDst && iuciBestDst < udConvInfoList.Count);   // cuci);

            int ctypeLiftBest = 3; // Bigger than any legal value on purpose.
            int iuciBest = -1;
            int iuciAmbig = -1;
            bool isAmbig = false;

            // In the second pass, we verify that the types we ended up with are indeed minimal and
            // find the one valid conversion.

            for (int iuci = 0; iuci < udConvInfoList.Count; iuci++)
            {
                //UdConvInfo & uci = prguci[iuci];
                UdConvInfo uci = udConvInfoList[iuci];

                // Get the substituted src and dst types.
                fromTypeSym = Compiler.MainSymbolManager.SubstType(
                    uci.MethWithType.MethSym.ParameterTypes[0],
                    uci.MethWithType.AggTypeSym,
                    null);
                toTypeSym = Compiler.MainSymbolManager.SubstType(
                    uci.MethWithType.MethSym.ReturnTypeSym,
                    uci.MethWithType.AggTypeSym,
                    null);

                int ctypeLift = 0;

                // Lift the conversion if needed.
                if (isSrcLifted && fromTypeSym.IsNonNullableValueType())
                {
                    fromTypeSym = Compiler.MainSymbolManager.GetNubType(fromTypeSym);
                    ctypeLift++;
                }
                if (isDstLifted && toTypeSym.IsNonNullableValueType())
                {
                    toTypeSym = Compiler.MainSymbolManager.GetNubType(toTypeSym);
                    ctypeLift++;
                }

                if (fromTypeSym == srcBestTypeSym && toTypeSym == dstBestTypeSym)
                {
                    // Record the matching conversions.
                    if (ctypeLiftBest > ctypeLift)
                    {
                        // This one is better.
                        iuciBest = iuci;
                        iuciAmbig = -1;
                        ctypeLiftBest = ctypeLift;
                        continue;
                    }

                    if (ctypeLiftBest < ctypeLift)
                    {
                        // Current answer is better.
                        continue;
                    }

                    // Ambiguous at this lifting level. This only guarantees an error if the
                    // lifting level is zero.
                    if (iuciAmbig < 0)
                    {
                        iuciAmbig = iuci;
                        if (ctypeLift == 0)
                        {
                            // No point continuing. We have an error.
                            break;
                        }
                    }
                    continue;
                }
                DebugUtil.Assert(fromTypeSym != srcBestTypeSym || toTypeSym != dstBestTypeSym);

                // Verify that the best types are indeed best. Must NOT compare if the best type is exact.
                // This is not just an efficiency issue. With nullables there are types that are implicitly
                // convertible to each other (eg, int? and int??) and hence not distinguishable by CompareXxxTypesBase.

                if (!isBestSrcExact && fromTypeSym != srcBestTypeSym)
                {
                    int n = CompareSrcTypesBased(
                        srcBestTypeSym,
                        udConvInfoList[iuciBestSrc].IsSrcImplicit,
                        fromTypeSym,
                        uci.IsSrcImplicit);
                    DebugUtil.Assert(n <= 0);

                    if (n >= 0)
                    {
                        if (srcExpr == null)    //if (!pexprDst)
                        {
                            return true;
                        }
                        iuciBestDst = iuci;
                        isAmbig = true;
                        goto LAmbig;
                    }
                }
                if (!isBestDstExact && toTypeSym != dstBestTypeSym)
                {
                    int n = CompareDstTypesBased(
                        dstBestTypeSym,
                        udConvInfoList[iuciBestDst].IsDstImplicit,
                        toTypeSym,
                        uci.IsDstImplicit);
                    DebugUtil.Assert(n <= 0);

                    if (n >= 0)
                    {
                        if (srcExpr == null)    //if (!pexprDst)
                        {
                            return true;
                        }
                        iuciBestDst = iuci;
                        isAmbig = true;
                        goto LAmbig;
                    }
                }
            }

            if (srcExpr == null)    //if (!pexprDst)
            {
                return true;
            }

            if (iuciBest < 0)
            {
                isAmbig = true;
                goto LAmbig;
            }
            if (iuciAmbig >= 0)
            {
                iuciBestSrc = iuciBest;
                iuciBestDst = iuciAmbig;
                isAmbig = true;
            }

        LAmbig:
            if (isAmbig)
            {
                DebugUtil.Assert(0 <= iuciBestSrc && iuciBestSrc < udConvInfoList.Count);   // cuci);
                DebugUtil.Assert(0 <= iuciBestDst && iuciBestDst < udConvInfoList.Count);   // cuci);
                Compiler.Error(
                    treeNode,
                    CSCERRID.ERR_AmbigUDConv,
                    new ErrArg(udConvInfoList[iuciBestSrc].MethWithType),
                    new ErrArg(udConvInfoList[iuciBestDst].MethWithType),
                    new ErrArg(srcTypeSym),
                    new ErrArg(dstTypeSym));
                dstExpr = NewError(treeNode, dstTypeSym);
                return true;
            }

            MethWithInst bestMwi = new MethWithInst(
                udConvInfoList[iuciBest].MethWithType.MethSym,
                udConvInfoList[iuciBest].MethWithType.AggTypeSym,
                null);

            DebugUtil.Assert(ctypeLiftBest <= 2);
            if (bestMwi.MethSym.IsDeprecated() && treeNode != null)
            {
                ReportDeprecated(treeNode, bestMwi);
            }

            fromTypeSym = Compiler.MainSymbolManager.SubstType(
                bestMwi.MethSym.ParameterTypes[0],
                bestMwi.AggTypeSym,
                null);
            toTypeSym = Compiler.MainSymbolManager.SubstType(
                bestMwi.MethSym.ReturnTypeSym,
                bestMwi.AggTypeSym,
                null);

            EXPR fromExpr = srcExpr;
            NubInfo nin = new NubInfo();

            if (ctypeLiftBest > 0 && !fromTypeSym.IsNUBSYM && dstHasNull)
            {
                // Need to lift over the null.
                DebugUtil.Assert(isSrcLifted || isDstLifted);

                BindNubCondValBin(treeNode, srcExpr, null, ref nin, LiftFlagsEnum.LiftBoth);
                DebugUtil.Assert(nin.IsActive);
                fromExpr = nin.Val(0);
            }
            else
            {
                DebugUtil.Assert(!nin.IsActive);
            }

            fromExpr = MustCastCore(fromExpr, fromTypeSym, treeNode, ConvertTypeEnum.NOUDC);
            DebugUtil.Assert(fromExpr != null);

            EXPRCALL callExpr = NewExpr(treeNode, EXPRKIND.CALL, toTypeSym) as EXPRCALL;
            callExpr.ArgumentsExpr = fromExpr;
            callExpr.ObjectExpr = null;
            callExpr.MethodWithInst = bestMwi;

            EXPR tempDstExpr = MustCastCore(callExpr, dstTypeSym, treeNode, ConvertTypeEnum.NOUDC);
            DebugUtil.Assert(tempDstExpr != null);

            if (nin.IsActive)
            {
                tempDstExpr = BindNubOpRes(
                    treeNode,
                    dstTypeSym,
                    tempDstExpr,
                    NewExprZero(treeNode, dstTypeSym),
                    ref nin);
            }
            dstExpr = tempDstExpr;

            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.CompareSrcTypesBased
        //
        /// <summary>
        /// <para>This is a helper method for bindUserDefinedConversion. "Compares" two types relative to a
        /// base type and indicates which is "closer" to base. fImplicit(1|2) specifies whether there is a
        /// standard implicit conversion from base to type(1|2). If fImplicit(1|2) is false there should
        /// be a standard explicit conversion from base to type(1|2). The partial ordering used is as
        /// follows:</para>
        ///
        /// <list type="bullet">
        /// <item>If exactly one of fImplicit(1|2) is true then the corresponding type is closer.</item>
        /// <item>Otherwise if there is a standard implicit conversion in neither direction or both directions
        /// then neither is closer.</item>
        /// <item>Otherwise if both of fImplicit(1|2) are true:
        /// <list type="bullet">
        /// <item>If there is a standard implicit conversion from type(1|2) to type(2|1) then type(1|2)
        /// is closer.</item>
        /// <item>Otherwise neither is closer.</item>
        /// </list>
        /// </item>
        /// <item>Otherwise both of fImplicit(1|2) are false and:
        /// <list type="bullet">
        /// <item>If there is a standard implicit conversion from type(1|2) to type(2|1) then type(2|1)
        /// is closer.</item>
        /// <item>Otherwise neither is closer.</item>
        /// </list>
        /// </item>
        /// </list>
        ///
        /// <para>The return value is -1 if type1 is closer, +1 if type2 is closer and 0 if neither is closer.</para>
        /// </summary>
        /// <param name="typeSym1"></param>
        /// <param name="isImplicit1"></param>
        /// <param name="typeSym2"></param>
        /// <param name="isImplicit2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private int CompareSrcTypesBased(
            TYPESYM typeSym1,
            bool isImplicit1,
            TYPESYM typeSym2,
            bool isImplicit2)
        {
            DebugUtil.Assert(typeSym1 != typeSym2);

            if (isImplicit1 != isImplicit2)
            {
                return isImplicit1 ? -1 : +1;
            }

            bool canCon1 = CanConvert(typeSym1, typeSym2, ConvertTypeEnum.NOUDC);
            bool canCon2 = CanConvert(typeSym2, typeSym1, ConvertTypeEnum.NOUDC);

            if (canCon1 == canCon2)
            {
                return 0;
            }

            return (isImplicit1 == canCon1) ? -1 : +1;
        }

        //--------------------------------------------------
        // FUNCBREC.CompareDstTypesBased
        //
        /// <summary>
        /// <para>This is a helper method for bindUserDefinedConversion. "Compares" two types relative to a
        /// base type and indicates which is "closer" to base. fImplicit(1|2) specifies whether there is a
        /// standard implicit conversion from type(1|2) to base. If fImplicit(1|2) is false there should
        /// be a standard explicit conversion from type(1|2) to base. The partial ordering used is as
        /// follows:</para>
        ///
        /// <list type="bullet">
        /// <item> If exactly one of fImplicit(1|2) is true then the corresponding type is closer.</item>
        /// <item> Otherwise if there is a standard implicit conversion in neither direction or both directions
        /// then neither is closer.</item>
        ///
        /// <item> Otherwise if both of fImplicit(1|2) are true:
        /// <list type="bullet">
        /// <item>If there is a standard implicit conversion from type(1|2) to type(2|1) then type(2|1)
        /// is closer.</item>
        /// <item>Otherwise neither is closer.</item>
        /// </list>
        /// </item>
        ///
        /// <item>Otherwise both of fImplicit(1|2) are false and:
        /// <list type="bullet">
        /// <item>If there is a standard implicit conversion from type(1|2) to type(2|1) then type(1|2)
        /// is closer.</item>
        /// <item>Otherwise neither is closer.</item>
        /// </list>
        /// </item>
        /// </list>
        ///
        /// <para>The return value is -1 if type1 is closer, +1 if type2 is closer and 0 if neither is closer.</para>
        /// </summary>
        /// <param name="typeSym1"></param>
        /// <param name="isImplicit1"></param>
        /// <param name="typeSym2"></param>
        /// <param name="isImplicit2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private int CompareDstTypesBased(
            TYPESYM typeSym1,
            bool isImplicit1,
            TYPESYM typeSym2,
            bool isImplicit2)
        {
            DebugUtil.Assert(typeSym1 != typeSym2);

            if (isImplicit1 != isImplicit2)
            {
                return isImplicit1 ? -1 : +1;
            }

            bool canCon1 = CanConvert(typeSym1, typeSym2, ConvertTypeEnum.NOUDC);
            bool canCon2 = CanConvert(typeSym2, typeSym1, ConvertTypeEnum.NOUDC);

            if (canCon1 == canCon2)
            {
                return 0;
            }

            return (isImplicit1 == canCon1) ? +1 : -1;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindImplicitConversion
        //
        /// <summary>
        /// This is a complex routine with complex parameters.
        /// Generally, this should be called through one of the helper methods
        /// that insulates you from the complexity of the interface.
        /// This routine handles all the logic associated with implicit conversions.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="srcExpr">the expression being converted.
        /// Can be NULL if only type conversion info is being supplied.</param>
        /// <param name="srcTypeSym">type of the source</param>
        /// <param name="destTypeSym">type of the destination</param>
        /// <param name="destExpr">returns an expression of the src converted to the dest.
        /// If NULL, we only care about whether the conversion can be attempted,
        /// not the expression tree.</param>
        /// <param name="flags">flags possibly customizing the conversions allowed.
        /// E.g., can suppress user-defined conversions.</param>
        /// <returns>returns true if the conversion can be made, false if not.</returns>
        //------------------------------------------------------------
        private bool BindImplicitConversion(
            BASENODE treeNode,
            EXPR srcExpr,
            TYPESYM srcTypeSym,
            TYPESYM destTypeSym,
            ref EXPR destExpr,
            ConvertTypeEnum flags)
        {
            // Can't convert to or from the error type.
            if (srcTypeSym == null || destTypeSym == null || destTypeSym.IsNeverSameType())
            {
                return false;
            }

            // CS4
            if (srcTypeSym.Kind == SYMKIND.DYNAMICSYM)
            {
                srcTypeSym = Compiler.MainSymbolManager.ObjectTypeSym;
            }
            if (destTypeSym.Kind == SYMKIND.DYNAMICSYM)
            {
                destTypeSym = Compiler.MainSymbolManager.ObjectTypeSym;
            }

            // types must be supplied.
            DebugUtil.Assert(srcTypeSym != null && destTypeSym != null);
            // type of source should be correct if source supplied
            DebugUtil.Assert(
                srcExpr == null ||
                srcTypeSym == srcExpr.TypeSym ||
                srcExpr.TypeSym.Kind == SYMKIND.DYNAMICSYM);

            // need source expr to create dest expr
            //ASSERT(pexprDest == NULL || exprSrc != NULL); 

            // Make sure both types are declared.
            Compiler.EnsureState(srcTypeSym, AggStateEnum.Prepared);
            Compiler.EnsureState(destTypeSym, AggStateEnum.Prepared);

            switch (destTypeSym.Kind)
            {
                case SYMKIND.ERRORSYM:
                    DebugUtil.Assert(destTypeSym.ParentSym != null);
                    if (srcTypeSym != destTypeSym)
                    {
                        return false;
                    }
                    destExpr = srcExpr;
                    return true;

                case SYMKIND.NULLSYM:
                    // Can only convert to the null type if src is null.
                    if (!srcTypeSym.IsNULLSYM)
                    {
                        return false;
                    }
                    destExpr = srcExpr;
                    return true;

                case SYMKIND.ANONMETHSYM:
                case SYMKIND.LAMBDAEXPRSYM: // CS3
                case SYMKIND.METHGRPSYM:
                    DebugUtil.Assert(false, "Something is wrong with TYPESYM.IsNeverSameType()");
                    return false;

                case SYMKIND.VOIDSYM:
                    return false;

                default:
                    break;
            }

            if (srcTypeSym.IsERRORSYM)
            {
                DebugUtil.Assert(!destTypeSym.IsERRORSYM);
                return false;
            }

            //--------------------------------------------------------
            // Does the trivial conversion exist?
            //--------------------------------------------------------
            if ((srcTypeSym == destTypeSym) &&
                (((flags & ConvertTypeEnum.ISEXPLICIT) == 0) ||
                (!srcTypeSym.IsPredefType(PREDEFTYPE.FLOAT) && !srcTypeSym.IsPredefType(PREDEFTYPE.DOUBLE))))
            {
                destExpr = srcExpr;
                return true;
            }

            if (destTypeSym.IsNUBSYM)
            {
                return BindNubConversion(treeNode, srcExpr, srcTypeSym, destTypeSym as NUBSYM, ref destExpr, flags);
            }

            //--------------------------------------------------------
            // (CS4)
            //--------------------------------------------------------
            if (destTypeSym.Kind == SYMKIND.DYNAMICSYM)
            {
                destTypeSym = Compiler.GetReqPredefType(PREDEFTYPE.OBJECT, true);
            }

            //--------------------------------------------------------
            // Boxing converions from T? to object, ValueType and the interfaces supported by T....
            //--------------------------------------------------------
            if (srcTypeSym.IsNUBSYM)
            {
                AGGTYPESYM nullableAggTypeSym = (srcTypeSym as NUBSYM).GetAggTypeSym();
                if (nullableAggTypeSym == null)
                {
                    return false;
                }

                // In case that src is T? and dest is Nullable<T>.
                if (nullableAggTypeSym == destTypeSym)
                {
                    destExpr = srcExpr;
                    return true;
                }

                if (Compiler.IsBaseType((srcTypeSym as NUBSYM).BaseTypeSym, destTypeSym) &&
                    !FUnwrappingConv(srcTypeSym, destTypeSym))
                {
                    return BindSimpleCast(
                        treeNode,
                        srcExpr,
                        destTypeSym,
                        ref destExpr,
                        EXPRFLAG.BOX);
                }
                return ((flags & ConvertTypeEnum.NOUDC) == 0) &&
                    BindUserDefinedConversion(
                        treeNode,
                        srcExpr,
                        srcTypeSym,
                        destTypeSym,
                        ref destExpr,
                        true);
            }

            if ((flags & ConvertTypeEnum.ISEXPLICIT) != 0)
            {
                flags |= ConvertTypeEnum.NOUDC;
            }

            // Get the fundamental types of destination.
            FUNDTYPE ftDest = destTypeSym.FundamentalType();
            DebugUtil.Assert(ftDest != FUNDTYPE.NONE || destTypeSym.IsPARAMMODSYM);

            switch (srcTypeSym.Kind)
            {
                default:
                    DebugUtil.Assert(false);
                    break;

                case SYMKIND.METHGRPSYM:
                    return BindGrpConversion(
                        treeNode,
                        srcExpr as EXPRMEMGRP,
                        destTypeSym,
                        ref destExpr,
                        false);

                case SYMKIND.ANONMETHSYM:
                    return BindAnonMethConversion(
                        treeNode,
                        srcExpr,
                        destTypeSym,
                        ref destExpr,
                        false);

                case SYMKIND.LAMBDAEXPRSYM:
                    return BindLambdaExpressionConversion(
                        treeNode,
                        srcExpr,
                        destTypeSym,
                        ref destExpr,
                        false);

                case SYMKIND.VOIDSYM:
                case SYMKIND.ERRORSYM:
                case SYMKIND.PARAMMODSYM:
                    return false;

                case SYMKIND.NULLSYM:
                    // null type can be implicitly converted to any reference type
                    // or pointer type or type variable with reference-type constraint.
                    if (ftDest != FUNDTYPE.REF &&
                        ftDest != FUNDTYPE.PTR &&
                        (ftDest != FUNDTYPE.VAR || !(destTypeSym as TYVARSYM).IsReferenceType()) &&
                        // null is convertible to System.Nullable<T>.
                        !destTypeSym.IsPredefType(PREDEFTYPE.G_OPTIONAL))
                    {
                        break;
                    }

                    if (srcExpr != null)
                    {
                        destExpr = AddSideEffects(
                            treeNode,
                            NewExprZero(treeNode, destTypeSym),
                            srcExpr,
                            true,
                            false);
                    }
                    return true;

                case SYMKIND.ARRAYSYM:
                    // Handle array conversions.
                    // An array type can be implicitly converted to some other array types,
                    // Object, or Array or some base class/interface that Array handles.
                    // Also, IList<U> whenever there is an implicit reference conversion
                    // from the element type to U and the rank is 1.
                    if (Compiler.IsBaseType(srcTypeSym, destTypeSym))
                    {
                        EXPRFLAG grfex = 0;

                        if ((destTypeSym.IsARRAYSYM ||
                            destTypeSym.IsInterfaceType() &&
                            (destTypeSym as AGGTYPESYM).AllTypeArguments.Count == 1 &&
                            (destTypeSym as AGGTYPESYM).AllTypeArguments[0] != (srcTypeSym as ARRAYSYM).ElementTypeSym)
                            &&
                            (BSYMMGR.TypeContainsTyVars(srcTypeSym, null) || BSYMMGR.TypeContainsTyVars(destTypeSym, null)))
                        {
                            grfex = EXPRFLAG.REFCHECK;
                        }
                        return BindSimpleCast(treeNode, srcExpr, destTypeSym, ref destExpr, grfex);
                    }
                    break;

                case SYMKIND.PTRSYM:
                    // Handle pointer conversions.
                    // A pointer can be implicitly converted to void *. That's it.
                    if (destTypeSym.IsPTRSYM && (destTypeSym as PTRSYM).BaseTypeSym == GetVoidType())
                    {
                        return BindSimpleCast(treeNode, srcExpr, destTypeSym, ref destExpr, 0);
                    }
                    break;

                case SYMKIND.TYVARSYM:
                    // Handle implicit conversions for type variables
                    // A type variable can be implicitly converted to its bounds
                    // (perhaps by boxing - will use generalized "box" instruction)

                    // Check the effective base class first.
                    TYVARSYM tvSym = srcTypeSym as TYVARSYM;
                    DebugUtil.Assert(tvSym != null);
                    TYPESYM tempType = tvSym.BaseClassSym;
                    TypeArray boundArray = tvSym.BoundArray;
                    int itype = -1;

                    // Examine if srcTypeSym can be converted to destTypeSym.
                    // If not, examine its bounds.
                    for (; ; )
                    {
                        DebugUtil.Assert(!tempType.IsValueType());

                        if (CanConvert(tempType, destTypeSym, flags | ConvertTypeEnum.NOUDC))
                        {
                            if (destTypeSym.IsTYVARSYM)
                            {
                                // For a type var destination we need to cast to object then to the other type var.
                                EXPR tempExpr = null;

                                BindSimpleCast(
                                    treeNode,
                                    srcExpr,
                                    this.GetRequiredPredefinedType(PREDEFTYPE.OBJECT),
                                    ref tempExpr,
                                    EXPRFLAG.FORCE_BOX);

                                BindSimpleCast(
                                    treeNode,
                                    tempExpr,
                                    destTypeSym,
                                    ref destExpr,
                                    EXPRFLAG.FORCE_UNBOX);
                            }
                            else
                            {
                                BindSimpleCast(
                                    treeNode,
                                    srcExpr,
                                    destTypeSym,
                                    ref destExpr,
                                    EXPRFLAG.FORCE_BOX);
                            }
                            return true;
                        }

                    LNext:
                        if (++itype >= boundArray.Count) break;
                        tempType = boundArray[itype];
                        if (!tempType.IsInterfaceType() && !tempType.IsTYVARSYM) goto LNext;
                    } // for (; ; )

                    break;

                case SYMKIND.AGGTYPESYM:
                    // GENERICS: The case for constructed types is very similar to types with
                    // no parameters. The parameters are irrelevant for most of the conversions
                    // below. They could be relevant if we had user-defined conversions on
                    // generic types.

                    AGGSYM srcAggSym = (srcTypeSym as AGGTYPESYM).GetAggregate();

                    // TypeReference and ArgIterator can't be boxed (or converted to anything else)
                    if (srcTypeSym.IsSpecialByRefType())
                    {
                        return false;
                    }

                    if (srcAggSym.IsEnum)
                    {
                        // Handle enum conversions.
                        if (destTypeSym.IsAGGTYPESYM &&
                            Compiler.IsBaseType(srcTypeSym as AGGTYPESYM, destTypeSym as AGGTYPESYM))
                        {
                            return BindSimpleCast(
                                treeNode,
                                srcExpr,
                                destTypeSym,
                                ref destExpr,
                                EXPRFLAG.BOX | EXPRFLAG.CANTBENULL);
                        }
                        break;
                    } // if (srcAggSym.IsEnum)

                    if (destTypeSym.IsEnumType())
                    {
                        // No implicit conversion TO enum except the identity conversion
                        // or literal '0'.
                        // NB: this is NOT a standard conversion
                        // Note: Don't use GetConst here since the conversion only applies to bona-fide compile time constants.
                        if (srcAggSym.PredefinedTypeID != PREDEFTYPE.BOOL &&
                            srcExpr != null &&
                            srcExpr.IsZero(false) &&
                            (srcExpr.Flags & EXPRFLAG.LITERALCONST) != 0 &&
                            (flags & ConvertTypeEnum.STANDARD) == 0)
                        {
                            destExpr = NewExprConstant(
                                treeNode,
                                destTypeSym,
                                new CONSTVAL(Compiler.MainSymbolManager.GetPredefZero(
                                destTypeSym.UnderlyingEnumType().GetPredefType())));
                            SetNodeExpr(srcExpr.TreeNode, destExpr);
                            return true;
                        }
                        break;
                    } // if (destTypeSym.IsEnumType())

                    //------------------------------
                    // Handle conversions between simple types.
                    // (int.long, float.double, etc...)
                    //------------------------------
                    if (srcAggSym.GetThisType().IsSimpleType() && destTypeSym.IsSimpleType())
                    {
                        DebugUtil.Assert(srcAggSym.IsPredefinedType && destTypeSym.IsPredefined());

                        PREDEFTYPE ptSrc = srcAggSym.PredefinedTypeID;
                        PREDEFTYPE ptDest = destTypeSym.GetPredefType();
                        byte convertKind;
                        bool isConstShrinkCast = false;

                        DebugUtil.Assert(
                            (int)ptSrc < SymbolUtil.NUM_SIMPLE_TYPES &&
                            (int)ptDest < SymbolUtil.NUM_SIMPLE_TYPES);
                        // Note: Don't use GetConst here
                        // since the conversion only applies to bona-fide compile time constants.

                        if (srcExpr != null
                            &&
                            srcExpr.Kind == EXPRKIND.CONSTANT
                            &&
                            ((ptSrc == PREDEFTYPE.INT && ptDest != PREDEFTYPE.BOOL && ptDest != PREDEFTYPE.CHAR) ||
                            (ptSrc == PREDEFTYPE.LONG && ptDest == PREDEFTYPE.ULONG))
                            &&
                            IsConstantInRange(srcExpr as EXPRCONSTANT, destTypeSym, false))
                        {
                            // Special case (CLR 6.1.6): if integral constant is in range,
                            // the conversion is a legal implicit conversion.
                            convertKind = SimpleTypeConversion.CONV_KIND_IMP;
                            isConstShrinkCast =
                                destExpr != null &&
                                (simpleTypeConversions[(int)ptSrc, (int)ptDest] & SimpleTypeConversion.CONV_KIND_MASK)
                                    != SimpleTypeConversion.CONV_KIND_IMP;
                        }
                        else if (ptSrc == ptDest)
                        {
                            // Special case: precision limiting casts to float or double
                            DebugUtil.Assert(ptSrc == PREDEFTYPE.FLOAT || ptSrc == PREDEFTYPE.DOUBLE);
                            DebugUtil.Assert((flags & ConvertTypeEnum.ISEXPLICIT) != 0);
                            convertKind = SimpleTypeConversion.CONV_KIND_IMP;
                        }
                        else
                        {
                            convertKind = simpleTypeConversions[(int)ptSrc, (int)ptDest];
                            // identity conversion should have been handled at first.
                            DebugUtil.Assert(
                                (convertKind & SimpleTypeConversion.CONV_KIND_MASK)
                                != SimpleTypeConversion.CONV_KIND_ID);
                        }

                        if ((convertKind & SimpleTypeConversion.CONV_KIND_MASK) == SimpleTypeConversion.CONV_KIND_IMP)
                        {
                            // An implicit conversion exists. Do the conversion.
                            if (srcExpr != null && srcExpr.GetConst() != null)
                            {
                                // Fold the constant cast if possible.
                                bool checkFailure = false;
                                if (BindConstantCast(treeNode, srcExpr, destTypeSym, ref destExpr, ref checkFailure))
                                {
                                    DebugUtil.Assert(!checkFailure);
                                    // If we cast down in size because the value was in range, then map that
                                    // node to the new value, so ExtractMethod doesn't introduce an error.
                                    if (isConstShrinkCast)
                                    {
                                        SetNodeExpr(srcExpr.TreeNode, destExpr);
                                    }
                                    return true;  // else, don't fold and use a regular cast, below.
                                }
                                DebugUtil.Assert(!checkFailure);
                                // since this is an implicit cast, it can never fail the check...
                            }

                            if ((convertKind & SimpleTypeConversion.CONV_KIND_USEUDC) != 0)
                            {
                                //if (!destExpr) return true;
                                // According the language, this is a standard conversion, but it is implemented
                                // through a user-defined conversion. Because it's a standard conversion, we don't
                                // test the NOUDC flag here.
                                return BindUserDefinedConversion(treeNode, srcExpr, srcTypeSym, destTypeSym, ref destExpr, true);
                            }
                            return BindSimpleCast(treeNode, srcExpr, destTypeSym, ref destExpr, 0);
                        }

                        // No break here, continue testing for derived to base conversions below.
                    } // if (srcAggSym.GetThisType().IsSimpleType() && destTypeSym.IsSimpleType())

                    //------------------------------
                    // Handle struct, class and interface conversions.
                    // Delegates are handled just like classes here.
                    // A class, struct, or interface is implicitly convertable to a base class or interface.
                    //------------------------------
                    if (destTypeSym.IsAGGTYPESYM &&
                        Compiler.IsBaseType(srcTypeSym as AGGTYPESYM, destTypeSym as AGGTYPESYM))
                    {
                        if (srcAggSym.IsStruct && ftDest == FUNDTYPE.REF)
                        {
                            return BindSimpleCast(
                                treeNode,
                                srcExpr,
                                destTypeSym,
                                ref destExpr,
                                EXPRFLAG.BOX | EXPRFLAG.CANTBENULL);
                        }
                        else
                        {
                            return BindSimpleCast(
                                treeNode,
                                srcExpr,
                                destTypeSym,
                                ref destExpr,
                                srcExpr != null ? (srcExpr.Flags & EXPRFLAG.CANTBENULL) : 0);
                        }
                    }
                    break;
            }

            // No built-in conversion was found. Maybe a user-defined conversion?
            if ((flags & ConvertTypeEnum.NOUDC) == 0)
            {
                return BindUserDefinedConversion(treeNode, srcExpr, srcTypeSym, destTypeSym, ref destExpr, true);
            }

            // No conversion was found.
            return false;
        }

        //--------------------------------------------------
        // FUNCBREC.BindExplicitConversion
        //
        /// This is a complex routine with complex parameter. Generally, this should
        /// be called through one of the helper methods that insulates you
        /// from the complexity of the interface. This routine handles all the logic
        /// associated with explicit conversions.
        ///
        /// Note that this function calls bindImplicitConversion first, so the main
        /// logic is only concerned with conversions that can be made explicitly, but
        /// not implicitly.
        //--------------------------------------------------
        private bool BindExplicitConversion(
            BASENODE treeNode,
            EXPR srcExpr,
            TYPESYM srcTypeSym,
            TYPESYM destTypeSym,
            ref EXPR destExpr,
            ConvertTypeEnum flags)
        {
            // To test for a standard conversion, call
            //     canConvert(srcExpr, destTypeSym, STANDARDANDNOUDC) and
            //     canConvert(destTypeSym, srcTypeSym, STANDARDANDNOUDC).
            DebugUtil.Assert((flags & ConvertTypeEnum.STANDARD) == 0);
            EXPR tempExpr = null;

            // All implicit conversions are explicit conversions.
            // Don't try user-defined conversions now because we'll try them again later.
            if (BindImplicitConversion(
                treeNode,
                srcExpr,
                srcTypeSym,
                destTypeSym,
                ref destExpr,
                flags | ConvertTypeEnum.ISEXPLICIT))
            {
                return true;
            }

            if (srcTypeSym == null ||
                destTypeSym == null ||
                srcTypeSym.IsERRORSYM ||
                destTypeSym.IsERRORSYM ||
                destTypeSym.IsNeverSameType())
            {
                return false;
            }

            if (destTypeSym.IsNUBSYM)
            {
                // This is handled completely by bindImplicitConversion.
                return false;
            }

            if (srcTypeSym.IsNUBSYM)
            {
                // If S and T are value types and there is a builtin conversion from S => T then there is an
                // explicit conversion from S? => T that throws on null.
                if (destTypeSym.IsValueType() &&
                    BindExplicitConversion(
                        treeNode,
                        null,
                        srcTypeSym.StripNubs(),
                        destTypeSym,
                        ref tempExpr,
                        flags | ConvertTypeEnum.NOUDC))
                {
                    //if (destExpr) {
                    if (srcExpr != null)
                    {
                        while (srcExpr.TypeSym.IsNUBSYM)
                        {
                            srcExpr = BindNubValue(treeNode, srcExpr);
                        }
                        DebugUtil.Assert(srcExpr.TypeSym == srcTypeSym.StripNubs());

                        if (!BindExplicitConversion(
                            treeNode,
                            srcExpr,
                            srcExpr.TypeSym,
                            destTypeSym,
                            ref destExpr,
                            flags | ConvertTypeEnum.NOUDC))
                        {
                            DebugUtil.VsFail("BindExplicitConversion failed unexpectedly");
                            return false;
                        }
                    }
                    return true;
                }

                return (
                    (flags & ConvertTypeEnum.NOUDC) == 0 &&
                    BindUserDefinedConversion(
                        treeNode,
                        srcExpr,
                        srcTypeSym,
                        destTypeSym,
                        ref destExpr,
                        false));
            }

            AGGSYM ilistAggSym;

            if (srcTypeSym.IsARRAYSYM &&
                (srcTypeSym as ARRAYSYM).Rank == 1 &&
                destTypeSym.IsInterfaceType() &&
                (destTypeSym as AGGTYPESYM).AllTypeArguments.Count == 1 &&
                (ilistAggSym = compiler.GetOptPredefAgg(PREDEFTYPE.G_ILIST, true)) != null &&
                compiler.IsBaseAggregate(ilistAggSym, (destTypeSym as AGGTYPESYM).GetAggregate()))
            {
                TYPESYM typeArr = (srcTypeSym as ARRAYSYM).ElementTypeSym;
                TYPESYM typeLst = (destTypeSym as AGGTYPESYM).AllTypeArguments[0];

                if (FExpRefConv(typeArr, typeLst))
                {
                    return BindSimpleCast(
                        treeNode,
                        srcExpr,
                        destTypeSym,
                        ref destExpr,
                        EXPRFLAG.REFCHECK);
                }
            }

            // if we were casting an integral constant to another constant type,
            // then, if the constant were in range, then the above call would have succeeded.

            // But it failed, and so we know that the constant is not in range

            switch (destTypeSym.Kind)
            {
                default:
                    DebugUtil.Assert(false);
                    // Fall through.
                    goto case SYMKIND.VOIDSYM;

                case SYMKIND.VOIDSYM:
                    // Can't convert to a method group or anon method.
                    return false;

                case SYMKIND.NULLSYM:
                    // Can never convert TO the null type.
                    return false;

                case SYMKIND.TYVARSYM:
                    // NOTE: for the flags, we have to use EXPRFLAG.FORCE_UNBOX (not EXPRFLAG.REFCHECK)
                    // even when we know that the type is a reference type.
                    // The verifier expects all code for type parameters to behave
                    // as if the type parameter is a value type.
                    // The jitter should be smart about it....
                    if (srcTypeSym.IsInterfaceType() ||
                        CanConvert(destTypeSym, srcTypeSym, ConvertTypeEnum.NOUDC))
                    {
                        // There is an explicit, possibly unboxing, conversion
                        // from Object or any interface to a type variable.
                        // This will involve a type check and possibly an unbox.
                        // There is an explicit conversion from non-interface X to the type var
                        // iff there is an implicit conversion from the type var to X.
                        if (srcTypeSym.IsTYVARSYM)
                        {
                            // Need to box first before unboxing.
                            tempExpr = null;
                            BindSimpleCast(
                                treeNode,
                                srcExpr,
                                GetRequiredPredefinedType(PREDEFTYPE.OBJECT),
                                ref tempExpr,
                                EXPRFLAG.FORCE_BOX);
                            srcExpr = tempExpr;
                        }
                        return BindSimpleCast(
                            treeNode, srcExpr,
                            destTypeSym,
                            ref destExpr,
                            EXPRFLAG.FORCE_UNBOX);
                    }
                    break;

                case SYMKIND.ARRAYSYM:
                    // Handle conversions to arrays.
                    // An array type can be explicitly converted to some other array types. Object, and Array
                    // and their interface can be explicitly converted to any array type.
                    if (srcTypeSym.IsARRAYSYM)
                    {
                        // Handle array . array conversions. Ranks must match (or cast from unknown rank),
                        // and element type must be same or built-in explicit reference conversion.
                        ARRAYSYM srcArraySym = srcTypeSym as ARRAYSYM;
                        ARRAYSYM destArraySym = destTypeSym as ARRAYSYM;
                        TYPESYM srcElementSym = srcArraySym.ElementTypeSym;
                        TYPESYM destElementSym = destArraySym.ElementTypeSym;

                        if (srcArraySym.Rank != destArraySym.Rank)
                        {
                            break;  // Ranks do not match.
                        }

                        if (FExpRefConv(srcElementSym, destElementSym))
                        {
                            // Element types are compatible.
                            return BindSimpleCast(
                                treeNode,
                                srcExpr,
                                destTypeSym,
                                ref destExpr,
                                EXPRFLAG.REFCHECK);
                        }
                        break;
                    }

                    if ((destTypeSym as ARRAYSYM).Rank == 1 &&
                        srcTypeSym.IsInterfaceType() &&
                        (srcTypeSym as AGGTYPESYM).AllTypeArguments.Count == 1 &&
                        (ilistAggSym = compiler.GetOptPredefAgg(PREDEFTYPE.G_ILIST, true)) != null &&
                        compiler.IsBaseAggregate(ilistAggSym, (srcTypeSym as AGGTYPESYM).GetAggregate()))
                    {
                        TYPESYM typeArr = (destTypeSym as ARRAYSYM).ElementTypeSym;
                        TYPESYM typeLst = (srcTypeSym as AGGTYPESYM).AllTypeArguments[0];

                        DebugUtil.Assert(!typeArr.IsNeverSameType());
                        if (typeArr == typeLst || FExpRefConv(typeArr, typeLst))
                        {
                            return BindSimpleCast(
                                treeNode,
                                srcExpr,
                                destTypeSym,
                                ref destExpr,
                                EXPRFLAG.REFCHECK);
                        }
                    }

                    if (CanConvert(GetRequiredPredefinedType(PREDEFTYPE.ARRAY), srcTypeSym, ConvertTypeEnum.NOUDC))
                    {
                        // The above if checks for src==Array, object or an interface Array implements.
                        return BindSimpleCast(
                            treeNode,
                            srcExpr,
                            destTypeSym,
                            ref destExpr,
                            EXPRFLAG.REFCHECK);
                    }
                    break;

                case SYMKIND.PTRSYM:
                    // Handle pointer conversions.
                    // Any pointer can be explicitly converted to any other pointer.
                    if (srcTypeSym.IsPTRSYM ||
                        srcTypeSym.FundamentalType() <= FUNDTYPE.LASTINTEGRAL && srcTypeSym.IsNumericType())
                    {
                        return BindSimpleCast(
                            treeNode,
                            srcExpr,
                            destTypeSym,
                            ref destExpr,
                            0);
                    }
                    break;

                case SYMKIND.AGGTYPESYM:
                    AGGSYM destAggSym = (destTypeSym as AGGTYPESYM).GetAggregate();

                    //------------------------------------------------
                    // AGGTYPESYM (1)
                    //------------------------------------------------
                    // TypeReference and ArgIterator can't be boxed (or converted to anything else)
                    if (srcTypeSym.IsSpecialByRefType())
                    {
                        return false;
                    }

                    //------------------------------------------------
                    // AGGTYPESYM (2)
                    //------------------------------------------------
                    if (srcTypeSym.IsEnumType() && !destAggSym.IsPredefAgg(PREDEFTYPE.DECIMAL))
                    {
                        // Handle explicit conversion from enum.
                        // enums can explicitly convert to any numeric type or any other enum.
                        if (destAggSym.GetThisType().IsNumericType() ||
                            destAggSym.IsEnum ||
                            (destAggSym.IsPredefinedType && destAggSym.PredefinedTypeID == PREDEFTYPE.CHAR))
                        {
                            if (srcExpr != null && srcExpr.GetConst() != null)
                            {
                                bool checkFailure = true;
                                if (BindConstantCast(
                                    treeNode,
                                    srcExpr,
                                    destTypeSym,
                                    ref destExpr,
                                    ref checkFailure))
                                {
                                    return true;
                                }
                                if (checkFailure)
                                {
                                    return false;
                                }
                            }
                            return BindSimpleCast(
                                treeNode,
                                srcExpr,
                                destTypeSym,
                                ref destExpr,
                                0);
                        }
                        break;
                    }

                    //------------------------------------------------
                    // AGGTYPESYM (3)
                    //------------------------------------------------
                    if (destAggSym.IsEnum && !srcTypeSym.IsPredefType(PREDEFTYPE.DECIMAL))
                    {
                        // Handle conversions to enum.
                        // Object or numeric types can explicitly convert to enums.
                        // However, this is not considered on a par to a user-defined conversion.
                        if (srcTypeSym.IsNumericType() ||
                            (srcTypeSym.IsPredefined() && srcTypeSym.GetPredefType() == PREDEFTYPE.CHAR))
                        {
                            // Transform constant to constant.
                            if (srcExpr != null && srcExpr.GetConst() != null)
                            {
                                bool checkFailure = true;
                                if (BindConstantCast(
                                    treeNode,
                                    srcExpr,
                                    destTypeSym,
                                    ref destExpr,
                                    ref checkFailure))
                                {
                                    return true;
                                }
                                if (checkFailure)
                                {
                                    return false;
                                }
                            }
                            return BindSimpleCast(
                                treeNode,
                                srcExpr,
                                destTypeSym,
                                ref destExpr,
                                0);
                        }
                        else if (
                            srcTypeSym.IsPredefined() &&
                            (srcTypeSym.IsPredefType(PREDEFTYPE.OBJECT) ||
                                srcTypeSym.IsPredefType(PREDEFTYPE.VALUE) ||
                                srcTypeSym.IsPredefType(PREDEFTYPE.ENUM)))
                        {
                            return BindSimpleCast(
                                treeNode,
                                srcExpr,
                                destTypeSym,
                                ref destExpr,
                                EXPRFLAG.UNBOX);
                        }
                        break;
                    }

                    //------------------------------------------------
                    // AGGTYPESYM (4)
                    //------------------------------------------------
                    if ((srcTypeSym.IsSimpleType() && destTypeSym.IsSimpleType()) ||
                        (srcTypeSym.IsEnumType() && destAggSym.IsPredefAgg(PREDEFTYPE.DECIMAL)) ||
                        (srcTypeSym.IsPredefType(PREDEFTYPE.DECIMAL) && destAggSym.IsEnum))
                    {
                        bool wasEnum = false;
                        AGGSYM oldDestAggSym = destAggSym;
                        TYPESYM oldDestTypeSym = destTypeSym;

                        if (!srcTypeSym.IsSimpleType())
                        {
                            DebugUtil.Assert(srcTypeSym.IsEnumType());
                            wasEnum = true;
                            srcTypeSym = srcTypeSym.UnderlyingType();
                            // Need to first cast the source expr to its underlying type.
                            if (srcExpr != null)
                            {
                                tempExpr = null;
                                BindSimpleCast(
                                    treeNode,
                                    srcExpr,
                                    srcTypeSym,
                                    ref tempExpr,
                                    0);
                                srcExpr = tempExpr;
                            }
                        }
                        else if (!destTypeSym.IsSimpleType())
                        {
                            DebugUtil.Assert(destAggSym.IsEnum);
                            wasEnum = true;
                            destTypeSym = destTypeSym.UnderlyingType();
                            destAggSym = destTypeSym.GetAggregate();
                        }

                        // Handle conversions between simple types. (int.long, float.double, etc...)

                        DebugUtil.Assert(srcTypeSym.IsPredefined() && destAggSym.IsPredefinedType);
                        PREDEFTYPE ptSrc = srcTypeSym.GetPredefType();
                        PREDEFTYPE ptDest = destAggSym.PredefinedTypeID;
                        DebugUtil.Assert(
                            (int)ptSrc < SymbolUtil.NUM_SIMPLE_TYPES &&
                            (int)ptDest < SymbolUtil.NUM_SIMPLE_TYPES);
                        byte convertKind = simpleTypeConversions[(int)ptSrc, (int)ptDest];

                        // identity conversion should have been handled at first.
                        DebugUtil.Assert(
                            (convertKind & SimpleTypeConversion.CONV_KIND_MASK)
                            != SimpleTypeConversion.CONV_KIND_ID);
                        // implicit conversion should have been handled earlier.
                        DebugUtil.Assert(
                            (convertKind & SimpleTypeConversion.CONV_KIND_MASK) != SimpleTypeConversion.CONV_KIND_IMP ||
                            wasEnum);

                        if ((convertKind & SimpleTypeConversion.CONV_KIND_MASK)
                                == SimpleTypeConversion.CONV_KIND_EXP ||
                            ((convertKind & SimpleTypeConversion.CONV_KIND_MASK)
                                == SimpleTypeConversion.CONV_KIND_IMP && wasEnum))
                        {
                            // An explicit conversion exists.

                            if (srcExpr != null && srcExpr.GetConst() != null)
                            {
                                // Fold the constant cast if possible.
                                bool checkFailure = true;
                                if (BindConstantCast(
                                    treeNode,
                                    srcExpr,
                                    oldDestTypeSym,
                                    ref destExpr,
                                    ref checkFailure))
                                {
                                    // else, don't fold and use a regular cast, below.
                                    return true;
                                }
                                if (checkFailure && (flags & ConvertTypeEnum.CHECKOVERFLOW) == 0)
                                {
                                    return false;
                                }
                            }

                            if ((convertKind & SimpleTypeConversion.CONV_KIND_USEUDC) != 0)
                            {
                                //if (!destExpr) return true;
                                if (srcExpr == null)
                                {
                                    return true;
                                }

                                // According the language, this is a standard conversion,
                                // but it is implemented through a user-defined conversion.
                                // Because it's a standard conversion,
                                // we don't test the ConvertTypeEnum.NOUDC flag here.

                                bool ok = BindUserDefinedConversion(
                                    treeNode,
                                    srcExpr,
                                    srcTypeSym,
                                    destTypeSym,
                                    ref destExpr,
                                    false);

                                // if we are converting Decimal to Enum,
                                // we just got a conversion from Decimal to underlying type,
                                // so we need to upcast to the Enum type

                                if (ok && oldDestAggSym.IsEnum)
                                {
                                    return BindSimpleCast(
                                        treeNode,
                                        destExpr,
                                        oldDestTypeSym,
                                        ref destExpr,
                                        0);
                                }
                                return ok;
                            }
                            else
                            {
                                return BindSimpleCast(
                                    treeNode,
                                    srcExpr,
                                    destTypeSym,
                                    ref destExpr,
                                    (flags & ConvertTypeEnum.CHECKOVERFLOW) != 0 ? EXPRFLAG.CHECKOVERFLOW : 0);
                            }
                        }
                        // No break here, continue testing for derived to base conversions below.
                    }

                    //------------------------------------------------
                    // AGGTYPESYM (5)
                    //------------------------------------------------
                    // Handle struct, class and interface conversions.
                    // A class, struct, or interface is explicity convertable to a derived class or interface.
                    if (srcTypeSym.IsAGGTYPESYM)
                    {
                        AGGSYM srcAggSym = (srcTypeSym as AGGTYPESYM).GetAggregate();

                        if (compiler.IsBaseType(destTypeSym as AGGTYPESYM, srcTypeSym as AGGTYPESYM))
                        {
                            if (destAggSym.IsStruct &&
                                srcAggSym.GetThisType().FundamentalType() == FUNDTYPE.REF)
                            {
                                return BindSimpleCast(
                                    treeNode,
                                    srcExpr,
                                    destTypeSym,
                                    ref destExpr, EXPRFLAG.UNBOX);
                            }
                            else
                            {
                                return BindSimpleCast(
                                    treeNode,
                                    srcExpr,
                                    destTypeSym,
                                    ref destExpr,
                                    EXPRFLAG.REFCHECK | (srcExpr != null ? (srcExpr.Flags & EXPRFLAG.CANTBENULL) : 0));
                            }
                        }

                        // A non-sealed class can cast to any interface, any interface can cast to a non-sealed class,
                        // and any interface can cast to any other interface.
                        if ((srcAggSym.IsClass && !srcAggSym.IsSealed && destAggSym.IsInterface) ||
                            (srcAggSym.IsInterface && destAggSym.IsClass && !destAggSym.IsSealed) ||
                            (srcAggSym.IsInterface && destAggSym.IsInterface))
                        {
                            return BindSimpleCast(
                                treeNode,
                                srcExpr,
                                destTypeSym,
                                ref destExpr,
                                EXPRFLAG.REFCHECK | (srcExpr != null ? (srcExpr.Flags & EXPRFLAG.CANTBENULL) : 0));
                        }
                    }

                    //------------------------------------------------
                    // AGGTYPESYM (6)
                    //------------------------------------------------
                    if (srcTypeSym.IsPTRSYM &&
                        destTypeSym.FundamentalType() <= FUNDTYPE.LASTINTEGRAL &&
                        destTypeSym.IsNumericType())
                    {
                        return BindSimpleCast(
                            treeNode,
                            srcExpr,
                            destTypeSym,
                            ref destExpr,
                            0);
                    }

                    //------------------------------------------------
                    // AGGTYPESYM (7)
                    //------------------------------------------------
                    if (srcTypeSym.IsVOIDSYM)
                    {
                        // No conversion is allowed to or from a void type (user defined or otherwise)
                        // This is most likely the result of a failed anonymous method or member group conversion
                        return false;
                    }

                    //------------------------------------------------
                    // AGGTYPESYM (8)
                    //------------------------------------------------
                    if (srcTypeSym.IsTYVARSYM && destAggSym.IsInterface)
                    {
                        // Explicit conversion of type variables to interfaces.
                        return BindSimpleCast(
                            treeNode,
                            srcExpr,
                            destTypeSym,
                            ref destExpr,
                            EXPRFLAG.FORCE_BOX | EXPRFLAG.REFCHECK);
                    }
                    break;
            } // switch (destTypeSym.Kind)

            // No built-in conversion was found. Maybe a user-defined conversion?
            if ((flags & ConvertTypeEnum.NOUDC) == 0)
            {
                return BindUserDefinedConversion(
                    treeNode,
                    srcExpr,
                    srcTypeSym,
                    destTypeSym,
                    ref destExpr,
                    false);
            }
            return false;
        }

        //--------------------------------------------------
        // FUNCBREC.CanConvert
        //
        /// <summary>
        /// returns true if an implicit conversion exists from source type to dest type.
        /// flags is an optional parameter (in sscli, default value 0).
        /// </summary>
        /// <param name="src"></param>
        /// <param name="dest"></param>
        /// <param name="flags"></param>
        //--------------------------------------------------
        private bool CanConvert(
            TYPESYM src,
            TYPESYM dest,
            ConvertTypeEnum flags) // = 0
        {
            DebugUtil.Assert(Compiler.CompilationPhase >= CompilerPhaseEnum.EvalConstants);
            EXPR tempExpr = null;
            return BindImplicitConversion(null, null, src, dest, ref tempExpr, flags);
        }

        //--------------------------------------------------
        // FUNCBREC.CanConvert
        //
        /// <summary>
        /// returns true if a implicit conversion exists from source expr to dest type.
        /// flags is an optional parameter.
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="dest"></param>
        /// <param name="flags"></param>
        //--------------------------------------------------
        private bool CanConvert(
            EXPR expr,
            TYPESYM dest,
            ConvertTypeEnum flags) // = 0
        {
            EXPR tempExpr = null;
            return BindImplicitConversion(null, expr, expr.TypeSym, dest, ref tempExpr, flags);
        }

        //--------------------------------------------------
        // FUNCBREC.MustConvertCore
        //
        /// <summary>
        /// <para>performs an implicit conversion if it's possible.
        /// otherwise displays an error.</para>
        /// <para>flags is an optional parameter, and its defalut value is 0.</para>
        /// </summary>
        //--------------------------------------------------
        private EXPR MustConvertCore(
            EXPR expr,
            TYPESYM destTypeSym,
            BASENODE treeNode,
            ConvertTypeEnum flags)    // = 0
        {
            EXPR exprResult = null;
            EXPR tempExpr = null;

            if (BindImplicitConversion(treeNode, expr, expr.TypeSym, destTypeSym, ref exprResult, flags))
            {
                // Conversion works.
                return exprResult;
            }

            if (expr.IsOK && !destTypeSym.IsERRORSYM)
            {
                // don't report cascading error.

                // For certain situations, try to give a better error.

                FUNDTYPE ftSrc = expr.TypeSym.FundamentalType();
                FUNDTYPE ftDest = destTypeSym.FundamentalType();

                if (expr.Kind == EXPRKIND.CONSTANT &&
                    expr.TypeSym.IsSimpleType() && destTypeSym.IsSimpleType())
                {
                    if ((ftSrc == FUNDTYPE.I4 && (ftDest <= FUNDTYPE.LASTNONLONG || ftDest == FUNDTYPE.U8)) ||
                        (ftSrc == FUNDTYPE.I8 && ftDest == FUNDTYPE.U8))
                    {
                        // Failed because value was out of range. Report nifty error message.
                        //WCHAR value[40];
                        //StringCchPrintfW (value, lengthof(value), L"%I64d", expr.AsCONSTANT.getI64Value());
                        string strValue = String.Format("{0}", (expr as EXPRCONSTANT).GetI64Value());
                        Compiler.Error(treeNode, CSCERRID.ERR_ConstOutOfRange, new ErrArg(strValue), new ErrArg(destTypeSym));
                        return NewError(treeNode, destTypeSym);
                    }
                    else if (
                        ftSrc == FUNDTYPE.R8 &&
                        ((expr.Flags & EXPRFLAG.LITERALCONST) != 0) &&
                        (destTypeSym.IsPredefType(PREDEFTYPE.FLOAT) || destTypeSym.IsPredefType(PREDEFTYPE.DECIMAL)))
                    {
                        // Tried to assign a literal of type double (the default) to a float or decimal. Suggest use
                        // of a 'F' or 'M' suffix.
                        Compiler.Error(treeNode, CSCERRID.ERR_LiteralDoubleCast,
                            new ErrArg((destTypeSym.IsPredefType(PREDEFTYPE.DECIMAL) ? "M" : "F")),
                            new ErrArg(destTypeSym));
                        return NewError(treeNode, destTypeSym);
                    }
                }

                if (expr.TypeSym.IsNULLSYM && destTypeSym.FundamentalType() != FUNDTYPE.REF)
                {
                    Compiler.Error(
                        treeNode,
                        destTypeSym.IsTYVARSYM ? CSCERRID.ERR_TypeVarCantBeNull : CSCERRID.ERR_ValueCantBeNull,
                        new ErrArg(destTypeSym));
                }
                else if (expr.Kind == EXPRKIND.MEMGRP)
                {
                    BindGrpConversion(treeNode, expr as EXPRMEMGRP, destTypeSym, ref tempExpr, true);
                }
                else if (expr.TypeSym.IsANONMETHSYM)
                {
                    BindAnonMethConversion(treeNode, expr, destTypeSym, ref tempExpr, true);
                }
                else if (CanCast(expr.TypeSym, destTypeSym, flags))
                {
                    // can't convert, but explicit exists.
                    Compiler.Error(
                        treeNode,
                        CSCERRID.ERR_NoImplicitConvCast,
                        new ErrArg(expr.TypeSym, ErrArgFlagsEnum.Unique),
                        new ErrArg(destTypeSym, ErrArgFlagsEnum.Unique));
                }
                else
                {
                    // Generic "can't convert" error.
                    Compiler.Error(
                        treeNode,
                        CSCERRID.ERR_NoImplicitConv,
                        new ErrArg(expr.TypeSym, ErrArgFlagsEnum.Unique),
                        new ErrArg(destTypeSym, ErrArgFlagsEnum.Unique));
                }
            }

            return NewError(treeNode, destTypeSym);
        }

        //--------------------------------------------------
        // FUNCBREC.MustConvert
        //
        /// <summary>
        /// <para>(flags has default value 0 in sscli.)</para>
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="dest"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR MustConvert(
            EXPR expr,
            TYPESYM dest,
            ConvertTypeEnum flags) // = 0
        {
            return MustConvertCore(expr, dest, expr.TreeNode, flags);
        }

        //--------------------------------------------------
        // FUNCBREC.TryConvert
        //
        /// <summary>
        /// <para>performs an implicit conversion if its possible. otherwise returns null.</para>
        /// <para>flags is an optional parameter (in sscli, default value 0).</para>
        /// <para>Only call this if you are ALWAYS going to use the returned result
        /// (and you're not just going to test and possibly throw away the result)</para>
        /// <para>If the conversion is possible it will modify an Anonymous Method expr thus changing results of
        /// future conversions.  It will also produce possible binding errors for method goups.</para>
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="dest"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR TryConvert(
            EXPR expr,
            TYPESYM dest,
            ConvertTypeEnum flags) // = 0
        {
            EXPR exprResult = null;

            if (BindImplicitConversion(expr.TreeNode, expr, expr.TypeSym, dest, ref exprResult, flags))
            {
                // Conversion works.
                return exprResult;
            }

            return null;
        }

        //--------------------------------------------------
        // FUNCBREC.CanCast
        //
        /// <summary>
        /// returns true if an explicit conversion exists from source type to dest type.
        /// flags is an optional parameter.
        /// </summary>
        /// <param name="src"></param>
        /// <param name="dest"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool CanCast(
            TYPESYM src,
            TYPESYM dest,
            ConvertTypeEnum flags) // = 0
        {
            EXPR tempExpr = null;
            return BindExplicitConversion(null, null, src, dest, ref tempExpr, flags);
        }

        //--------------------------------------------------
        // FUNCBREC.CanCast
        //
        /// <summary>
        /// returns true if a explicit conversion exists from source expr to dest type.
        /// flags is an optional parameter.
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="dest"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool CanCast(
            EXPR expr,
            TYPESYM dest,
            ConvertTypeEnum flags) // = 0
        {
            EXPR tempExpr = null;
            return BindExplicitConversion(null, expr, expr.TypeSym, dest, ref tempExpr, flags);
        }

        //--------------------------------------------------
        // FUNCBREC.mustCastCore
        //
        /// <summary>
        /// <para>performs an explicit conversion if its possible.
        /// otherwise displays an error. flags is an optional parameter.</para>
        /// <para>(In sscli, flags has the default value 0.)</para>
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="destTypeSym"></param>
        /// <param name="treeNode"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR MustCastCore(
            EXPR expr,
            TYPESYM destTypeSym,
            BASENODE treeNode,
            ConvertTypeEnum flags) //  = 0
        {
            EXPR resultExpr = null;
            EXPR tempExpr = null;

            Compiler.CheckForStaticClass(treeNode, null, destTypeSym, CSCERRID.ERR_ConvertToStaticClass);

            if (BindExplicitConversion(treeNode, expr, expr.TypeSym, destTypeSym, ref resultExpr, flags))
            {
                // Conversion works.
                return resultExpr;
            }

            if (expr.IsOK && destTypeSym != null && !destTypeSym.IsERRORSYM)
            {
                // don't report cascading error.
                // For certain situations, try to give a better error.

                EXPR constExpr = expr.GetConst();
                if (constExpr != null && this.CheckedContext.IsConstant &&
                    expr.TypeSym.IsSimpleType() && (destTypeSym.IsSimpleType() || destTypeSym.IsEnumType()))
                {
                    // check if we failed because we are in chec^ked mode...
                    CHECKEDCONTEXT tempContext = new CHECKEDCONTEXT(this, false);
                    bool okNow = BindExplicitConversion(
                        treeNode,
                        expr,
                        expr.TypeSym,
                        destTypeSym,
                        ref tempExpr,	// null,
                        flags | ConvertTypeEnum.NOUDC);
                    tempContext.Restore(this);

                    if (!okNow) goto CANTCONVERT;

                    // Failed because value was out of range. Report nifty error message.
                    //HRESULT hr = E_FAIL;
                    //WCHAR value[256];
                    string formatted = null;
                    if (expr.TypeSym.FundamentalType() <= FUNDTYPE.LASTINTEGRAL)
                    {
                        if (expr.TypeSym.IsUnsigned())
                        {
                            //hr = StringCchPrintfW (value, lengthof(value), L"%I64u", constExpr.AsCONSTANT.getI64Value());
                            formatted = String.Format("{0}", (constExpr as EXPRCONSTANT).ConstVal.GetULong());
                        }
                        else
                        {
                            //hr = StringCchPrintfW (value, lengthof(value), L"%I64d", constExpr.AsCONSTANT.getI64Value());
                            formatted = String.Format("{0}", (constExpr as EXPRCONSTANT).ConstVal.GetLong());
                        }
                    }
                    else
                    {
                        //hr = StringCchPrintfW (value, lengthof(value), L"%g", *(constExpr.AsCONSTANT.getVal().doubleVal));
                        formatted = String.Format("{0}", (constExpr as EXPRCONSTANT).ConstVal.GetDouble());
                    }
                    //DebugUtil.Assert  (SUCCEEDED (hr));

                    Compiler.Error(treeNode, CSCERRID.ERR_ConstOutOfRangeChecked,
                        new ErrArg(formatted), new ErrArg(destTypeSym));
                }
                else if (expr.TypeSym.IsNULLSYM && destTypeSym.FundamentalType() != FUNDTYPE.REF)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_ValueCantBeNull, new ErrArg(destTypeSym));
                }
                else if (expr.Kind == EXPRKIND.MEMGRP)
                {
                    BindGrpConversion(treeNode, expr as EXPRMEMGRP, destTypeSym, ref tempExpr, true);
                }
                else if (expr.TypeSym.IsANONMETHSYM)
                {
                    BindAnonMethConversion(treeNode, expr, destTypeSym, ref tempExpr, true);
                }
                else
                {
                    goto CANTCONVERT;
                }
            }

            return NewError(treeNode, destTypeSym);

        CANTCONVERT:
            // Generic "can't convert" error.
            Compiler.Error(treeNode, CSCERRID.ERR_NoExplicitConv,
                new ErrArg(expr.TypeSym, ErrArgFlagsEnum.Unique),
                new ErrArg(destTypeSym, ErrArgFlagsEnum.Unique));

            return NewError(treeNode, destTypeSym);
        }

        //--------------------------------------------------
        // FUNCBREC.MustCast
        //
        /// <summary></summary>
        /// <param name="expr"></param>
        /// <param name="dest"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR MustCast(
            EXPR expr,
            TYPESYM dest,
            ConvertTypeEnum flags)  // = 0
        {
            return MustCastCore(expr, dest, expr.TreeNode, flags);
        }

        //--------------------------------------------------
        // FUNCBREC.tryCast
        //
        //// performs an explicit conversion if its possible. otherwise returns null. flags is an optional parameter.
        //// Only call this if you are ALWAYS going to use the returned result (and you're not just going to test and
        //// possibly throw away the result)
        //// If the conversion is possible it will modify an Anonymous Method expr thus changing results of
        //// future conversions.  It will also produce possible binding errors for method goups.
        //--------------------------------------------------
        //private    EXPR *      tryCast(EXPR * expr, TYPESYM * dest, BASENODE * tree, unsigned flags = 0);
        //EXPR * FUNCBREC::tryCast(EXPR * expr, TYPESYM * dest, BASENODE * tree, unsigned flags)
        //{
        //    EXPR * exprResult;
        //
        //    if (bindExplicitConversion(tree, expr, expr->type, dest, &exprResult, flags)) {
        //        // Conversion works.
        //        return exprResult;
        //    }
        //
        //    return NULL;
        //}

        // Determine whether this is an implicit/explicit reference conversion from typeSrc to typeDst.

        //--------------------------------------------------
        // FUNCBREC.FImpRefConv
        //
        /// <summary>
        /// Determine whether there is an implicit reference conversion from typeSrc to typeDst. This is
        /// when the source is a reference type and the destination is a base type of the source. Note
        /// that typeDst->IsRefType() may still return false (when both are type parameters).
        /// </summary>
        /// <param name="typeSrc"></param>
        /// <param name="typeDst"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool FImpRefConv(TYPESYM typeSrc, TYPESYM typeDst)
        {
            return typeSrc.IsReferenceType() && Compiler.IsBaseType(typeSrc, typeDst);
        }

        //--------------------------------------------------
        // FUNCBREC.FExpRefConv
        //
        /// <summary>
        /// <para>Determine whether there is an explicit or implicit reference conversion (or identity conversion)
        /// from typeSrc to typeDst. This is when:</para>
        /// <list type="bullet">
        /// <item>Both src and dst are reference types and
        /// there is a builtin explicit conversion from src to dst.</item>
        /// <item>Or src is a reference type and dst is a base type of src
        /// (in which case the conversion is implicit as well).</item>
        /// <item>Or dst is a reference type and src is a base type of dst.</item>
        /// </list>
        /// <para>The latter two cases can happen with type variables even though the other type variable is not
        /// a reference type.</para>
        /// </summary>
        /// <param name="typeSrc"></param>
        /// <param name="typeDst"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool FExpRefConv(TYPESYM typeSrc, TYPESYM typeDst)
        {
            if (typeSrc.IsReferenceType())
            {
                if (typeDst.IsReferenceType())
                {
                    return CanCast(typeSrc, typeDst, ConvertTypeEnum.NOUDC);
                }
                return Compiler.IsBaseType(typeSrc, typeDst);
            }
            return typeDst.IsReferenceType() && Compiler.IsBaseType(typeDst, typeSrc);
        }

        //--------------------------------------------------
        // FUNCBREC.FIsSameType
        //
        /// <summary>
        /// Determine whether two types are the same type.
        /// Always returns false if the types are error, anonymous method, or method group
        /// </summary>
        /// <param name="typeSrc"></param>
        /// <param name="typeDst"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool FIsSameType(TYPESYM typeSrc, TYPESYM typeDst)
        {
            return typeSrc == typeDst && !typeSrc.IsNeverSameType();
        }

        //--------------------------------------------------
        // FUNCBREC.FBoxingConv
        //
        /// <summary>
        /// Determines whether there is a boxing conversion from typeSrc to typeDest
        /// </summary>
        /// <param name="typeSrc"></param>
        /// <param name="typeDst"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool FBoxingConv(TYPESYM typeSrc, TYPESYM typeDst)
        {
            return
                (typeSrc.IsValueType() || (typeSrc.IsTYVARSYM && !typeSrc.IsReferenceType())) &&
                typeDst.IsReferenceType() &&
                CanConvert(typeSrc, typeDst, ConvertTypeEnum.NOUDC);
        }

        //--------------------------------------------------
        // FUNCBREC.FUnboxingConv
        //
        /// <summary>
        /// Determines whether there is an unboxing conversion from typeSrc to typeDest
        /// </summary>
        /// <param name="typeSrc"></param>
        /// <param name="typeDst"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool FUnboxingConv(TYPESYM typeSrc, TYPESYM typeDst)
        {
            return FBoxingConv(typeDst, typeSrc);
        }

        //--------------------------------------------------
        // FUNCBREC.FUnwrappingConv
        //
        /// <summary>
        /// <para>Determines whether there is a wrapping conversion from typeSrc to typeDest</para>
        /// <para>True if typeDst represents a nullable type and typeSrc is its base type.
        /// (base types of nullable types is their parents.)</para>
        /// </summary>
        //--------------------------------------------------
        private bool FWrappingConv(TYPESYM typeSrc, TYPESYM typeDst)
        {
            return typeDst.IsNUBSYM && typeSrc == (typeDst as NUBSYM).BaseTypeSym;
        }

        //--------------------------------------------------
        // FUNCBREC.FUnwrappingConv
        //
        /// <summary>
        /// <para>Determines whether there is a unwrapping conversion from typeSrc to typeDest</para>
        /// <para>True if typeSrc represents a nullable type and typeDst is its base type.
        /// (base types of nullable types is their parents.)</para>
        /// </summary>
        /// <param name="typeSrc"></param>
        /// <param name="typeDst"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool FUnwrappingConv(TYPESYM typeSrc, TYPESYM typeDst)
        {
            return FWrappingConv(typeDst, typeSrc);
        }

        //--------------------------------------------------
        // FUNCBREC.BindBlock
        //
        /// <summary>
        /// Bind the given block by binding its statement list..
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="scopeFlags"></param>
        /// <param name="scopeSym"></param>
        /// <param name="existingScopeSym"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRBLOCK BindBlock(
            BASENODE treeNode,
            SCOPEFLAGS scopeFlags,		// = SCOPEFLAGS.NONE,
            ref SCOPESYM scopeSym,
            SCOPESYM existingScopeSym)	// = null
        {
            if (existingScopeSym == null)
            {
                CreateNewScope();
            }
            scopeSym = this.currentScopeSym;
            this.currentScopeSym.ScopeFlags = scopeFlags;

            SCOPESYM oldScopeSym = null;
            bool saveScope = false;

            this.currentBlockExpr = NewExprBlock(treeNode);
            this.currentBlockExpr.ScopeSym = this.currentScopeSym;

            // Save the SCOPESYM instance to oldScopeSym
            switch (scopeFlags & SCOPEFLAGS.KINDMASK)
            {
                case SCOPEFLAGS.CATCHSCOPE:
                    oldScopeSym = this.innermostCatchScopeSym;
                    this.innermostCatchScopeSym = this.currentScopeSym;
                    saveScope = true;
                    break;

                case SCOPEFLAGS.TRYSCOPE:
                    oldScopeSym = this.innermostTryScopeSym;
                    this.innermostTryScopeSym = this.currentScopeSym;
                    saveScope = true;
                    break;

                case SCOPEFLAGS.FINALLYSCOPE:
                    oldScopeSym = this.innermostFinallyScopeSym;
                    this.innermostFinallyScopeSym = this.currentScopeSym;
                    saveScope = true;
                    this.currentScopeSym.BlockExpr = this.currentBlockExpr;
                    break;

                case SCOPEFLAGS.SWITCHSCOPE:
                    oldScopeSym = this.innermostSwitchScopeSym;
                    this.innermostSwitchScopeSym = this.currentScopeSym;
                    saveScope = true;
                    break;

                case SCOPEFLAGS.NONE:
                    break;

                default:
                    DebugUtil.Assert(false, "bad sf type");
                    break;
            }

            // processed in switch statement above.

            STATEMENTNODE stms = treeNode.Kind == NODEKIND.BLOCK ?
                (treeNode as BLOCKNODE).StatementsNode :
                treeNode.AsANYSTATEMENT;

            StatementListBuilder builder = new StatementListBuilder();

            //--------------------------------------------------------
            // process each statement.
            //--------------------------------------------------------
            while (stms != null)
            {
                BindStatement(stms, builder);
                stms = stms.NextStatementNode;
            }

            this.currentBlockExpr.StatementsExpr = builder.GetList();
            EXPRBLOCK rval = this.currentBlockExpr;
            this.currentBlockExpr = rval.OwingBlockExpr;

            CloseScope();

            // Restore the saved SCOPESYM instace.
            if (saveScope)
            {
                switch (scopeFlags & SCOPEFLAGS.KINDMASK)
                {
                    case SCOPEFLAGS.CATCHSCOPE:
                        this.innermostCatchScopeSym = oldScopeSym;
                        break;

                    case SCOPEFLAGS.TRYSCOPE:
                        this.innermostTryScopeSym = oldScopeSym;
                        break;

                    case SCOPEFLAGS.FINALLYSCOPE:
                        this.innermostFinallyScopeSym = oldScopeSym;
                        break;

                    case SCOPEFLAGS.SWITCHSCOPE:
                        this.innermostSwitchScopeSym = oldScopeSym;
                        break;

                    case SCOPEFLAGS.NONE:
                        break;

                    default:
                        DebugUtil.Assert(false, "bad sf type");
                        break;
                }
            }

            SetNodeExpr(treeNode, rval);
            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.BindStatement
        //
        /// <summary>
        /// Bind an individial statement
        /// </summary>
        /// <param name="statementNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindStatement(
            STATEMENTNODE statementNode,
            StatementListBuilder builder)
        {
#if DEBUG
            int debug_NodeID = statementNode.NodeID;
#endif
            if (this.bindCallback.IsStartStatementNode(statementNode))
            {
                EXPRDELIM delim = NewExprDelim(statementNode, DELIMKIND.START);
                builder.Add(delim);
                bindCallback.DelimCreated(delim);
            }

            StatementListBuilder oldIniBuilder1 = this.initializerBuilder1;
            StatementListBuilder oldIniBuilder2 = this.initializerBuilder2;

            try
            {
                // (CS3) process the initializers.
                if (statementNode.HasObjectInitializer ||
                    statementNode.HasCollectionInitializer)
                {
                    this.initializerBuilder1 = new StatementListBuilder();
                    this.initializerBuilder2 = new StatementListBuilder();
                }
                else
                {
                    this.initializerBuilder1 = null;
                    this.initializerBuilder2 = null;
                }

                StatementListBuilder currentBuilder = new StatementListBuilder();
                BindStatementWorker(statementNode, currentBuilder);
                EXPRSTMT currentStmt = currentBuilder.GetList();
#if DEBUG
                StringBuilder sb = new StringBuilder();
                DebugUtil.DebugSymsOutput(sb);
                sb.Length = 0;
                DebugUtil.DebugExprsOutput(sb);
#endif
                // (CS3) Initializer
                if (this.initializerBuilder1 != null)
                {
                    builder.Add(this.initializerBuilder1.GetList());
                }

                //builder.Add(currentBuilder.GetList());

                // (CS4) RuntimeBinding
                if (this.FoundRuntimeBindedObject())
                {
                    ConvertToRuntimeBindedStatement(currentStmt, builder);
                    this.ResetDynamicObjectCount();
                }
                else
                {
                    builder.Add(currentStmt);
                }

                // (CS3) Initializer
                if (this.initializerBuilder2 != null)
                {
                    builder.Add(this.initializerBuilder2.GetList());
                }
            }
            finally
            {
                this.initializerBuilder1 = oldIniBuilder1;
                this.initializerBuilder2 = oldIniBuilder2;
            }

            if (bindCallback.IsEndStatementNode(statementNode))
            {
                EXPRDELIM delim = NewExprDelim(statementNode, DELIMKIND.END);
                builder.Add(delim);
                bindCallback.DelimCreated(delim);
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindStatementWorker
        //
        /// <summary></summary>
        /// <param name="statementNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindStatementWorker(
            STATEMENTNODE statementNode,
            StatementListBuilder builder)
        {
            BASENODE treeNode = statementNode;
            EXPR rval;
            SCOPESYM scopeSym = null;   // dummy

            Compiler.SetLocation(statementNode);   //SETLOCATIONNODE(statementNode);

            //  give one error per statement at most...
            this.unsafeErrorGiven = false;

        AGAIN:
            if (treeNode == null)
            {
                return;
            }

#if DEBUG
            POSDATA pd = new POSDATA();
            {
                if (treeNode != null)
                {
                    if (this.methodSym != null)
                    {
                        pd = this.methodSym.GetInputFile().SourceData.GetSingleTokenPos(treeNode.TokenIndex);
                    }
                    else if (this.currentFieldSym != null)
                    {
                        pd = this.currentFieldSym.GetInputFile().SourceData.GetSingleTokenPos(treeNode.TokenIndex);
                    }
                }
            }

            int debug_NodeID = treeNode.NodeID;
            if (treeNode.NodeID == 7459)
            {
                ;
            }
#endif

            // Anonymous methods and iterators don't like locals in scopes that
            // don't belong to blocks. We have an assert in declareVar, but we
            // want this one here to catch more cases.
            DebugUtil.Assert(this.currentScopeSym == this.currentBlockExpr.ScopeSym);
            this.lastNode = statementNode;

            switch (treeNode.Kind)
            {
                case NODEKIND.BLOCK:
                    builder.Add(BindBlock(
                        treeNode as BLOCKNODE,
                        SCOPEFLAGS.NONE,
                        ref scopeSym,
                        null));
                    return;

                case NODEKIND.LABEL:
                    BindLabel(treeNode as LABELSTMTNODE, builder);
                    return;

                case NODEKIND.UNSAFE:
                    BindUnsafe(treeNode.AsUNSAFE, builder);
                    return;

                case NODEKIND.CHECKED:
                    BindChecked(treeNode.AsCHECKED, builder);
                    return;

                case NODEKIND.EMPTYSTMT:
                    return;

                default:
                    break;
            }

            switch (treeNode.Kind)
            {
                default:
                    // This expression is not a legal statement.
                    Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    // We call bindExpr for refactoring and error reporting.
                    rval = BindExpr(treeNode,BindFlagsEnum.RValueRequired);
                    return;

                case NODEKIND.NAME:
                case NODEKIND.GENERICNAME:
                case NODEKIND.DOT:
                case NODEKIND.OP:
                case NODEKIND.CALL:
                case NODEKIND.DEREF:
                case NODEKIND.BINOP:
                case NODEKIND.UNOP:
                case NODEKIND.NEW:
                    rval = BindExpr(
                        treeNode,
                        BindFlagsEnum.RValueRequired| BindFlagsEnum.StatementExpressionOnly);
                    builder.Add(SetNodeStmt(statementNode, MakeStmt(statementNode, rval, 0)));
                    return;

                case NODEKIND.EXPRSTMT:
                    treeNode = (treeNode as EXPRSTMTNODE).ArgumentsNode;
                    goto AGAIN;

                case NODEKIND.BREAK:
                    BindBreakOrContinue(treeNode, true, builder);
                    return;

                case NODEKIND.CONTINUE:
                    BindBreakOrContinue(treeNode, false, builder);
                    return;

                case NODEKIND.YIELD:
                    BindYield(treeNode.AsYIELD, builder);
                    return;

                case NODEKIND.RETURN:
                    BindReturn(treeNode.AsRETURN, builder);
                    return;

                case NODEKIND.DECLSTMT:
                    BindVarDecls(treeNode as DECLSTMTNODE, builder, false);
                    return;

                case NODEKIND.IF:
                    BindIf(treeNode as IFSTMTNODE, builder);
                    return;

                case NODEKIND.DO:
                    BindWhileOrDo(treeNode.AsDO, false, builder);
                    return;

                case NODEKIND.WHILE:
                    BindWhileOrDo(treeNode.AsWHILE, true, builder);
                    return;

                case NODEKIND.FOR:
                    BindFor(treeNode as FORSTMTNODE, builder);
                    return;

                case NODEKIND.GOTO:
                    BindGoto(treeNode.AsGOTO, builder);
                    return;

                case NODEKIND.SWITCH:
                    BindSwitch(treeNode as SWITCHSTMTNODE, builder);
                    return;

                case NODEKIND.TRY:
                    BindTry(treeNode as TRYSTMTNODE, builder);
                    return;

                case NODEKIND.THROW:
                    BindThrow(treeNode.AsTHROW, builder);
                    return;

                case NODEKIND.LOCK:
                    BindLock(treeNode.AsLOCK, builder);
                    return;
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindExpr
        //
        /// <summary>
        /// <para>Bind the expression</para>
        /// <para>bindFlags has default value BindFlagsEnum.RValueRequired</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindExpr(
            BASENODE treeNode,
            BindFlagsEnum bindFlags)	// = BindFlagsEnum.RValueRequired
        {
#if DEBUG
            POSDATA pd;
            {
                if (treeNode != null && this.parentDeclSym != null)
                {
                    pd = this.parentDeclSym.GetInputFile().SourceData.GetSingleTokenPos(treeNode.TokenIndex);
                }
            }
#endif

            if (treeNode == null)
            {
                return null;
            }
#if DEBUG
            if (treeNode.NodeID == 28108)
            {
                ;
            }
#endif
            // Remember if we are restriction to statement-expressions only.
            // Don't propagate this value to sub-expressions.
            SYMBMASK typesMask = 0;
            SYMBMASK methodMask = SYMBMASK.METHSYM;
            DebugUtil.Assert((bindFlags & (BindFlagsEnum.MethodNotOk | BindFlagsEnum.TypeOk)) == 0);
            bool stmtExprOnly = ((bindFlags & BindFlagsEnum.StatementExpressionOnly) != 0);
            bindFlags &= ~BindFlagsEnum.StatementExpressionOnly;

            lastNode = treeNode;

            NODEFLAGS mods = treeNode.Flags & (NODEFLAGS.PARMMOD_REF | NODEFLAGS.PARMMOD_OUT);
            TYPESYM typeSym;

            if ((mods & NODEFLAGS.PARMMOD_OUT) != 0)
            {
                bindFlags &= ~BindFlagsEnum.RValueRequired;
                bindFlags |= BindFlagsEnum.MemberSet;
            }

            EXPR rval;
            switch (treeNode.Kind)
            {
                case NODEKIND.ANONBLOCK:
                    if (stmtExprOnly)
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    }
                    rval = BindAnonymousMethod(treeNode as ANONBLOCKNODE);
                    break;

                case NODEKIND.LAMBDAEXPR:  // CS3
                    if (stmtExprOnly)
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    }
                    rval = BindLambdaExpression(treeNode as LAMBDAEXPRNODE, null);
                    break;

                case NODEKIND.NEW:
                    rval = BindNew(treeNode as NEWNODE, stmtExprOnly);
                    break;

                case NODEKIND.CONSTVAL:
                    if (stmtExprOnly)
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    }
                    CONSTVAL val = (treeNode as CONSTVALNODE).Value;
                    typeSym = this.GetOptionalPredefinedType(treeNode.PredefinedType);
                    if (typeSym == null) // decimal could be missing
                    {
                        return NewError(treeNode, null);
                    }
                    rval = NewExprConstant(treeNode, typeSym, val);
                    rval.Flags |= EXPRFLAG.LITERALCONST;
                    break;

                case NODEKIND.CALL:
                case NODEKIND.DEREF:
                case NODEKIND.BINOP:
                    if (stmtExprOnly && !opCanBeStatement[(int)treeNode.Operator])
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    }
                    rval = BindBinOp(treeNode.AsANYBINOP, bindFlags);
                    break;

                case NODEKIND.UNOP:
                    if (stmtExprOnly && !opCanBeStatement[(int)treeNode.Operator])
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    }
                    rval = BindUnop(treeNode as UNOPNODE, bindFlags);
                    break;

                case NODEKIND.LIST:
                    rval = null;
                    EXPR last = null;
                    if (stmtExprOnly)
                    {
                        bindFlags |= BindFlagsEnum.StatementExpressionOnly;
                    }
                    BASENODE node = treeNode;
                    while (node != null)
                    {
                        BASENODE elem;
                        if (node.Kind == NODEKIND.LIST)
                        {
                            elem = node.AsLIST.Operand1.AsBASE;
                            node = node.AsLIST.Operand2;
                        }
                        else
                        {
                            elem = node.AsBASE;
                            node = null;
                        }
                        EXPR item = BindExpr(elem, bindFlags);
                        NewList(item, ref rval, ref last);
                    }
                    break;

                case NODEKIND.GENERICNAME:
                case NODEKIND.NAME:
                    if (stmtExprOnly)
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    }
                    rval = BindName(
                        treeNode.AsANYNAME,
                        SYMBMASK.LOCVARSYM | SYMBMASK.MEMBVARSYM | SYMBMASK.PROPSYM |
                            typesMask | methodMask,
                        bindFlags);
                    // since we could have bound to a constant expression, we do not
                    // mark this as an lvalue here, but rather let bindName do it...
                    break;

                case NODEKIND.ALIASNAME:
                    if (stmtExprOnly)
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    }
                    rval = BindAliasName(treeNode.AsALIASNAME);
                    break;

                case NODEKIND.DOT:
                    if (stmtExprOnly)
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    }
                    rval = BindDot(
                        treeNode.AsDOT,
                        SYMBMASK.MEMBVARSYM | SYMBMASK.PROPSYM | typesMask | methodMask,
                        bindFlags);
                    break;

                case NODEKIND.ARRAYINIT:
                    Compiler.Error(treeNode, CSCERRID.ERR_ArrayInitInBadPlace);
                    BindArrayInit(
                        treeNode.AsARRAYINIT,
                        Compiler.MainSymbolManager.GetArray(this.GetRequiredPredefinedType(PREDEFTYPE.OBJECT), 1, null),
                        null);
                    rval = NewError(treeNode, null);
                    break;

                case NODEKIND.OP:
                    if (stmtExprOnly && !opCanBeStatement[(int)treeNode.Operator])
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    }

                    switch (treeNode.Operator)
                    {
                        case OPERATOR.NULL:
                            rval = BindNull(treeNode);
                            break;

                        case OPERATOR.TRUE:
                        case OPERATOR.FALSE:
                            rval = NewExprConstant(
                                treeNode,
                                this.GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                                new ConstValInit(treeNode.Operator == OPERATOR.TRUE));
                            rval.Flags |= EXPRFLAG.LITERALCONST;
                            break;

                        case OPERATOR.THIS:
                            rval = BindThisExplicit(treeNode);
                            break;

                        case OPERATOR.ARGS:
                            if (this.methodSym != null && this.methodSym.IsVarargs)
                            {
                                AGGTYPESYM atsArgHandle = this.GetOptionalPredefinedType(PREDEFTYPE.ARGUMENTHANDLE);
                                if (atsArgHandle != null)
                                {
                                    rval = NewExprBinop(treeNode, EXPRKIND.ARGS, atsArgHandle, null, null);
                                }
                                else
                                {
                                    rval = NewError(treeNode, null);
                                }
                            }
                            else
                            {
                                Compiler.Error(treeNode, CSCERRID.ERR_ArgsInvalid);
                                rval = NewError(treeNode, this.GetOptionalPredefinedType(PREDEFTYPE.ARGUMENTHANDLE));
                            }
                            break;

                        case OPERATOR.BASE:
                            Compiler.Error(treeNode, CSCERRID.ERR_BaseIllegal);
                            rval = NewError(treeNode, null);
                            break;

                        default:
                            DebugUtil.Assert(Compiler.ErrorCount() > 0);
                            rval = NewError(treeNode, null);
                            break;
                    }
                    break;

                case NODEKIND.PREDEFINEDTYPE:
                case NODEKIND.ARRAYTYPE:
                case NODEKIND.POINTERTYPE:
                case NODEKIND.NULLABLETYPE:
                case NODEKIND.NAMEDTYPE:
                    typeSym = BindType(treeNode.AsANYTYPE);
                    DebugUtil.Assert(typeSym != null);
                    rval = NewExpr(treeNode, EXPRKIND.CLASS, typeSym);
                    break;

                case NODEKIND.ARROW:
                    if (stmtExprOnly)
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IllegalStatement);
                    }
                    rval = BindDot(
                        treeNode.AsARROW,
                        SYMBMASK.MEMBVARSYM | SYMBMASK.PROPSYM | methodMask,
                        bindFlags);
                    break;

                case NODEKIND.QUERYEXPR:    // CS3
                    rval = BindQueryExpression(treeNode as QUERYEXPRNODE, bindFlags);
                    break;

                default:
                    DebugUtil.Assert(Compiler.ErrorCount() == 0, "unknown expression");
                    return NewError(treeNode, null);
            }

            if (mods != 0)
            {
                if (!CheckLvalue(rval, false))
                {
                    return SetNodeExpr(treeNode, rval.IsOK ? NewError(treeNode, rval.TypeSym) : rval);
                }

                // do not give this error if we also failed the lvalue check...
                if (rval.Kind == EXPRKIND.PROP && (rval.Flags & EXPRFLAG.LVALUE) != 0)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_RefProperty);
                }
                CheckFieldRef(rval);
                NoteReference(rval);
                rval.TypeSym = Compiler.MainSymbolManager.GetParamModifier(rval.TypeSym, (mods & NODEFLAGS.PARMMOD_OUT) != 0);
            }

            if (rval.TypeSym != null)
            {
                CheckUnsafe(treeNode, rval.TypeSym, CSCERRID.ERR_UnsafeNeeded, null);
                Compiler.EnsureState(rval.TypeSym, AggStateEnum.Prepared);
            }

            return SetNodeExpr(treeNode, rval);
        }

        //--------------------------------------------------
        // FUNCBREC.bindThisCore
        //
        /// <summary>
        /// <para>Return an expression that refers to the this pointer.
        /// Returns null if no this is available.</para>
        /// <para>See bindThis is error reporting is required.</para>
        /// <para>If this is an anonymous method in the EE,
        /// then bindThisCore will return an expr which corresponds to the field
        /// which holds the semantically correct this pointer, not the real this pointer</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindThisCore(BASENODE treeNode, EXPRFLAG flags)
        {
            if (this.thisPointerSym == null)
            {
                return null;
            }

            AGGSYM root = this.parentAggSym;

            if (this.currentAnonymousMethodInfo != null && root.IsStruct)
            {
                // Anonymous methods cannot access the 'this' pointer inside structs
                return null;
            }

            return BindRealThis(treeNode, flags);
        }

        //--------------------------------------------------
        // FUNCBREC.bindRealThis
        //
        /// <summary>
        /// <para>Binds the actual this pointer of the method.</para>
        /// <para>In the EE this always returns the runtime this pointer,
        /// even in the case of anonymous methods</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindRealThis(BASENODE treeNode, EXPRFLAG flags)
        {
            LOCVARSYM relevantThisPointer = this.thisPointerSym;
            if (relevantThisPointer == null)
            {
                return null;
            }

            TYPESYM thisTypeSym = this.parentAggSym.GetThisType();
            if (this.parentAggSym.IsPredefAgg(PREDEFTYPE.G_OPTIONAL))   // System.Nullable
            {
                thisTypeSym = Compiler.MainSymbolManager.GetNubFromNullable(thisTypeSym as AGGTYPESYM);
            }

            EXPR thisExpr = NewExprCore(treeNode, EXPRKIND.LOCAL, thisTypeSym, flags, EXPRKIND.LOCAL);
            (thisExpr as EXPRLOCAL).LocVarSym = relevantThisPointer;
            if (this.parentAggSym.IsStruct)
            {
                thisExpr.Flags |= EXPRFLAG.LVALUE;
            }

            if (this.currentAnonymousMethodInfo != null)
            {
                EXPRLOCAL localExpr = thisExpr as EXPRLOCAL;
                localExpr.LocVarSym.UsedInAnonMeth = true;
                if (localExpr.LocVarSym.NodeUsedInAnonMethod == null)
                {
                    localExpr.LocVarSym.NodeUsedInAnonMethod = treeNode;
                }
            }

            return thisExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindThisImplicit
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindThisImplicit(BASENODE tree)
        {
            return BindThisCore(tree, EXPRFLAG.IMPLICITTHIS | EXPRFLAG.CANTBENULL);
        }

        //--------------------------------------------------
        // FUNCBREC.bindThisExplicit
        //
        /// <summary>
        /// Return an expression that refers to the this pointer.
        /// Prints appropriate error if this is not available.
        /// See bindThisExpr if no error is desired.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindThisExplicit(BASENODE treeNode)
        {
            EXPR thisExpr = BindThisCore(treeNode, EXPRFLAG.CANTBENULL);

            if (thisExpr == null)
            {
                if (this.methodSym != null && this.methodSym.IsStatic)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_ThisInStaticMeth);
                }
                else if (
                    this.methodSym != null &&
                    !this.methodSym.IsStatic &&
                    this.currentAnonymousMethodInfo != null &&
                    parentAggSym.IsStruct)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_ThisStructNotInAnonMeth);
                }
                else
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_ThisInBadContext);
                    // 'this' isn't available for some other reason
                }

                return NewError(treeNode, this.parentAggSym != null ? this.parentAggSym.GetThisType() : null);
            }
            DebugUtil.Assert((thisExpr.Flags & EXPRFLAG.IMPLICITTHIS) == 0);
            return thisExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BadOperatorTypesError
        //
        /// <summary>
        /// <para>Report a bad operator types error to the user.</para>
        /// <para>(In sscli, typeErr has the default value null.)</para>
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="op1"></param>
        /// <param name="op2"></param>
        /// <param name="typeErr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BadOperatorTypesError(
            BASENODE tree,
            EXPR op1,
            EXPR op2,
            TYPESYM typeErr)	// = null
        {
            string strOp = OpName(tree.Operator);

            while (op1.Kind == EXPRKIND.WRAP && (op1 as EXPRWRAP).Expr != null)
            {
                op1 = (op1 as EXPRWRAP).Expr;
            }

            if (op2 != null)
            {
                while (op2.Kind == EXPRKIND.WRAP && (op2 as EXPRWRAP).Expr != null)
                {
                    op2 = (op2 as EXPRWRAP).Expr;
                }
                if (!op1.TypeSym.IsERRORSYM && !op2.TypeSym.IsERRORSYM)
                {
                    Compiler.Error(tree, CSCERRID.ERR_BadBinaryOps,
                        new ErrArg(strOp),
                        new ErrArg(op1.TypeSym),
                        new ErrArg(op2.TypeSym));
                }
            }
            else if (!op1.TypeSym.IsERRORSYM)
            {
                Compiler.Error(tree, CSCERRID.ERR_BadUnaryOp,
                    new ErrArg(strOp),
                    new ErrArg(op1.TypeSym));
            }

            return NewError(tree, typeErr);
        }

        //--------------------------------------------------
        // FUNCBREC.AmbiguousOperatorError
        //
        /// <summary>
        /// Report an ambiguous operator types error.
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="op1"></param>
        /// <param name="op2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR AmbiguousOperatorError(BASENODE tree, EXPR op1, EXPR op2)
        {
            // Bad arg types - report error to user.
            if (op2 != null)
            {
                Compiler.Error(tree, CSCERRID.ERR_AmbigBinaryOps,
                    new ErrArg(OpName(tree.Operator)),
                    new ErrArg(op1.TypeSym),
                    new ErrArg(op2.TypeSym));
            }
            else
            {
                Compiler.Error(tree, CSCERRID.ERR_AmbigUnaryOp,
                    new ErrArg(OpName(tree.Operator)),
                    new ErrArg(op1.TypeSym));
            }
            return NewError(tree, null);
        }

        //--------------------------------------------------
        // FUNCBREC.checkVacuousIntegralCompare
        //
        /// <summary>
        /// Check for a integral comparison operation that can't be right. If one operand
        /// is a constant, the other operand has been cast from a smaller integration type, and the
        /// constant isn't in the range of the smaller type, the comparison is vacuous, and will
        /// always be true or false.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="castExpr"></param>
        /// <param name="constExpr"></param>
        //--------------------------------------------------
        private void CheckVacuousIntegralCompare(BASENODE treeNode, EXPR castExpr, EXPR constExpr)
        {
            DebugUtil.Assert(castExpr.Kind == EXPRKIND.CAST);
            DebugUtil.Assert(constExpr.Kind == EXPRKIND.CONSTANT);

            do
            {
                // Ensure this is a cast from one integral/enum type to another.
                if ((castExpr.Flags & (EXPRFLAG.BOX | EXPRFLAG.UNBOX)) != 0)
                {
                    break;
                }
                if (!castExpr.TypeSym.IsAGGTYPESYM)
                {
                    break;
                }
                if (!(castExpr as EXPRCAST).Operand.TypeSym.IsAGGTYPESYM)
                {
                    break;
                }

                AGGTYPESYM destAggTypeSym = castExpr.TypeSym.UnderlyingType() as AGGTYPESYM;
                AGGTYPESYM srcAggTypeSym = (castExpr as EXPRCAST).Operand.TypeSym.UnderlyingType() as AGGTYPESYM;

                if (!srcAggTypeSym.IsSimpleType() || !destAggTypeSym.IsSimpleType())
                {
                    break;
                }

                // If the cast is a narrowing cast, then it could change the
                // value of the expression, so this test isn't valid                                

                byte convertKind =
                    SimpleTypeConversion.Table[
                        (int)srcAggTypeSym.GetPredefType(),
                        (int)destAggTypeSym.GetPredefType()];
                if ((convertKind & SimpleTypeConversion.CONV_KIND_MASK) == SimpleTypeConversion.CONV_KIND_EXP)
                {
                    break;
                }

                // The cast meets all the requirements, so check if the constant is in
                // range of the original integral type of the casted expression.
                if (!IsConstantInRange((constExpr as EXPRCONSTANT), srcAggTypeSym, false))
                {
                    Compiler.Error(treeNode, CSCERRID.WRN_VacuousIntegralComp, new ErrArg(srcAggTypeSym));
                    break;
                }

                castExpr = (castExpr as EXPRCAST).Operand;
            } while (castExpr.Kind == EXPRKIND.CAST);
        }

        //--------------------------------------------------
        // FUNCBREC.BindDecimalConstCast
        //
        /// <summary>
        /// Bind a constant cast to or from decimal. Return null if cast can't be done.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="destTypeSym"></param>
        /// <param name="srcTypeSym"></param>
        /// <param name="srcConstExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindDecimalConstCast(
            BASENODE treeNode,
            TYPESYM destTypeSym,
            TYPESYM srcTypeSym,
            EXPRCONSTANT srcConstExpr)
        {
            TYPESYM decimalTypeSym = Compiler.GetOptPredefType(PREDEFTYPE.DECIMAL, true);
            CONSTVAL constVal = new CONSTVAL();

            if (decimalTypeSym == null)
            {
                return null;
            }

            if (destTypeSym == decimalTypeSym)
            {
                // Casting to decimal.

                FUNDTYPE ftSrc = srcTypeSym.FundamentalType();
                //DECIMAL castedDecimalValue;

                switch (ftSrc)
                {
                    case FUNDTYPE.I1:
                        constVal.SetDecimal((decimal)srcConstExpr.ConstVal.GetSByte());
                        break;

                    case FUNDTYPE.I2:
                        constVal.SetDecimal((decimal)srcConstExpr.ConstVal.GetShort());
                        break;

                    case FUNDTYPE.I4:
                        constVal.SetDecimal((decimal)srcConstExpr.ConstVal.GetInt());
                        break;

                    case FUNDTYPE.U1:
                        constVal.SetDecimal((decimal)srcConstExpr.ConstVal.GetByte());
                        break;

                    case FUNDTYPE.U2:
                        constVal.SetDecimal((decimal)srcConstExpr.ConstVal.GetUShort());
                        break;

                    case FUNDTYPE.U4:
                        constVal.SetDecimal((decimal)srcConstExpr.ConstVal.GetUInt());
                        break;

                    case FUNDTYPE.R4:
                        constVal.SetDecimal((decimal)srcConstExpr.ConstVal.GetFloat());
                        break;

                    case FUNDTYPE.R8:
                        constVal.SetDecimal((decimal)srcConstExpr.ConstVal.GetDouble());
                        break;

                    case FUNDTYPE.U8:
                        constVal.SetDecimal((decimal)srcConstExpr.ConstVal.GetULong());
                        break;

                    case FUNDTYPE.I8:
                        constVal.SetDecimal((decimal)srcConstExpr.ConstVal.GetLong());
                        break;

                    default:
                        // Not supported cast.
                        return null;
                }

                return NewExprConstant(treeNode, decimalTypeSym, constVal);
            } // if (destTypeSym == decimalTypeSym)

            if (srcTypeSym == decimalTypeSym)
            {
                // Casting from decimal
                //DECIMAL truncatedDecimalValue;

                FUNDTYPE ftDest = destTypeSym.FundamentalType();
                Exception excp = null;

                switch (ftDest)
                {
                    case FUNDTYPE.I1:
                        constVal.SetSByte(srcConstExpr.ConstVal.GetSByte(out excp));
                        break;

                    case FUNDTYPE.U1:
                        constVal.SetByte(srcConstExpr.ConstVal.GetByte(out excp));
                        break;

                    case FUNDTYPE.I2:
                        constVal.SetShort(srcConstExpr.ConstVal.GetShort(out excp));
                        break;

                    case FUNDTYPE.U2:
                        constVal.SetUShort(srcConstExpr.ConstVal.GetUShort(out excp));
                        break;

                    case FUNDTYPE.I4:
                        constVal.SetInt(srcConstExpr.ConstVal.GetInt(out excp));
                        break;

                    case FUNDTYPE.U4:
                        constVal.SetUInt(srcConstExpr.ConstVal.GetUInt(out excp));
                        break;

                    case FUNDTYPE.I8:
                        constVal.SetLong(srcConstExpr.ConstVal.GetLong(out excp));
                        break;

                    case FUNDTYPE.U8:
                        constVal.SetULong(srcConstExpr.ConstVal.GetULong(out excp));
                        break;

                    case FUNDTYPE.R4:
                        constVal.SetFloat(srcConstExpr.ConstVal.GetFloat(out excp));
                        break;

                    case FUNDTYPE.R8:
                        constVal.SetDouble(srcConstExpr.ConstVal.GetDouble(out excp));
                        break;

                    default:
                        // Not supported cast.
                        return null;
                }

                if (excp != null)
                {
                    // show error messages.
                    //return null;
                }
                return NewExprConstant(treeNode, destTypeSym, constVal);
            }
            return null;
        }

        //--------------------------------------------------
        // FUNCBREC.bindFloatOp
        //
        /// <summary>
        /// Bind an float/double operator: +, -, *, /, %, <, >, <=, >=, ==, !=.
        /// If both operations are constants, the result will be a constant also.
        /// op2 can be null for a unary operator.
        /// The operands are assumed to be already converted to the correct type.
        /// </summary>
        /// <remarks>
        /// We have an intentional divide by 0 there, so disable the warning...
        /// #if _MSC_VER
        /// #pragma warning( disable : 4723 )
        /// #endif
        /// </remarks>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="exprFlags"></param>
        /// <param name="operandExpr1"></param>
        /// <param name="operandExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindFloatOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG exprFlags,
            EXPR operandExpr1,
            EXPR operandExpr2)
        {
            DebugUtil.Assert(
                EXPRKIND.RELATIONAL_MIN <= exprKind && exprKind <= EXPRKIND.RELATIONAL_MAX ||
                EXPRKIND.ARITH_MIN <= exprKind && exprKind <= EXPRKIND.ARITH_MAX);
            DebugUtil.Assert(operandExpr2 == null || operandExpr1.TypeSym == operandExpr2.TypeSym);
            DebugUtil.Assert(
                operandExpr1.TypeSym.IsPredefType(PREDEFTYPE.FLOAT) ||
                operandExpr1.TypeSym.IsPredefType(PREDEFTYPE.DOUBLE));

            EXPR resExpr;
            EXPR opConstExpr1 = operandExpr1.GetConst();
            EXPR opConstExpr2 = (operandExpr2 != null) ? operandExpr2.GetConst() : null;

            // Check for constants and fold them.
            if (opConstExpr1 != null && (operandExpr2 == null || opConstExpr2 != null))
            {
                // Get the operands
                double d1 = (opConstExpr1 as EXPRCONSTANT).ConstVal.GetDouble();
                double d2 = opConstExpr2 != null ? (opConstExpr2 as EXPRCONSTANT).ConstVal.GetDouble() : 0.0;
                double result = 0;      // if isBoolResult is false
                bool result_b = false;  // if isBoolResult is true

                // Do the operation.
                switch (exprKind)
                {
                    case EXPRKIND.ADD:
                        result = d1 + d2;
                        break;

                    case EXPRKIND.SUB:
                        result = d1 - d2;
                        break;

                    case EXPRKIND.MUL:
                        result = d1 * d2;
                        break;

                    case EXPRKIND.DIV:
                        result = d1 / d2;
                        break;

                    case EXPRKIND.NEG:
                        result = -d1;
                        break;

                    case EXPRKIND.UPLUS:
                        result = d1;
                        break;

                    case EXPRKIND.MOD:
                        //if (!_finite(d2) && !_isnan(d2))
                        if (Double.IsInfinity(d2))
                        {
                            //if (!_finite(d1) && !_isnan(d1))
                            if (Double.IsInfinity(d1))
                            {
                                double d = 0.0;
                                result = 0.0 / d;
                            }
                            else
                            {
                                result = d1;
                            }
                        }
                        else
                        {
                            result = d1 % d2; // fmod(d1, d2);
                        }
                        break;

                    case EXPRKIND.EQ:
                        result_b = (d1 == d2);
                        break;

                    case EXPRKIND.NE:
                        result_b = (d1 != d2);
                        break;

                    case EXPRKIND.LE:
                        result_b = (d1 <= d2);
                        break;

                    case EXPRKIND.LT:
                        result_b = (d1 < d2);
                        break;

                    case EXPRKIND.GE:
                        result_b = (d1 >= d2);
                        break;

                    case EXPRKIND.GT:
                        result_b = (d1 > d2);
                        break;

                    default:
                        DebugUtil.Assert(false);
                        result = 0.0;  // unexpected operation.
                        break;
                }

                TYPESYM destTypeSym;
                CONSTVAL cv = new CONSTVAL();

                // Allocate the result node.
                if (EXPRKIND.RELATIONAL_MIN <= exprKind && exprKind <= EXPRKIND.RELATIONAL_MAX)
                {
                    cv.SetBool(result_b);
                    destTypeSym = GetRequiredPredefinedType(PREDEFTYPE.BOOL);
                }
                else
                {
                    //cv.doubleValue = (double *) allocator.Alloc(sizeof(double));

                    // NaN has some implementation defined bits that differ between platforms.
                    // Normalize it to produce identical images accross all platforms
                    //if (_isnan(result))
                    if (Double.IsNaN(result))
                    {
                        //* (unsigned __int64 *) cv.doubleVal = UI64(0xFFF8000000000000);
                        //_ASSERTE(_isnan(* cv.doubleVal));
                        cv.SetDouble(Double.NaN);
                    }
                    else
                    {
                        cv.SetDouble(result);
                    }

                    destTypeSym = operandExpr1.TypeSym;
                }
                resExpr = NewExprConstant(treeNode, destTypeSym, cv);
                resExpr = AddSideEffects(treeNode, resExpr, operandExpr2, true, false);
                resExpr = AddSideEffects(treeNode, resExpr, operandExpr1, true, false);
            }
            else
            {
                // Allocate the result expression.
                TYPESYM destTypeSym = (EXPRKIND.RELATIONAL_MIN <= exprKind && exprKind <= EXPRKIND.RELATIONAL_MAX) ?
                   GetRequiredPredefinedType(PREDEFTYPE.BOOL) : operandExpr1.TypeSym;

                resExpr = NewExprBinop(treeNode, exprKind, destTypeSym, operandExpr1, operandExpr2);
                exprFlags &= ~EXPRFLAG.CHECKOVERFLOW;
                resExpr.Flags |= exprFlags;
            }

            return resExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.HasSelfCompare
        //
        /// <summary></summary>
        /// <param name="type"></param>
        /// <param name="kind"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool HasSelfCompare(TYPESYM type, EXPRKIND kind)
        {
            if (type == null || !type.IsAGGTYPESYM) return false;

            AGGSYM agg = type.GetAggregate();

            if (!agg.IsSelfCmpValid)
            {
                Compiler.EnsureState(agg, AggStateEnum.Prepared);
                if (!agg.HasSelfEquality)
                {
                    agg.HasSelfEquality = HasSelfCompare(agg.BaseClassSym, EXPRKIND.EQ);
                }
                if (!agg.HasSelfEquality)
                {
                    agg.HasSelfNonEquality = HasSelfCompare(agg.BaseClassSym, EXPRKIND.NE);
                }
                agg.IsSelfCmpValid = true;
            }

            return (kind == EXPRKIND.EQ) ? agg.HasSelfEquality : agg.HasSelfNonEquality;
        }

        // Binary operator binding.

#if DEBUG
        static bool checkedBetter;
#endif

        //------------------------------------------------------------
        // FUNCBREC.BindStdBinOp
        //
        /// <summary>
        /// This handles binding binary operators
        /// by first checking for user defined operators,
        /// then applying overload resolution to the predefined operators.
        /// It handles lifting over nullable.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <param name="isUserDef"></param>
        /// <param name="nubInfo"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR BindStdBinOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPR argExpr1,
            EXPR argExpr2,
            ref bool isUserDef,     // = NULL
            ref NubInfo nubInfo)    // = NULL
        {
#if DEBUG
            if (!checkedBetter)
            {
                for (int i = 0; i <= SymbolUtil.NUM_EXT_TYPES; i++)
                {
                    DebugUtil.Assert(g_mpptptBetter[i, i] == 0);
                    for (int j = 0; j < i; j++)
                    {
                        DebugUtil.Assert(g_mpptptBetter[i, j] != 0 && g_mpptptBetter[j, i] != 0);
                        DebugUtil.Assert(
                            g_mpptptBetter[i, j] + g_mpptptBetter[j, i] == 3 ||
                            g_mpptptBetter[i, j] == 3 && g_mpptptBetter[j, i] == 3);

                        TYPESYM type1 = GetOptionalPredefinedType((PREDEFTYPE)(i));
                        TYPESYM type2 = GetOptionalPredefinedType((PREDEFTYPE)(j));

                        DebugUtil.Assert(
                            type1 == null ||
                            type2 == null ||
                            ((g_mpptptBetter[i, j] == 1 || !CanConvert(type1, type2, ConvertTypeEnum.NOUDC)) &&
                            (g_mpptptBetter[j, i] == 1 || !CanConvert(type2, type1, ConvertTypeEnum.NOUDC))));
                    }
                }
                checkedBetter = true;
            }

            DebugUtil.Assert(argExpr1 != null && argExpr2 != null);
#endif

            EXPRFLAG flags = 0;
            BinOpArgInfo binOpArgInfo = new BinOpArgInfo();

            if (nubInfo != null)
            {
                nubInfo.Init();
            }
            isUserDef = false;

            // Get the binary operator kind and flags.
            if (!GetBokAndFlags(exprKind, out binOpArgInfo.BinOpKind, out flags))
            {
                return BadOperatorTypesError(treeNode, argExpr1, argExpr2, null);
            }

            binOpArgInfo.ArgumentExpr1 = argExpr1;
            binOpArgInfo.ArgumentExpr2 = argExpr2;
            binOpArgInfo.TypeSym1 = argExpr1.TypeSym;
            binOpArgInfo.TypeSym2 = argExpr2.TypeSym;
            binOpArgInfo.RawTypeSym1 = binOpArgInfo.TypeSym1.StripNubs();
            binOpArgInfo.RawTypeSym2 = binOpArgInfo.TypeSym2.StripNubs();
            binOpArgInfo.BinOpMask = (BinOpMaskEnum)((int)1 << (int)binOpArgInfo.BinOpKind);

            Compiler.EnsureState(binOpArgInfo.TypeSym1, AggStateEnum.Prepared);
            Compiler.EnsureState(binOpArgInfo.TypeSym2, AggStateEnum.Prepared);

            binOpArgInfo.PredefinedType1 =
                binOpArgInfo.TypeSym1.IsPredefined() ?
                binOpArgInfo.TypeSym1.GetPredefType() :
                PREDEFTYPE.COUNT;
            binOpArgInfo.PredefinedType2 =
                binOpArgInfo.TypeSym2.IsPredefined() ?
                binOpArgInfo.TypeSym2.GetPredefType() :
                PREDEFTYPE.COUNT;
            binOpArgInfo.RawPredefinedType1 =
                binOpArgInfo.RawTypeSym1.IsPredefined() ?
                binOpArgInfo.RawTypeSym1.GetPredefType() :
                PREDEFTYPE.COUNT;
            binOpArgInfo.RawPredefinedType2 =
                binOpArgInfo.RawTypeSym2.IsPredefined() ?
                binOpArgInfo.RawTypeSym2.GetPredefType() :
                PREDEFTYPE.COUNT;

            //const int kcbofsMaxExtra = 10; // This is the maximum number of non-predef signatures we'll have.
            //const int kcbofsMax = lengthof(g_rgbos) + kcbofsMaxExtra;
            //BinOpFullSig rgbofs[kcbofsMax];
            List<BinOpFullSig> bofsList = new List<BinOpFullSig>();
            //int cbofs = 0;
            int ibofsBest = -1;
            int ibos;
            int ibosMinLift;
            int ibofs;

            int bosCount = BinOpSigArray.Length;	// lengthof(g_rgbos)
            // g_rgbos is defined and renamed BinOpSigArray in Operator.cs.

            BinOpFullSig tempBofs;
            EXPR resExpr;

            //------------------------------------------------------------
            // Find all applicable operator signatures.
            // First check for special ones (delegate, enum, pointer) and check for user defined ops.
            //------------------------------------------------------------

            if (binOpArgInfo.PredefinedType1 > PREDEFTYPE.ULONG ||
                binOpArgInfo.PredefinedType2 > PREDEFTYPE.ULONG)
            {
                EXPR expr;

                // Check for user defined.
                switch (binOpArgInfo.BinOpKind)
                {
                    case BinOpKindEnum.Logical:
                        // Logical operators cannot be overloaded, but use the bitwise overloads.
                        expr = BindUDBinop(
                            treeNode,
                            (exprKind - EXPRKIND.LOGAND + EXPRKIND.BITAND),
                            argExpr1,
                            argExpr2,
                            true);
                        if (expr != null)
                        {
                            isUserDef = true;
                            return BindUserBoolOp(treeNode, exprKind, expr);
                        }
                        break;

                    default:
                        expr = BindUDBinop(treeNode, exprKind, argExpr1, argExpr2, false);
                        if (expr != null)
                        {
                            isUserDef = true;
                            return expr;
                        }
                        break;
                }

                // Delegate types and enum types are special in that they carry a set
                // of "predefined" operators.
                if (// Delegate
                    (binOpArgInfo.TypeSym1.IsDelegateType() || binOpArgInfo.TypeSym2.IsDelegateType()) &&
                    (binOpArgInfo.BinOpMask & BinOpMaskEnum.Delegate) != 0 &&
                    GetDelBinOpSigs(bofsList, binOpArgInfo)
                    ||
                    // Enum
                    (binOpArgInfo.RawTypeSym1.IsEnumType() || binOpArgInfo.RawTypeSym2.IsEnumType()) &&
                    GetEnumBinOpSigs(bofsList, /*&cbofs,*/ binOpArgInfo)
                    ||
                    // Pointer
                    (binOpArgInfo.TypeSym1.IsPTRSYM || binOpArgInfo.TypeSym2.IsPTRSYM) &&
                    GetPtrBinOpSigs(bofsList, /*&cbofs,*/ binOpArgInfo)
                    ||
                    // Equality
                    binOpArgInfo.BinOpKind == BinOpKindEnum.Equal &&
                    GetRefEqualSigs(bofsList, /*&cbofs,*/ binOpArgInfo))
                {
                    // We have an exact match.
                    DebugUtil.Assert(bofsList.Count > 0);
                    ibofsBest = bofsList.Count - 1;
                    goto LMatch;
                }
            }
            //DebugUtil.Assert(cbofs <= kcbofsMaxExtra);

            //------------------------------------------------------------
            // Now check for standard ones (numeric, string, etc) and their lifted forms.
            //------------------------------------------------------------

            ibosMinLift = Compiler.FCanLift() ? 0 : bosCount;
            for (ibos = 0; ibos < bosCount; ibos++)
            {
                BinOpSig bos = BinOpSigArray[ibos];
                if ((bos.Mask & binOpArgInfo.BinOpMask) == 0)
                {
                    continue;
                }

                TYPESYM sigTypeSym1 = GetOptionalPredefinedType(bos.PredefinedType1);
                TYPESYM sigTypeSym2 = GetOptionalPredefinedType(bos.PredefinedType2);
                if (sigTypeSym1 == null || sigTypeSym2 == null)
                {
                    continue;
                }

                ConvKindEnum cv1 = GetConvKind(binOpArgInfo.PredefinedType1, bos.PredefinedType1);
                ConvKindEnum cv2 = GetConvKind(binOpArgInfo.PredefinedType2, bos.PredefinedType2);
                LiftFlagsEnum liftFlags = LiftFlagsEnum.None;

                switch (cv1)
                {
                    default:
                        DebugUtil.VsFail("Shouldn't happen!");
                        goto case ConvKindEnum.None;

                    case ConvKindEnum.None:
                        continue;

                    case ConvKindEnum.Explicit:
                        if (argExpr1.Kind != EXPRKIND.CONSTANT)
                        {
                            continue;
                        }
                        // Need to try to convert.
                        goto case ConvKindEnum.Unknown;

                    case ConvKindEnum.Unknown:
                        if (CanConvert(argExpr1, sigTypeSym1, 0))
                        {
                            break;
                        }
                        if (ibos < ibosMinLift || (bos.Flags & OpSigFlagsEnum.CanLift) == 0)
                        {
                            continue;
                        }
                        DebugUtil.Assert(sigTypeSym1.IsValueType());

                        sigTypeSym1 = Compiler.MainSymbolManager.GetNubType(sigTypeSym1);
                        if (!CanConvert(argExpr1, sigTypeSym1, 0))
                        {
                            continue;
                        }
                        switch (GetConvKind(binOpArgInfo.RawPredefinedType1, bos.PredefinedType1))
                        {
                            default:
                                liftFlags = liftFlags | LiftFlagsEnum.Convert1;
                                break;

                            case ConvKindEnum.Implicit:
                            case ConvKindEnum.Identity:
                                liftFlags = liftFlags | LiftFlagsEnum.Lift1;
                                break;
                        }
                        break;

                    case ConvKindEnum.Implicit:
                        break;

                    case ConvKindEnum.Identity:
                        if (cv2 == ConvKindEnum.Identity)
                        {
                            tempBofs = new BinOpFullSig();
                            if (tempBofs.Set(this, bos))
                            {
                                // Exact match.
                                ibofsBest = bofsList.Count;
                                bofsList.Add(tempBofs);
                                goto LMatch;
                            }
                        }
                        break;
                }

                switch (cv2)
                {
                    default:
                        DebugUtil.Assert(false, "Shouldn't happen!");
                        goto case ConvKindEnum.None;

                    case ConvKindEnum.None:
                        continue;

                    case ConvKindEnum.Explicit:
                        if (argExpr2.Kind != EXPRKIND.CONSTANT)
                        {
                            continue;
                        }
                        // Need to try to convert.
                        goto case ConvKindEnum.Unknown;

                    case ConvKindEnum.Unknown:
                        if (CanConvert(argExpr2, sigTypeSym2, 0))
                        {
                            break;
                        }
                        if (ibos < ibosMinLift || (bos.Flags & OpSigFlagsEnum.CanLift) == 0)
                        {
                            continue;
                        }
                        DebugUtil.Assert(sigTypeSym2.IsValueType());
                        sigTypeSym2 = Compiler.MainSymbolManager.GetNubType(sigTypeSym2);
                        if (!CanConvert(argExpr2, sigTypeSym2, 0))
                        {
                            continue;
                        }

                        switch (GetConvKind(binOpArgInfo.RawPredefinedType2, bos.PredefinedType2))
                        {
                            default:
                                liftFlags = liftFlags | LiftFlagsEnum.Convert2;
                                break;

                            case ConvKindEnum.Implicit:
                            case ConvKindEnum.Identity:
                                liftFlags = liftFlags | LiftFlagsEnum.Lift2;
                                break;
                        }
                        break;

                    case ConvKindEnum.Identity:
                    case ConvKindEnum.Implicit:
                        break;
                }

                if (liftFlags != 0)
                {
                    // We have a lifted signature.
                    //rgbofs[cbofs].Set(sigTypeSym1, sigTypeSym2, bos.pfn, bos.grfos, liftFlags);
                    //cbofs++;
                    tempBofs = new BinOpFullSig();
                    tempBofs.Set(sigTypeSym1, sigTypeSym2, bos.BindOp, bos.Flags, liftFlags);
                    bofsList.Add(tempBofs);

                    // NOTE: Can't skip any if we use a lifted signature because the
                    // type might convert to int? and to long (but not to int) in which
                    // case we should get an ambiguity. But we can skip the lifted ones....
                    ibosMinLift = ibos + bos.SkipCount + 1;
                }
                else
                {
                    // Record it as applicable and skip accordingly.
                    //if (rgbofs[cbofs].Set(this, bos))
                    //    cbofs++;
                    tempBofs = new BinOpFullSig();
                    if (tempBofs.Set(this, bos))
                    {
                        bofsList.Add(tempBofs);
                    }
                    ibos += bos.SkipCount;
                }
            } // for (ibos = 0; ibos < bosCount; ibos++)

            //DebugUtil.Assert(cbofs <= kcbofsMax);

            if (bofsList.Count == 0)
            {
                // Check for x == null where x is a nullable.
                if (binOpArgInfo.BinOpKind == BinOpKindEnum.Equal)
                {
                    if (binOpArgInfo.TypeSym1.IsNUBSYM && binOpArgInfo.TypeSym2.IsNULLSYM)
                    {
                        resExpr = BindNubHasValue(treeNode, binOpArgInfo.ArgumentExpr1, exprKind == EXPRKIND.NE);
                        return AddSideEffects(treeNode, resExpr, binOpArgInfo.ArgumentExpr2, false, true);
                    }
                    if (binOpArgInfo.TypeSym1.IsNULLSYM && binOpArgInfo.TypeSym2.IsNUBSYM)
                    {
                        resExpr = BindNubHasValue(treeNode, binOpArgInfo.ArgumentExpr2, exprKind == EXPRKIND.NE);
                        return AddSideEffects(treeNode, resExpr, binOpArgInfo.ArgumentExpr1, true, true);
                    }
                }
                return BadOperatorTypesError(treeNode, argExpr1, argExpr2, null);
            }

            ibofsBest = 0;
            if (bofsList.Count == 1)
            {
                goto LMatch;
            }

            // Determine which is best.
            for (ibofs = 1; ibofs < bofsList.Count; ibofs++)
            {
                if (ibofsBest < 0)
                {
                    ibofsBest = ibofs;
                }
                else
                {
                    int nT = WhichBofsIsBetter(
                        bofsList[ibofsBest],
                        bofsList[ibofs],
                        binOpArgInfo.TypeSym1,
                        binOpArgInfo.TypeSym2);
                    if (nT == 0)
                    {
                        ibofsBest = -1;
                    }
                    else if (nT > 0)
                    {
                        ibofsBest = ibofs;
                    }
                }
            }
            if (ibofsBest < 0)
            {
                // Ambigous.
                return AmbiguousOperatorError(treeNode, argExpr1, argExpr2);
            }

            // Verify that our answer works.
            for (ibofs = 0; ibofs < bofsList.Count; ibofs++)
            {
                if (ibofs == ibofsBest) continue;
                if (WhichBofsIsBetter(
                    bofsList[ibofsBest],
                    bofsList[ibofs],
                    binOpArgInfo.TypeSym1,
                    binOpArgInfo.TypeSym2) >= 0)
                {
                    return AmbiguousOperatorError(treeNode, argExpr1, argExpr2);
                }
            }

        LMatch:
            //DebugUtil.Assert(cbofs <= kcbofsMax);
            DebugUtil.Assert(ibofsBest < bofsList.Count);
            BinOpFullSig bofs = bofsList[ibofsBest];

            if (bofs.BindOp == 0)
            {
                return BadOperatorTypesError(treeNode, argExpr1, argExpr2, null);
            }

            EXPR expr1 = argExpr1;
            EXPR expr2 = argExpr2;

            if (bofs.LiftFlags == 0 || (bofs.Flags & OpSigFlagsEnum.AutoLift) == 0)
            {
                if ((bofs.Flags & OpSigFlagsEnum.Convert) != 0)
                {
                    expr1 = MustConvert(expr1, bofs.TypeSym1, 0);
                    expr2 = MustConvert(expr2, bofs.TypeSym2, 0);
                }
                //return (this.*bofs.pfn)(treeNode, exprKind, flags, expr1, expr2);
                return BindBinaryOperator(bofs.BindOp, treeNode, exprKind, flags, expr1, expr2);
            }

            // Have to lift.
            DebugUtil.Assert(bofs.TypeSym1.IsNUBSYM || bofs.TypeSym2.IsNUBSYM);
            NubInfo nin = new NubInfo();

            if ((bofs.LiftFlags & LiftFlagsEnum.Lift1) == 0)
            {
                expr1 = MustConvert(expr1, bofs.TypeSym1, 0);
            }
            if ((bofs.LiftFlags & LiftFlagsEnum.Lift2) == 0)
            {
                expr2 = MustConvert(expr2, bofs.TypeSym2, 0);
            }

            BindNubCondValBin(treeNode, expr1, expr2, ref nin, LiftFlagsEnum.LiftBoth);
            DebugUtil.Assert(nin.IsActive);
            if (binOpArgInfo.BinOpKind == BinOpKindEnum.Equal)
            {
                return BindNubEqOpCore(treeNode, exprKind, flags, expr1, expr2, bofs, nin);
            }

            if (binOpArgInfo.BinOpKind == BinOpKindEnum.Compare)
            {
                return BindNubCmpOpCore(treeNode, exprKind, flags, bofs, nin);
            }

            expr1 = nin.Val(0);
            expr2 = nin.Val(1);

            if ((bofs.LiftFlags & LiftFlagsEnum.Lift1) != 0)
            {
                expr1 = MustConvert(expr1, (bofs.TypeSym1 as NUBSYM).BaseTypeSym, 0);
            }
            if ((bofs.LiftFlags & LiftFlagsEnum.Lift2) != 0)
            {
                expr2 = MustConvert(expr2, (bofs.TypeSym2 as NUBSYM).BaseTypeSym, 0);
            }

            // We need to substitute a dummy expr for GetValOrDef(null) - which was optimized to
            // a default value - so the bofs.pfn doesn't issue bogus errors - like can't divide
            // by zero (for x / null). We do however want to issue errors for any non-null args
            // (for null / 0).
            if (nin.IsNull[0])
            {
                DebugUtil.Assert(nin.FAlwaysNull());
                expr1 = NewExpr(expr1.TreeNode, EXPRKIND.NOOP, expr1.TypeSym);
            }
            if (nin.IsNull[1])
            {
                DebugUtil.Assert(nin.FAlwaysNull());
                expr2 = NewExpr(expr2.TreeNode, EXPRKIND.NOOP, expr2.TypeSym);
            }

            // Bind the value expression.
            //resExpr = (this.*bofs.pfn)(treeNode, exprKind, flags, expr1, expr2);
            resExpr = BindBinaryOperator(bofs.BindOp, treeNode, exprKind, flags, expr1, expr2);
            DebugUtil.Assert(!resExpr.TypeSym.IsNUBSYM);
            // Expedientially, nubInfo == null means that NubInfo is not necessary.
            if (nubInfo != null)
            {
                nubInfo = nin;
                return resExpr;
            }

            NUBSYM nubDst = Compiler.MainSymbolManager.GetNubType(resExpr.TypeSym);
            return BindNubOpRes(treeNode, nubDst, nubDst, resExpr, ref nin, true);
        }

        //------------------------------------------------------------
        // FUNCBREC.BindNubEqOpCore
        //
        /// <summary>
        /// Handle predefined nullable equality operators.
        /// These are special because the return type is not lifted and null compares equal to null.
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="expr1"></param>
        /// <param name="expr2"></param>
        /// <param name="binOpFullSig"></param>
        /// <param name="nubInfo"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR BindNubEqOpCore(
            BASENODE tree,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR expr1,
            EXPR expr2,
            BinOpFullSig binOpFullSig,
            NubInfo nubInfo)
        {
            DebugUtil.Assert(nubInfo.IsActive);
            EXPR resExpr;

            if (nubInfo.FAlwaysNull())
            {
                // At least one of them is a constant null.
                TYPESYM boolTypeSym = GetRequiredPredefinedType(PREDEFTYPE.BOOL);

                if (!binOpFullSig.TypeSym1.IsNUBSYM || !binOpFullSig.TypeSym2.IsNUBSYM)
                {
                    // One is null and the other is not nullable.
                    Compiler.Error(tree, CSCERRID.WRN_NubExprIsConstBool,
                        new ErrArg(exprKind == EXPRKIND.NE ? PREDEFNAME.TRUE : PREDEFNAME.FALSE),
                        new ErrArg(nubInfo.IsNull[0] ? binOpFullSig.TypeSym2 : binOpFullSig.TypeSym1),
                        new ErrArg(nubInfo.IsNull[0] ? binOpFullSig.TypeSym1 : binOpFullSig.TypeSym2));
                    resExpr = NewExprConstant(tree, boolTypeSym, new ConstValInit(exprKind == EXPRKIND.NE));
                    resExpr = AddSideEffects(tree, resExpr, expr2, true, true);
                    return AddSideEffects(tree, resExpr, expr1, true, true);
                }

                if (nubInfo.IsNull[0] && nubInfo.IsNull[1])
                {
                    // Both are constant nulls.
                    resExpr = NewExprConstant(tree, boolTypeSym, new ConstValInit(exprKind == EXPRKIND.EQ));
                    resExpr = AddSideEffects(tree, resExpr, expr2, true, true);
                    return AddSideEffects(tree, resExpr, expr1, true, true);
                }

                // Generate seq(a, !b.HasValue) or rev(!a.HasValue, b).
                resExpr = BindNubHasValue(tree, nubInfo.IsNull[0] ? expr2 : expr1, exprKind == EXPRKIND.NE);
                return AddSideEffects(tree, resExpr, nubInfo.IsNull[0] ? expr1 : expr2, nubInfo.IsNull[0], true);
            }

            if (nubInfo.IsSameTemp)
            {
                // The answer is (exprKind == EXPRKIND.EQ). There aren't any side effects.
                return NewExprConstant(
                    tree,
                    GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                    new ConstValInit(exprKind == EXPRKIND.EQ));
            }

            // Generate (tmp1 = a).GetValOrDef() == (tmp2 = b).GetValOrDef() && tmp1.HasValue == tmp2.HasValue
            EXPR tempExpr = nubInfo.PreVal(0);
            if (tempExpr.TypeSym.IsNUBSYM)
            {
                expr1 = BindNubGetValOrDef(tree, tempExpr);
            }
            else
            {
                DebugUtil.Assert(nubInfo.ConditionExpr[0] == null);
                nubInfo.PostExpr[0] = null;
            }

            tempExpr = nubInfo.PreVal(1);
            if (tempExpr.TypeSym.IsNUBSYM)
                expr2 = BindNubGetValOrDef(tree, tempExpr);
            else
            {
                DebugUtil.Assert(nubInfo.ConditionExpr[1] == null);
                nubInfo.PostExpr[1] = null;
            }

            if ((binOpFullSig.LiftFlags & LiftFlagsEnum.Lift1) != 0)
            {
                expr1 = MustConvert(expr1, (binOpFullSig.TypeSym1 as NUBSYM).BaseTypeSym, 0);
            }
            if ((binOpFullSig.LiftFlags & LiftFlagsEnum.Lift2) != 0)
            {
                expr2 = MustConvert(expr2, (binOpFullSig.TypeSym2 as NUBSYM).BaseTypeSym, 0);
            }

            // Bind the value expression.
            resExpr = BindBinaryOperator(binOpFullSig.BindOp, tree, exprKind, flags, expr1, expr2);
            DebugUtil.Assert(resExpr.TypeSym.IsPredefType(PREDEFTYPE.BOOL));
            if (nubInfo.FAlwaysNonNull())
            {
                return resExpr;
            }
            DebugUtil.Assert(nubInfo.CombinedConditionExpr != null);
            DebugUtil.Assert(
                (nubInfo.CombinedConditionExpr.Kind == EXPRKIND.BITAND)
                == (nubInfo.ConditionExpr[0] != null && nubInfo.ConditionExpr[1] != null));
            if (nubInfo.CombinedConditionExpr.Kind == EXPRKIND.BITAND)
            {
                nubInfo.CombinedConditionExpr.Kind = exprKind;
            }
            else if (exprKind == EXPRKIND.NE)
            {
                nubInfo.CombinedConditionExpr = NewExprBinop(
                    tree,
                    EXPRKIND.LOGNOT,
                    resExpr.TypeSym,
                    nubInfo.CombinedConditionExpr,
                    null);
            }
            resExpr = NewExprBinop(
                tree,
                exprKind == EXPRKIND.NE ? EXPRKIND.LOGOR : EXPRKIND.LOGAND,
                resExpr.TypeSym,
                resExpr,
                nubInfo.CombinedConditionExpr);

            // Don't call BindNubAddTmps since we've already used the rgexprPre values.
            resExpr = AddSideEffects(tree, resExpr, nubInfo.PostExpr[0], false, true);
            return AddSideEffects(tree, resExpr, nubInfo.PostExpr[1], false, true);
        }

        //--------------------------------------------------
        // FUNCBREC.BindNubCmpOpCore
        //
        /// <summary>
        /// Handle predefined nullable comparison operators.
        /// These are special because the return type is not lifted.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="binOpFullSig"></param>
        /// <param name="nubInfo"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindNubCmpOpCore(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            BinOpFullSig binOpFullSig,
            NubInfo nubInfo)
        {
            DebugUtil.Assert(nubInfo.IsActive);

            EXPR resExpr;
            EXPR expr1 = nubInfo.Val(0);
            EXPR expr2 = nubInfo.Val(1);

            if ((binOpFullSig.LiftFlags & LiftFlagsEnum.Lift1) != 0)
            {
                expr1 = MustConvert(expr1, (binOpFullSig.TypeSym1 as NUBSYM).BaseTypeSym, 0);
            }
            if ((binOpFullSig.LiftFlags & LiftFlagsEnum.Lift2) != 0)
            {
                expr2 = MustConvert(expr2, (binOpFullSig.TypeSym2 as NUBSYM).BaseTypeSym, 0);
            }

            if (nubInfo.FAlwaysNull())
            {
                Compiler.Error(treeNode, CSCERRID.WRN_CmpAlwaysFalse,
                    new ErrArg(nubInfo.TmpVal(nubInfo.IsNull[0] ? 0 : 1).TypeSym));
                resExpr = NewExprConstant(
                    treeNode,
                    GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                    new ConstValInit(false));
            }
            else
            {
                // Bind the value expression.
                resExpr = BindBinaryOperator(
                    binOpFullSig.BindOp,
                    treeNode,
                    exprKind,
                    flags,
                    expr1,
                    expr2);
                DebugUtil.Assert(resExpr.TypeSym.IsPredefType(PREDEFTYPE.BOOL));

                if (nubInfo.FAlwaysNonNull())
                {
                    return resExpr;
                }

                resExpr = NewExprBinop(
                    treeNode,
                    EXPRKIND.LOGAND,
                    resExpr.TypeSym,
                    resExpr,
                    nubInfo.CombinedConditionExpr);
            }

            return BindNubAddTmps(treeNode, resExpr, ref nubInfo);
        }

        //--------------------------------------------------
        // FUNCBREC.BindIntBinOp
        //
        /// <summary>
        /// Handles standard binary integer based operators.
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="ek"></param>
        /// <param name="flags"></param>
        /// <param name="arg1"></param>
        /// <param name="arg2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindIntBinOp(BASENODE tree, EXPRKIND ek, EXPRFLAG flags, EXPR arg1, EXPR arg2)
        {
            DebugUtil.Assert(
                arg1.TypeSym.IsPredefined() &&
                arg2.TypeSym.IsPredefined() &&
                arg1.TypeSym.GetPredefType() == arg2.TypeSym.GetPredefType());

            return BindIntOp(tree, ek, flags, arg1, arg2, arg1.TypeSym.GetPredefType());
        }

        //--------------------------------------------------
        // FUNCBREC.BindRealBinOp
        //
        //--------------------------------------------------
        //private EXPR * BindRealBinOp(BASENODE * tree, EXPRKIND ek, uint flags, EXPR * arg1, EXPR * arg2);

        //--------------------------------------------------
        // FUNCBREC.BindDecBinOp
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        /// <remarks>
        /// In sscli, call the methods defined in sscli20\palrt\src\decarith.cpp
        /// </remarks>
        //--------------------------------------------------
        private EXPR BindDecBinOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            DebugUtil.Assert(
                argExpr1.TypeSym.IsPredefType(PREDEFTYPE.DECIMAL) &&
                argExpr2.TypeSym.IsPredefType(PREDEFTYPE.DECIMAL));

            TYPESYM decimalTypeSym = GetOptionalPredefinedType(PREDEFTYPE.DECIMAL);
            DebugUtil.Assert(decimalTypeSym != null);

            EXPR argConstExpr1 = argExpr1.GetConst();
            EXPR argConstExpr2 = argExpr2.GetConst();


            if (argConstExpr1 != null)
            {
                if (argConstExpr2 != null) goto LBothConst;
                decimal dec = (argConstExpr1 as EXPRCONSTANT).ConstVal.GetDecimal();

                // Convert 1 + d to inc(d) and -1 + d to dec(d)
                //if (exprKind == EXPRKIND.ADD &&
                //    DECIMAL_LO32(dec) == 1 && DECIMAL_SCALE(dec) == 0 &&
                //    (DECIMAL_MID32(dec) | DECIMAL_HI32(dec)) == 0)
                if (exprKind == EXPRKIND.ADD)
                {
                    if (dec == 1)
                    {
                        return AddSideEffects(
                            treeNode,
                            BindPredefOpAsUD(treeNode, EXPRKIND.INC, argExpr2, null),
                            argExpr1,
                            true,
                            false);
                    }
                    else if (dec == -1)
                    {
                        return AddSideEffects(
                            treeNode,
                            BindPredefOpAsUD(treeNode, EXPRKIND.DEC, argExpr2, null),
                            argExpr1,
                            true,
                            false);
                    }
                }
            }
            else if (argConstExpr2 != null)
            {
                decimal dec = (argConstExpr2 as EXPRCONSTANT).ConstVal.GetDecimal();

                // Convert d + 1 to inc(d) and d - 1 to dec(d)
                //if ((exprKind == EXPRKIND.ADD || exprKind == EXPRKIND.SUB) &&
                //    DECIMAL_LO32(dec) == 1 && DECIMAL_SCALE(dec) == 0 &&
                //    (DECIMAL_MID32(dec) | DECIMAL_HI32(dec)) == 0)
                //{
                //    if (DECIMAL_SIGN(dec) == DECIMAL_NEG)
                //        exprKind = (EXPRKIND)(EXPRKIND.ADD + EXPRKIND.SUB - exprKind);
                //    return BindPredefOpAsUD(
                //    	treeNode,
                //    	(EXPRKIND)(exprKind - EXPRKIND.ADD + EXPRKIND.INC),
                //    	AddSideEffects(treeNode, argExpr1, argExpr2, false),
                //    	null);
                //}

                if (exprKind == EXPRKIND.ADD)
                {
                    if (dec == 1)
                    {
                        return BindPredefOpAsUD(
                            treeNode,
                            EXPRKIND.INC,
                            AddSideEffects(treeNode, argExpr1, argExpr2, false, false),
                            null);
                    }
                    else if (dec == -1)
                    {
                        return BindPredefOpAsUD(
                            treeNode,
                            EXPRKIND.DEC,
                            AddSideEffects(treeNode, argExpr1, argExpr2, false, false),
                            null);
                    }
                }
                else if (exprKind == EXPRKIND.SUB)
                {
                    if (dec == 1)
                    {
                        return BindPredefOpAsUD(
                            treeNode,
                            EXPRKIND.DEC,
                            AddSideEffects(treeNode, argExpr1, argExpr2, false, false),
                            null);
                    }
                    else if (dec == -1)
                    {
                        return BindPredefOpAsUD(
                            treeNode,
                            EXPRKIND.INC,
                            AddSideEffects(treeNode, argExpr1, argExpr2, false, false),
                            null);
                    }
                }
            }

            return BindPredefOpAsUD(treeNode, exprKind, argExpr1, argExpr2);

        LBothConst:

            decimal dec1;
            decimal dec2;
            decimal decRes = default(decimal);
            bool resBool = false;
            bool isBool = false;
            //HRESULT hr = NOERROR;
            Exception resException = null;

            dec1 = (argConstExpr1 as EXPRCONSTANT).ConstVal.GetDecimal();
            dec2 = (argConstExpr2 as EXPRCONSTANT).ConstVal.GetDecimal();

            // Do the operation.
            switch (exprKind)
            {
                case EXPRKIND.ADD:
                    try
                    {
                        decRes = checked(dec1 + dec2);
                    }
                    catch (OverflowException ex)
                    {
                        resException = ex;
                        decRes = unchecked(dec1 + dec2);
                    }
                    break;

                case EXPRKIND.SUB:
                    try
                    {
                        decRes = checked(dec1 - dec2);
                    }
                    catch (OverflowException ex)
                    {
                        resException = ex;
                        decRes = unchecked(dec1 - dec2);
                    }
                    break;

                case EXPRKIND.MUL:
                    try
                    {
                        decRes = checked(dec1 * dec2);
                    }
                    catch (OverflowException ex)
                    {
                        resException = ex;
                        decRes = unchecked(dec1 * dec2);
                    }
                    break;

                case EXPRKIND.DIV:
                    //if ((DECIMAL_HI32(dec2) | DECIMAL_LO32(dec2) | DECIMAL_MID32(dec2)) == 0)
                    if (dec2 == Decimal.Zero)
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_IntDivByZero);
                        return NewError(treeNode, decimalTypeSym);
                    }

                    try
                    {
                        decRes = checked(dec1 / dec2);
                    }
                    catch (OverflowException ex)
                    {
                        resException = ex;
                        decRes = unchecked(dec1 / dec2);
                    }
                    break;

                case EXPRKIND.MOD:
                    {
                        /* n % d = n - d * truncate(n/d) */
                        //decimal decDiv, decTrunc, decProd;

                        //if ((DECIMAL_HI32(dec2) | DECIMAL_LO32(dec2) | DECIMAL_MID32(dec2)) == 0)
                        if (dec2 == Decimal.Zero)
                        {
                            Compiler.Error(treeNode, CSCERRID.ERR_IntDivByZero);
                            return NewError(treeNode, decimalTypeSym);
                        }

                        //hr = Util.VarDecDiv(&dec1, &dec2, &decDiv);
                        //if (SUCCEEDED(hr) &&
                        //    SUCCEEDED(hr = Util.VarDecFix(&decDiv, &decTrunc)) &&
                        //    SUCCEEDED(hr = Util.VarDecMul(&decTrunc, &dec2, &decProd)))
                        //{
                        //    hr = Util.VarDecSub(&dec1, &decProd, &decRes);
                        //}

                        try
                        {
                            decRes = checked(dec1 % dec2);
                        }
                        catch (OverflowException ex)
                        {
                            resException = ex;
                            decRes = unchecked(dec1 % dec2);
                        }
                        break;
                    }

                case EXPRKIND.EQ:
                    isBool = true;
                    resBool = (dec1 == dec2);
                    break;

                case EXPRKIND.NE:
                    isBool = true;
                    resBool = (dec1 != dec2);
                    break;

                case EXPRKIND.LE:
                    isBool = true;
                    resBool = (dec1 <= dec2);
                    break;

                case EXPRKIND.LT:
                    isBool = true;
                    resBool = (dec1 < dec2);
                    break;

                case EXPRKIND.GE:
                    isBool = true;
                    resBool = (dec1 >= dec2);
                    break;

                case EXPRKIND.GT:
                    isBool = true;
                    resBool = (dec1 > dec2);
                    break;

                default:
                    DebugUtil.Assert(false, "Bad exprKind");
                    break;
            }

            if (resException != null)
            {
                string message = CharUtil.GetLineByIndex(resException.ToString(), 0);
                Compiler.Error(treeNode, CSCERRID.ERR_DecConstError, new ErrArg(message));
                return NewError(treeNode, isBool ? GetRequiredPredefinedType(PREDEFTYPE.BOOL) : decimalTypeSym);
            }

            // Allocate the result node.
            CONSTVAL cv = new CONSTVAL();
            EXPR resExpr;

            if (isBool)
            {
                cv.SetBool(resBool);
                resExpr = NewExprConstant(treeNode, GetRequiredPredefinedType(PREDEFTYPE.BOOL), cv);
            }
            else
            {
                //cv.decVal = (DECIMAL *) allocator.Alloc(sizeof(DECIMAL));
                cv.SetDecimal(decRes);
                resExpr = NewExprConstant(treeNode, decimalTypeSym, cv);
            }

            resExpr = AddSideEffects(treeNode, resExpr, argExpr2, true, false);
            return AddSideEffects(treeNode, resExpr, argExpr1, true, false);
        }

        //private EXPR * BindStrBinOp(BASENODE * tree, EXPRKIND ek, uint flags, EXPR * arg1, EXPR * arg2);

        //--------------------------------------------------
        // FUNCBREC.BindShiftOp
        //
        /// <summary>
        /// Bind a shift operator: &lt;&lt;, &gt;&gt;.
        /// These can have integer or long first operands,
        /// and second operand must be int.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindShiftOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            DebugUtil.Assert(exprKind == EXPRKIND.LSHIFT || exprKind == EXPRKIND.RSHIFT);
            DebugUtil.Assert(argExpr1.TypeSym.IsPredefined());
            DebugUtil.Assert(argExpr2.TypeSym.IsPredefType(PREDEFTYPE.INT));

            TYPESYM operatorTypeSym = argExpr1.TypeSym;
            PREDEFTYPE operatorPt = argExpr1.TypeSym.GetPredefType();

            DebugUtil.Assert(
                operatorPt == PREDEFTYPE.INT ||
                operatorPt == PREDEFTYPE.UINT ||
                operatorPt == PREDEFTYPE.LONG ||
                operatorPt == PREDEFTYPE.ULONG);

            CONSTVAL cv = new CONSTVAL();
            cv.SetInt((operatorPt == PREDEFTYPE.LONG || operatorPt == PREDEFTYPE.ULONG) ? 0x3f : 0x1f);

            EXPR resExpr;

            EXPR argConstExpr2 = argExpr2.GetConst();
            if (argConstExpr2 != null)
            {
                cv.SetInt((argConstExpr2 as EXPRCONSTANT).ConstVal.GetInt() & cv.GetInt());	// number of shift
                if (cv.GetInt() == 0)
                {
                    return AddSideEffects(treeNode, argExpr1, argExpr2, false, false);
                }
                argExpr2 = AddSideEffects(
                    argExpr2.TreeNode,
                    NewExprConstant(argExpr2.TreeNode, argExpr2.TypeSym, cv),
                    argExpr2,
                    true,
                    false);
            }
            else
            {
                argExpr2 = NewExprBinop(
                    argExpr2.TreeNode,
                    EXPRKIND.BITAND,
                    argExpr2.TypeSym,
                    argExpr2,
                    NewExprConstant(null, argExpr2.TypeSym, cv));
            }

            EXPR argConstExpr1 = argExpr1.GetConst();
            if (argConstExpr1 != null && argConstExpr1.IsZero(false))
            {
                return AddSideEffects(treeNode, argExpr1, argExpr2, false, false);
            }

            if (argConstExpr1 == null || argConstExpr2 == null)
            {
                return NewExprBinop(treeNode, exprKind, operatorTypeSym, argExpr1, argExpr2);
            }
            DebugUtil.Assert(argExpr1.TypeSym == operatorTypeSym);
            DebugUtil.Assert(argExpr2.TypeSym.IsPredefType(PREDEFTYPE.INT));

            // Both args are constant so compute the result.
            int cbit = cv.GetInt();

            // Fill in the CONSTVAL.
            if (operatorPt == PREDEFTYPE.LONG || operatorPt == PREDEFTYPE.ULONG)
            {
                DebugUtil.Assert(0 <= cbit && cbit < 0x40);

                //unsigned __int64 u1 = *argConstExpr1.asCONSTANT().getVal().ulongVal;
                ulong ul1 = (argConstExpr1 as EXPRCONSTANT).ConstVal.GetULong();
                ulong ulval = 0;
                //cv.ulongVal = (unsigned __int64 *) allocator.Alloc(sizeof(unsigned __int64));

                switch (exprKind)
                {
                    case EXPRKIND.LSHIFT:
                        //cv.SetULong(ul1 << cbit);
                        ulval = ul1 << cbit;
                        break;

                    case EXPRKIND.RSHIFT:
                        //cv.SetULong((operatorPt == PREDEFTYPE.LONG) ?
                        //    //(unsigned __int64)((__int64)u1 >> cbit) : (u1 >> cbit);
                        //    (ulong)((long)ul1 >> cbit) : (ul1 >> cbit));
                        ulval = (operatorPt == PREDEFTYPE.LONG)
                            ? (ulong)((long)ul1 >> cbit) : (ul1 >> cbit);
                        break;

                    default:
                        DebugUtil.Assert(false, "Unknown op");
                        //cv.SetULong(0);
                        ulval = 0;
                        break;
                }
                if (operatorPt == PREDEFTYPE.LONG)
                {
                    cv.SetLong((long)ulval);
                }
                else
                {
                    cv.SetULong(ulval);
                }
            }
            else
            {
                DebugUtil.Assert(0 <= cbit && cbit < 0x20);
                uint ui1 = (argConstExpr1 as EXPRCONSTANT).ConstVal.GetUInt();
                uint uival = 0;

                switch (exprKind)
                {
                    case EXPRKIND.LSHIFT:
                        //cv.SetUInt(ui1 << cbit);
                        uival = ui1 << cbit;
                        break;

                    case EXPRKIND.RSHIFT:
                        //cv.SetUInt((operatorPt == PREDEFTYPE.INT)
                        //    ? (uint)((int)ui1 >> cbit) : (ui1 >> cbit));
                        uival = (operatorPt == PREDEFTYPE.INT)
                            ? (uint)((int)ui1 >> cbit) : (ui1 >> cbit);
                        break;

                    default:
                        DebugUtil.Assert(false, "Unknown op");
                        //cv.SetUInt(0);
                        uival = 0;
                        break;
                }
                if (operatorPt == PREDEFTYPE.INT)
                {
                    cv.SetInt((int)uival);
                }
                else
                {
                    cv.SetUInt(uival);
                }
            }

            resExpr = NewExprConstant(treeNode, GetRequiredPredefinedType(operatorPt), cv);
            resExpr = AddSideEffects(treeNode, resExpr, argExpr2, true, false);
            return AddSideEffects(treeNode, resExpr, argExpr1, true, false);
        }

        //--------------------------------------------------
        // FUNCBREC.BindBoolBinOp
        //
        /// <summary>
        /// Bind a bool binary operator: ==, !=, &amp;&amp;, ||, &amp;, |, ^.
        /// If both operands are constant, the result will be a constant also.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindBoolBinOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            DebugUtil.Assert(
                argExpr1.TypeSym.IsPredefType(PREDEFTYPE.BOOL) &&
                argExpr2.TypeSym.IsPredefType(PREDEFTYPE.BOOL));

            // Get the result type and operand type.
            TYPESYM boolTypeSym = GetRequiredPredefinedType(PREDEFTYPE.BOOL);

            // For optimizations and for better definite assignment and unreachable code analysis,
            // we determine whether the result values of op1 and op2 are constants. The ops may
            // have side effects even though the result values are constant, eg, (F() | true).
            // We walk past any EXPRKIND.SEQUENCE nodes to check for a constant result. If one or both
            // results are constant, the result may be constant (or optimizable) but any side effects
            // still need to be performed (and short-circuited in the case of && and ||).

            //#define NOT(a) newExprBinop(treeNode, EXPRKIND.LOGNOT, boolTypeSym, (a), null)
            //#define VAL(a) newExprConstant(treeNode, boolTypeSym, ConstValInit(a))

            // Determine if argExpr1 has a constant value.
            // Strip off EXPRKIND.SEQUENCE for constant checking.
            EXPR argConstExpr1 = argExpr1.GetConst();
            EXPR argConstExpr2 = argExpr2.GetConst();

            if (argConstExpr1 == null && argConstExpr2 == null)
            {
                // General case - no optimizations.
                return NewExprBinop(treeNode, exprKind, boolTypeSym, argExpr1, argExpr2);
            }

            bool f1 = argConstExpr1 != null && (argConstExpr1 as EXPRCONSTANT).ConstVal.GetBool();
            bool f2 = argConstExpr2 != null && (argConstExpr2 as EXPRCONSTANT).ConstVal.GetBool();

            int nConst = (argConstExpr1 != null ? 1 : 0) | (argConstExpr2 != null ? 2 : 0);
            DebugUtil.Assert(1 <= nConst && nConst <= 3);

            bool fInvert = false;
            EXPR resExpr;

            switch (exprKind)
            {
                default:
                    DebugUtil.Assert(false, "Shouldn't happen");
                    return BadOperatorTypesError(treeNode, argExpr1, argExpr2, boolTypeSym);

                case EXPRKIND.BITXOR: // Same as NE.
                case EXPRKIND.NE:
                    fInvert = true; // Fall through.
                    goto case EXPRKIND.EQ;

                case EXPRKIND.EQ:
                    switch (nConst)
                    {
                        case 1: // argExpr1
                            resExpr = (f1 ^ fInvert) ?
                                argExpr2 :
                                NewExprBinop(treeNode, EXPRKIND.LOGNOT, boolTypeSym, argExpr2, null);
                            return AddSideEffects(treeNode, resExpr, argExpr1, true, false);

                        case 2: // argExpr2
                            resExpr = (f2 ^ fInvert) ?
                                argExpr1 :
                                NewExprBinop(treeNode, EXPRKIND.LOGNOT, boolTypeSym, argExpr1, null);
                            return AddSideEffects(treeNode, resExpr, argExpr2, false, false);

                        case 3: // Both
                            //resExpr = VAL(!(f1 ^ f2 ^ fInvert));
                            resExpr = NewExprConstant(
                                treeNode,
                                boolTypeSym,
                                new ConstValInit(!(f1 ^ f2 ^ fInvert)));
                            resExpr = AddSideEffects(treeNode, resExpr, argExpr2, true, false);
                            return AddSideEffects(treeNode, resExpr, argExpr1, true, false);
                    }
                    break;

                case EXPRKIND.BITOR:
                    fInvert = true; // Fall through.
                    goto case EXPRKIND.BITAND;

                case EXPRKIND.BITAND:
                    switch (nConst)
                    {
                        case 1: // argExpr1
                            return (f1 ^ fInvert) ?
                                AddSideEffects(treeNode, argExpr2, argExpr1, true, false) :
                                AddSideEffects(treeNode, argExpr1, argExpr2, false, false);

                        case 2: // argExpr2
                            return (f2 ^ fInvert) ?
                                AddSideEffects(treeNode, argExpr1, argExpr2, false, false) :
                                AddSideEffects(treeNode, argExpr2, argExpr1, true, false);

                        case 3: // Both
                            //resExpr = VAL(fInvert ? (f1 | f2) : (f1 & f2));
                            resExpr = NewExprConstant(
                                treeNode,
                                boolTypeSym,
                                new ConstValInit(fInvert ? (f1 | f2) : (f1 & f2)));
                            resExpr = AddSideEffects(treeNode, resExpr, argExpr2, true, false);
                            return AddSideEffects(treeNode, resExpr, argExpr1, true, false);
                    }
                    break;

                case EXPRKIND.LOGOR:
                    fInvert = true; // Fall through.
                    goto case EXPRKIND.LOGAND;

                case EXPRKIND.LOGAND:
                    switch (nConst)
                    {
                        case 1: // argExpr1
                            if (f1 ^ fInvert)
                                return AddSideEffects(treeNode, argExpr2, argExpr1, true, false);
                            // Since these are the short-circuiting operators we don't add side effects for argExpr2!
                            // Warn if we're dropping code that has side effects.
                            if (argExpr2.HasSideEffects(Compiler))
                            {
                                Compiler.Error(argExpr2.TreeNode, CSCERRID.WRN_UnreachableExpr);
                            }
                            // Since argExpr2 isn't a constant, we need to make the result a non-constant (and non-lvalue).
                            return EnsureNonConstNonLvalue(treeNode, argExpr1);

                        case 2: // argExpr2
                            if (argExpr2.HasSideEffects(Compiler))
                            {
                                resExpr = NewExprBinop(treeNode, exprKind, boolTypeSym, argExpr1, argExpr2);
                            }
                            else
                            {
                                resExpr = argExpr1;
                            }
                            if (!(f2 ^ fInvert))
                            {
                                // Result is always f2, but execution of f2 is conditioned on f1.
                                resExpr = AddSideEffects(
                                    treeNode,
                                    NewExprConstant(treeNode, boolTypeSym, new ConstValInit(f2)),
                                    resExpr,
                                    true,
                                    true);
                            }
                            return EnsureNonConstNonLvalue(treeNode, resExpr);

                        case 3: // Both
                            if (f1 ^ fInvert)
                            {
                                //resExpr = VAL(f2);
                                resExpr = NewExprConstant(treeNode, boolTypeSym, new ConstValInit(f2));
                                resExpr = AddSideEffects(treeNode, resExpr, argExpr2, true, false);
                                return AddSideEffects(treeNode, resExpr, argExpr1, true, false);
                            }

                            // Since these are the short-circuiting operators we don't add side effects for argExpr2!
                            // Warn if we're dropping code that has side effects.
                            if (argExpr2.HasSideEffects(Compiler))
                            {
                                Compiler.Error(argExpr2.TreeNode, CSCERRID.WRN_UnreachableExpr);
                            }
                            // If either isn't a constant, we need to make the result a non-constant.
                            if (argExpr1.Kind == EXPRKIND.CONSTANT && argExpr2.Kind == EXPRKIND.CONSTANT)
                            {
                                return argExpr1;
                            }
                            return EnsureNonConstNonLvalue(treeNode, argExpr1);
                    }
                    break;
            }

            //#undef NOT
            //#undef VAL

            DebugUtil.Assert(false, "Shouldn't be here");
            return NewError(treeNode, boolTypeSym);
        }

        //--------------------------------------------------
        // FUNCBREC.BindBoolBitwiseOp
        //
        /// <summary>
        /// Bind a bitwise bool binary operator: &amp;, |.
        /// This handles the nullable cases directly and forwards the non-nullable case to BindBoolBinOp.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindBoolBitwiseOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            DebugUtil.Assert(exprKind == EXPRKIND.BITAND || exprKind == EXPRKIND.BITOR);
            DebugUtil.Assert(
                argExpr1.TypeSym.IsPredefType(PREDEFTYPE.BOOL) ||
                argExpr1.TypeSym.IsNUBSYM && (argExpr1.TypeSym as NUBSYM).BaseTypeSym.IsPredefType(PREDEFTYPE.BOOL));
            DebugUtil.Assert(
                argExpr2.TypeSym.IsPredefType(PREDEFTYPE.BOOL) ||
                argExpr2.TypeSym.IsNUBSYM && (argExpr2.TypeSym as NUBSYM).BaseTypeSym.IsPredefType(PREDEFTYPE.BOOL));

            if (!argExpr1.TypeSym.IsNUBSYM && !argExpr2.TypeSym.IsNUBSYM)
            {
                return BindBoolBinOp(treeNode, exprKind, flags, argExpr1, argExpr2);
            }

            if (argExpr1.TypeSym.IsNUBSYM)
            {
                argExpr1 = StripNubCtor(argExpr1);
            }
            if (argExpr2.TypeSym.IsNUBSYM)
            {
                argExpr2 = StripNubCtor(argExpr2);
            }

            if (!argExpr1.TypeSym.IsNUBSYM && !argExpr2.TypeSym.IsNUBSYM)
            {
                // We stripped away all the NUBSYMs. The result is simply a wrap
                // of the normal result.
                return BindNubNew(treeNode, BindBoolBinOp(treeNode, exprKind, flags, argExpr1, argExpr2));
            }

            EXPR constExpr;
            EXPR condExpr;
            EXPR resExpr;
            int iexpr;

            // Get the result type.
            TYPESYM boolTypeSym = GetRequiredPredefinedType(PREDEFTYPE.BOOL);
            TYPESYM resTypeSym = Compiler.MainSymbolManager.GetNubType(boolTypeSym);

            EXPR[] rgexpr = { argExpr1, argExpr2 };
            //rgexpr[0] = expr1;
            //rgexpr[1] = expr2;

            bool fInvert = false;

            NubInfo nubInfo = new NubInfo();
            nubInfo.Init();

            switch (exprKind)
            {
                default:
                    DebugUtil.Assert(false, "Shouldn't happen");
                    return BadOperatorTypesError(treeNode, rgexpr[0], rgexpr[1], resTypeSym);

                case EXPRKIND.BITAND:
                    //----------------------------------------
                    // When only b is nullable, generate:
                    //     rev(a, tmp = b) ? tmp : new bool?(false);
                    // When only a is nullable, generate:
                    //     seq(tmp = a, b) ? tmp : new bool?(false);
                    // When both a and b are nullable, generate the equivalent of:
                    //     tmp1 = a;
                    //     tmp2 = b;
                    //     tmp1.GetValOrDef() || !(tmp2.GetValOrDef() || tmp1.HasValue) ? tmp2 : tmp1;
                    //----------------------------------------
                    fInvert = true;
                    // Fall through.
                    goto case EXPRKIND.BITOR;

                case EXPRKIND.BITOR:
                    //----------------------------------------
                    // When only b is nullable, generate:
                    //     rev(a, tmp = b) ? new bool?(true) : tmp;
                    // When only a is nullable, generate:
                    //     seq(tmp = a, b) ? new bool?(true) : tmp;
                    // When both a and b are nullable, generate the equivalent of:
                    //     tmp1 = a;
                    //     tmp2 = b;
                    //     tmp1.GetValOrDef() || !(tmp2.GetValOrDef() || tmp1.HasValue) ? tmp1 : tmp2;
                    //----------------------------------------
                    for (iexpr = 0; iexpr < 2; iexpr++)
                    {
                        if (rgexpr[iexpr].TypeSym.IsNUBSYM) continue;

                        constExpr = rgexpr[iexpr].GetConst();
                        if (constExpr != null)
                        {
                            //if (!constExpr.AsCONSTANT.ConstVal.IntValue ^ fInvert) {
                            if ((!(constExpr as EXPRCONSTANT).ConstVal.GetBool()) ^ fInvert)
                            {
                                // seq(a, b);
                                return AddSideEffects(
                                    treeNode, rgexpr[1 - iexpr], rgexpr[iexpr], iexpr == 0, true);
                            }

                            // seq(a, b, new bool?(!fInvert));
                            resExpr = AddSideEffects(
                                treeNode, BindNubConstBool(treeNode, !fInvert), rgexpr[1], true, true);
                            return AddSideEffects(treeNode, resExpr, rgexpr[0], true, true);
                        }

                        BindNubSave(rgexpr[1 - iexpr], ref nubInfo, 1 - iexpr, true);
                        resExpr = AddSideEffects(
                            treeNode, rgexpr[iexpr], nubInfo.PreExpr[1 - iexpr], iexpr != 0, true);
                        resExpr = BindQMark(
                            treeNode,
                            resExpr,
                            BindNubConstBool(treeNode, !fInvert),
                            nubInfo.TmpExpr[1 - iexpr],
                            fInvert);
                        return AddSideEffects(treeNode, resExpr, nubInfo.PostExpr[1 - iexpr], false, true);
                    }

                    // Both are nullable.
                    DebugUtil.Assert(rgexpr[0].TypeSym.IsNUBSYM && rgexpr[1].TypeSym.IsNUBSYM);
                    bool[] rgfNull =
                    {
                        !BindNubSave(rgexpr[0], ref nubInfo, 0, true),
                        !BindNubSave(rgexpr[1], ref nubInfo, 1, true)
                    };
                    //rgfNull[0] = !BindNubSave(rgexpr[0], nubInfo, 0, true);
                    //rgfNull[1] = !BindNubSave(rgexpr[1], nubInfo, 1, true);

                    if (rgfNull[0] == rgfNull[1])
                    {
                        if (rgfNull[0])
                        {
                            // Both are null, so result is null.
                            // seq(a, b);
                            return AddSideEffects(treeNode, rgexpr[1], rgexpr[0], true, true);
                        }

                        EXPR leftExpr = BindNubGetValOrDef(treeNode, nubInfo.TmpExpr[1]);
                        EXPR rightExpr = BindNubHasValue(treeNode, nubInfo.TmpExpr[0], true);
                        rightExpr = NewExprBinop(treeNode, EXPRKIND.LOGOR, boolTypeSym, leftExpr, rightExpr);
                        rightExpr = NewExprBinop(treeNode, EXPRKIND.LOGNOT, boolTypeSym, rightExpr, null);
                        leftExpr = BindNubGetValOrDef(treeNode, nubInfo.TmpExpr[0]);
                        leftExpr = AddSideEffects(treeNode, leftExpr, nubInfo.PreExpr[1], true, true);
                        leftExpr = AddSideEffects(treeNode, leftExpr, nubInfo.PreExpr[0], true, true);
                        condExpr = NewExprBinop(treeNode, EXPRKIND.LOGOR, boolTypeSym, leftExpr, rightExpr);
                        iexpr = 0;
                    }
                    else
                    {
                        iexpr = rgfNull[0] ? 1 : 0;

                        // When iexpr == 1, rgexpr[0] is null. Evaluate as: seq(tmp1 = a, tmp2 = b).GetValOrDef() ? tmp2 : tmp1;
                        // Note that tmp1 will not actually be code-gened.
                        condExpr = AddSideEffects(
                            treeNode, nubInfo.PreExpr[iexpr], nubInfo.PreExpr[1 - iexpr], iexpr != 0, true);
                        condExpr = BindNubGetValOrDef(treeNode, condExpr);
                    }
                    return BindQMark(
                        treeNode,
                        condExpr,
                        BindNubFetchAndFree(treeNode, ref nubInfo, iexpr),
                        BindNubFetchAndFree(treeNode, ref nubInfo, 1 - iexpr),
                        fInvert);
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindDelegateBinOp
        //
        /// <summary>
        /// <para>Handles delegate binary operators.</para>
        /// <para>(BindDelBinOp in sscil.)</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindDelegateBinOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            if (exprKind == EXPRKIND.EQ || exprKind == EXPRKIND.NE)
            {
                if (argExpr1.IsNull() || argExpr2.IsNull())
                {
                    return BindRefCmpOp(treeNode, exprKind, flags, argExpr1, argExpr2);
                }

                DebugUtil.Assert(
                    argExpr1.TypeSym == argExpr2.TypeSym &&
                    (argExpr1.TypeSym.IsDelegateType() ||
                    argExpr1.TypeSym.IsPredefType(PREDEFTYPE.DELEGATE)));

                argExpr1 = MustConvert(
                    argExpr1,
                    GetRequiredPredefinedType(PREDEFTYPE.DELEGATE),
                    ConvertTypeEnum.NOUDC);

                argExpr2 = MustConvert(
                    argExpr2,
                    GetRequiredPredefinedType(PREDEFTYPE.DELEGATE),
                    ConvertTypeEnum.NOUDC);

                return BindPredefOpAsUD(treeNode, exprKind, argExpr1, argExpr2);
            }
            DebugUtil.Assert(exprKind == EXPRKIND.ADD || exprKind == EXPRKIND.SUB);
            DebugUtil.Assert(argExpr1.TypeSym == argExpr2.TypeSym && argExpr1.TypeSym.IsDelegateType());

            // Construct argument list from the two delegates.
            EXPR argsExpr = NewExprBinop(null, EXPRKIND.LIST, GetVoidType(), argExpr1, argExpr2);

            // Find and bind the Delegate.Combine or Delegate.Remove call.
            EXPR expr = BindPredefMethToArgs(
                treeNode,
                (exprKind == EXPRKIND.ADD ? PREDEFNAME.COMBINE : PREDEFNAME.REMOVE),
                GetRequiredPredefinedType(PREDEFTYPE.DELEGATE),
                null,
                argsExpr,
                null);

            // Cast the result to the delegate type.
            return MustCastCore(expr, argExpr1.TypeSym, treeNode, 0);
        }


        //--------------------------------------------------
        // FUNCBREC.BindEnumBinOp
        //
        /// <summary>
        /// Handles enum binary operators.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindEnumBinOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            DebugUtil.Assert(argExpr1.TypeSym.IsEnumType() || argExpr2.TypeSym.IsEnumType());

            AGGTYPESYM typeSym1 = argExpr1.TypeSym as AGGTYPESYM;
            AGGTYPESYM typeSym2 = argExpr2.TypeSym as AGGTYPESYM;
            AGGTYPESYM enumTypeSym = typeSym1.IsEnumType() ? typeSym1 : typeSym2;

            DebugUtil.Assert(typeSym1 == enumTypeSym || typeSym1 == enumTypeSym.UnderlyingEnumType());
            DebugUtil.Assert(typeSym2 == enumTypeSym || typeSym2 == enumTypeSym.UnderlyingEnumType());

            AGGTYPESYM dstTypeSym = enumTypeSym;

            switch (exprKind)
            {
                case EXPRKIND.BITAND:
                case EXPRKIND.BITOR:
                case EXPRKIND.BITXOR:
                    DebugUtil.Assert(typeSym1 == typeSym2);
                    break;

                case EXPRKIND.ADD:
                    DebugUtil.Assert(typeSym1 != typeSym2);
                    break;

                case EXPRKIND.SUB:
                    if (typeSym1 == typeSym2)
                    {
                        dstTypeSym = enumTypeSym.UnderlyingEnumType();
                    }
                    break;

                default:
                    DebugUtil.Assert(
                        EXPRKIND.RELATIONAL_MIN <= exprKind &&
                        exprKind <= EXPRKIND.RELATIONAL_MAX);
                    dstTypeSym = GetRequiredPredefinedType(PREDEFTYPE.BOOL);
                    break;
            }

            PREDEFTYPE ptOp;

            switch (enumTypeSym.FundamentalType())
            {
                default:
                    // Promote all smaller types to int.
                    ptOp = PREDEFTYPE.INT;
                    break;

                case FUNDTYPE.U4:
                    ptOp = PREDEFTYPE.UINT;
                    break;

                case FUNDTYPE.I8:
                    ptOp = PREDEFTYPE.LONG;
                    break;

                case FUNDTYPE.U8:
                    ptOp = PREDEFTYPE.ULONG;
                    break;
            }

            TYPESYM opTypeSym = GetRequiredPredefinedType(ptOp);
            argExpr1 = MustCast(argExpr1, opTypeSym, ConvertTypeEnum.NOUDC);
            argExpr2 = MustCast(argExpr2, opTypeSym, ConvertTypeEnum.NOUDC);

            EXPR resExpr = BindIntOp(treeNode, exprKind, flags, argExpr1, argExpr2, ptOp);

            if (resExpr == null || !resExpr.IsOK)
            {
                return NewError(treeNode, dstTypeSym);
            }

            if (resExpr.TypeSym != dstTypeSym)
            {
                DebugUtil.Assert(!dstTypeSym.IsPredefType(PREDEFTYPE.BOOL));
                resExpr = MustCast(resExpr, dstTypeSym, ConvertTypeEnum.NOUDC);
            }

            return resExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindStrCmpOp
        //
        /// <summary>
        /// Handles string equality.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindStrCmpOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            DebugUtil.Assert(exprKind == EXPRKIND.EQ || exprKind == EXPRKIND.NE);
            DebugUtil.Assert(
                argExpr1.TypeSym.IsPredefType(PREDEFTYPE.STRING) &&
                argExpr2.TypeSym.IsPredefType(PREDEFTYPE.STRING));

            if (argExpr1.Kind == EXPRKIND.CONSTANT && argExpr2.Kind == EXPRKIND.CONSTANT)
            {
                // Both strings are constants. Compare values at compile time.
                bool fRes;

                string str1 = (argExpr1 as EXPRCONSTANT).GetStringValue();
                string str2 = (argExpr2 as EXPRCONSTANT).GetStringValue();
                if (str1 == null || str2 == null)
                {
                    fRes = (str1 == str2);
                }
                else
                {
                    fRes = (str1 == str2);
                }

                if (exprKind == EXPRKIND.NE) fRes = !fRes;

                return NewExprConstant(treeNode, GetRequiredPredefinedType(PREDEFTYPE.BOOL), new ConstValInit(fRes));
            }

            if (argExpr1.IsNull() || argExpr2.IsNull())
            {
                return BindRefCmpOp(treeNode, exprKind, flags, argExpr1, argExpr2);
            }

            return BindPredefOpAsUD(treeNode, exprKind, argExpr1, argExpr2);
        }

        //--------------------------------------------------
        // FUNCBREC.BindRefCmpOp
        //
        /// <summary>
        /// Handles reference equality operators.
        /// Type variables come through here.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindRefCmpOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            DebugUtil.Assert(exprKind == EXPRKIND.EQ || exprKind == EXPRKIND.NE);

            // Check if maybe you are making a mistake... :)
            if (argExpr1.TypeSym != argExpr2.TypeSym)
            {
                if ((argExpr2.Kind != EXPRKIND.CONSTANT || (argExpr2 as EXPRCONSTANT).GetStringValue() != null)
                    && HasSelfCompare(argExpr1.TypeSym, exprKind))
                {
                    Compiler.Error(treeNode, CSCERRID.WRN_BadRefCompareRight, new ErrArg(argExpr1.TypeSym));
                }
                else if (
                    (argExpr1.Kind != EXPRKIND.CONSTANT || (argExpr1 as EXPRCONSTANT).GetStringValue() != null)
                    && HasSelfCompare(argExpr2.TypeSym, exprKind))
                {
                    Compiler.Error(treeNode, CSCERRID.WRN_BadRefCompareLeft, new ErrArg(argExpr2.TypeSym));
                }
            }

            if (argExpr1.Kind == EXPRKIND.CONSTANT && argExpr2.Kind == EXPRKIND.CONSTANT)
            {
                // Both references are constants.  Compare values at compile time.
                // Only null vs. non-null can possibly matter here.
                bool fRes = (
                    (argExpr1 as EXPRCONSTANT).GetStringValue() == null &&
                    (argExpr2 as EXPRCONSTANT).GetStringValue() == null);
                if (exprKind == EXPRKIND.NE)
                {
                    fRes = !fRes;
                }
                return NewExprConstant(treeNode, GetRequiredPredefinedType(PREDEFTYPE.BOOL), new ConstValInit(fRes));
            }

            // Must box type variables for the verifier.
            argExpr1 = MustConvert(argExpr1, GetRequiredPredefinedType(PREDEFTYPE.OBJECT), ConvertTypeEnum.NOUDC);
            argExpr2 = MustConvert(argExpr2, GetRequiredPredefinedType(PREDEFTYPE.OBJECT), ConvertTypeEnum.NOUDC);

            return NewExprBinop(treeNode, exprKind, GetRequiredPredefinedType(PREDEFTYPE.BOOL), argExpr1, argExpr2);
        }


        //--------------------------------------------------
        // FUNCBREC.BindPtrBinOp
        //
        /// <summary>
        /// Handles pointer binary operators (+ and -).
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPtrBinOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            DebugUtil.Assert(argExpr1.TypeSym.IsPTRSYM || argExpr2.TypeSym.IsPTRSYM);
            DebugUtil.Assert(exprKind == EXPRKIND.ADD || exprKind == EXPRKIND.SUB);
            EXPR expr;

            CheckUnsafe(treeNode, null, CSCERRID.ERR_UnsafeNeeded, null);

            if (exprKind == EXPRKIND.SUB && argExpr1.TypeSym == argExpr2.TypeSym)
            {
                if ((argExpr1.TypeSym as PTRSYM).BaseTypeSym.IsVOIDSYM)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_VoidError);
                    return NewError(treeNode, GetRequiredPredefinedType(PREDEFTYPE.LONG));
                }

                // Substract and divide by the size of the underlying type...
                expr = NewExprBinop(
                    treeNode,
                    EXPRKIND.SUB,
                    GetRequiredPredefinedType(PREDEFTYPE.INTPTR),
                    argExpr1,
                    argExpr2); // the type here must be signed...
                expr = NewExprBinop(
                    treeNode,
                    EXPRKIND.DIV,
                    GetRequiredPredefinedType(PREDEFTYPE.INTPTR),
                    expr,
                    BindSizeOf(treeNode, argExpr1.TypeSym.ParentSym as TYPESYM));
                EXPRCAST castExpr = NewExpr(
                    treeNode,
                    EXPRKIND.CAST,
                    GetRequiredPredefinedType(PREDEFTYPE.LONG)) as EXPRCAST;
                castExpr.Operand = expr;

                return castExpr;
            }

            EXPR numExpr;
            EXPR prtExpr;

            if (argExpr1.TypeSym.IsPTRSYM)
            {
                numExpr = argExpr2;
                prtExpr = argExpr1;
            }
            else
            {
                DebugUtil.Assert(exprKind == EXPRKIND.ADD);
                numExpr = argExpr1;
                prtExpr = argExpr2;
            }
            DebugUtil.Assert(numExpr.TypeSym.IsPredefined());

            if ((prtExpr.TypeSym as PTRSYM).BaseTypeSym.IsVOIDSYM)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_VoidError);
                return NewError(treeNode, prtExpr.TypeSym);
            }

            EXPR sizeExpr = BindSizeOf(treeNode, prtExpr.TypeSym.ParentSym as TYPESYM);
            expr = BindPtrAddMul(treeNode, prtExpr, numExpr, sizeExpr, argExpr1.TypeSym.IsPTRSYM, exprKind);

            if (expr.Kind == exprKind)
            {
                expr.Flags |= flags;
            }
            return expr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindPtrCmpOp
        //
        /// <summary>
        /// Handles pointer comparison operators.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPtrCmpOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            DebugUtil.Assert(argExpr1.TypeSym.IsPTRSYM && argExpr2.TypeSym.IsPTRSYM);
            EXPR expr;

            CheckUnsafe(treeNode, null, CSCERRID.ERR_UnsafeNeeded, null);

            // this is just a simple direct comparison...
            expr = NewExprBinop(
                treeNode,
                exprKind,
                GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                argExpr1,
                argExpr2);
            expr.Flags |= flags;
            return expr;
        }

        // Unary operator binding.

        //--------------------------------------------------
        // FUNCBREC.BindStdUnaOp
        //
        /// <summary>
        /// Bind a standard unary operator.
        /// Takes care of user defined operators, predefined operators
        /// and lifting over nullable.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="operatorID"></param>
        /// <param name="argumentExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindStdUnaOp(BASENODE treeNode, OPERATOR operatorID, EXPR argumentExpr)
        {
            DebugUtil.Assert(argumentExpr != null);

            EXPRKIND exprKind;
            UnaOpKindEnum unaOpKind;
            EXPRFLAG flags = 0;
            EXPR expr = null;

            switch (operatorID)
            {
                case OPERATOR.UPLUS:
                    unaOpKind = UnaOpKindEnum.Plus;
                    exprKind = EXPRKIND.UPLUS;
                    break;

                case OPERATOR.NEG:
                    if (this.CheckedContext.IsNormal)
                    {
                        flags |= EXPRFLAG.CHECKOVERFLOW;
                    }
                    unaOpKind = UnaOpKindEnum.Minus;
                    exprKind = EXPRKIND.NEG;
                    break;

                case OPERATOR.BITNOT:
                    unaOpKind = UnaOpKindEnum.Tilde;
                    exprKind = EXPRKIND.BITNOT;
                    break;

                case OPERATOR.LOGNOT:
                    unaOpKind = UnaOpKindEnum.Bang;
                    exprKind = EXPRKIND.LOGNOT;
                    break;

                case OPERATOR.POSTINC:
                    flags |= EXPRFLAG.ISPOSTOP;
                    goto case OPERATOR.PREINC;

                case OPERATOR.PREINC:
                    if (this.CheckedContext.IsNormal)
                    {
                        flags |= EXPRFLAG.CHECKOVERFLOW;
                    }
                    unaOpKind = UnaOpKindEnum.IncDec;
                    exprKind = EXPRKIND.ADD;
                    break;

                case OPERATOR.POSTDEC:
                    flags |= EXPRFLAG.ISPOSTOP;
                    goto case OPERATOR.PREDEC;

                case OPERATOR.PREDEC:
                    if (this.CheckedContext.IsNormal)
                    {
                        flags |= EXPRFLAG.CHECKOVERFLOW;
                    }
                    unaOpKind = UnaOpKindEnum.IncDec;
                    exprKind = EXPRKIND.SUB;
                    break;

                default:
                    DebugUtil.Assert(false, "Bad op");
                    return BadOperatorTypesError(treeNode, argumentExpr, null, null);
            }

            UnaOpMaskEnum unaOpMask = (UnaOpMaskEnum)(1 << (int)unaOpKind);
            TYPESYM typeSym = argumentExpr.TypeSym;
            TYPESYM rawTypeSym = typeSym.StripNubs();
            Compiler.EnsureState(typeSym, AggStateEnum.Prepared);

            PREDEFTYPE predefType
                = typeSym.IsPredefined() ? typeSym.GetPredefType() : PREDEFTYPE.COUNT;
            PREDEFTYPE rawPredefType
                = rawTypeSym.IsPredefined() ? rawTypeSym.GetPredefType() : PREDEFTYPE.COUNT;

            List<UnaOpFullSig> unaOpFullSigList = new List<UnaOpFullSig>();
            UnaOpFullSig uofsTemp = null;

            //int unaOpFullSigCount = 0;
            int bestUnaOpFullSigIndex = -1;
            int minLiftUnaOpSigIndex;
            int unaOpSigIndex;
            int unaOpFullSigIndex;

            //--------------------------------------------------------
            // Find all applicable operator signatures.
            // First check for special ones (enum, ptr) and check for user defined ops.
            //--------------------------------------------------------

            if (rawPredefType > PREDEFTYPE.ULONG)
            {
                // Enum types are special in that they carry a set of "predefined" operators
                // (~ and inc/dec).
                if (rawTypeSym.IsEnumType())
                {
                    if ((unaOpMask & (UnaOpMaskEnum.Tilde | UnaOpMaskEnum.IncDec)) != 0)
                    {
                        // We have an exact match.
                        LiftFlagsEnum liftFlags = LiftFlagsEnum.None;
                        TYPESYM sigTypeSym = typeSym;

                        if (sigTypeSym.IsNUBSYM)
                        {
                            if ((sigTypeSym as NUBSYM).BaseTypeSym != rawTypeSym)
                            {
                                sigTypeSym = Compiler.MainSymbolManager.GetNubType(rawTypeSym);
                            }
                            liftFlags = LiftFlagsEnum.Lift1;
                        }

                        uofsTemp = new UnaOpFullSig();
                        uofsTemp.Set(
                            sigTypeSym,
                            unaOpKind == UnaOpKindEnum.Tilde ? BindUnaOpEnum.Enum : BindUnaOpEnum.None,
                            liftFlags);
                        bestUnaOpFullSigIndex = unaOpFullSigList.Count;
                        unaOpFullSigList.Add(uofsTemp);

                        goto LMatch;
                    }
                }
                else if (unaOpKind == UnaOpKindEnum.IncDec)
                {
                    // Check for pointers
                    if (typeSym.IsPTRSYM)
                    {
                        uofsTemp = new UnaOpFullSig();
                        uofsTemp.Set(
                            typeSym, BindUnaOpEnum.None, LiftFlagsEnum.None);
                        bestUnaOpFullSigIndex = unaOpFullSigList.Count;
                        unaOpFullSigList.Add(uofsTemp);
                        goto LMatch;
                    }

                    // Check for user defined inc/dec
                    EXPRMULTIGET getExpr = NewExpr(
                        argumentExpr.TreeNode,
                        EXPRKIND.MULTIGET,
                        argumentExpr.TypeSym) as EXPRMULTIGET;

                    EXPR valueExpr = BindUDUnop(
                        treeNode,
                        (exprKind - EXPRKIND.ADD + EXPRKIND.INC),
                        getExpr);

                    if (valueExpr != null)
                    {
                        EXPRMULTI multiExpr = NewExpr(
                            treeNode,
                            EXPRKIND.MULTI,
                            argumentExpr.TypeSym) as EXPRMULTI;
                        multiExpr.LeftExpr = argumentExpr;
                        multiExpr.Flags |= EXPRFLAG.ASSGOP | flags;
                        getExpr.MultiExpr = multiExpr;

                        if (!valueExpr.TypeSym.IsERRORSYM &&
                            valueExpr.TypeSym != argumentExpr.TypeSym)
                        {
                            valueExpr = MustConvert(valueExpr, argumentExpr.TypeSym, 0);
                        }

                        multiExpr.OperandExpr = valueExpr;
                        return multiExpr;
                    }
                    // Try for a predefined increment operator.
                }
                else
                {
                    // Check for user defined.
                    expr = BindUDUnop(treeNode, exprKind, argumentExpr);
                    if (expr != null)
                    {
                        return expr;
                    }
                }
            }

            //--------------------------------------------------------
            // Find applicable signatures....
            //--------------------------------------------------------
            minLiftUnaOpSigIndex = Compiler.FCanLift() ? 0 : UnaOpSigArray.Length;
            for (unaOpSigIndex = 0; unaOpSigIndex < UnaOpSigArray.Length; unaOpSigIndex++)
            {
                UnaOpSig uos = UnaOpSigArray[unaOpSigIndex];
                if ((uos.UnaOpMask & unaOpMask) == 0)
                {
                    continue;
                }

                ConvKindEnum convKind
                    = GetConvKind(predefType, UnaOpSigArray[unaOpSigIndex].PredefinedType);
                TYPESYM sigTypeSym = null;

                switch (convKind)
                {
                    default:
                        DebugUtil.Assert(false, "Shouldn't happen!");
                        goto case ConvKindEnum.None;

                    case ConvKindEnum.None:
                        continue;

                    case ConvKindEnum.Explicit:
                        if (argumentExpr.Kind != EXPRKIND.CONSTANT)
                        {
                            continue;
                        }
                        // Need to try to convert.
                        goto case ConvKindEnum.Unknown;

                    case ConvKindEnum.Unknown:
                        if (CanConvert(
                            argumentExpr,
                            sigTypeSym = GetOptionalPredefinedType(uos.PredefinedType),
                            0))
                        {
                            break;
                        }
                        if (unaOpSigIndex < minLiftUnaOpSigIndex)
                        {
                            continue;
                        }
                        sigTypeSym = Compiler.MainSymbolManager.GetNubType(sigTypeSym);
                        if (!CanConvert(argumentExpr, sigTypeSym, 0))
                        {
                            continue;
                        }
                        break;

                    case ConvKindEnum.Implicit:
                        break;

                    case ConvKindEnum.Identity:
                        uofsTemp = new UnaOpFullSig();
                        if (uofsTemp.Set(this, uos))
                        {
                            // Exact match.
                            bestUnaOpFullSigIndex = unaOpFullSigList.Count;
                            unaOpFullSigList.Add(uofsTemp);
                            goto LMatch;
                        }
                        break;
                }

                if (sigTypeSym != null && sigTypeSym.IsNUBSYM)
                {
                    // Need to use a lifted signature.
                    LiftFlagsEnum liftFlags = LiftFlagsEnum.None;

                    switch (GetConvKind(rawPredefType, uos.PredefinedType))
                    {
                        default:
                            liftFlags = liftFlags | LiftFlagsEnum.Convert1;
                            break;

                        case ConvKindEnum.Implicit:
                        case ConvKindEnum.Identity:
                            liftFlags = liftFlags | LiftFlagsEnum.Lift1;
                            break;
                    }

                    uofsTemp = new UnaOpFullSig();
                    uofsTemp.Set(sigTypeSym, uos.BindOp, liftFlags);
                    unaOpFullSigList.Add(uofsTemp);

                    // NOTE: Can't skip any if we use the lifted signature because the
                    // type might convert to int? and to long (but not to int) in which
                    // case we should get an ambiguity. But we can skip the lifted ones....
                    minLiftUnaOpSigIndex = unaOpSigIndex + uos.SkipCount + 1;
                }
                else
                {
                    // Record it as applicable and skip accordingly.
                    uofsTemp = new UnaOpFullSig();
                    if (uofsTemp.Set(this, uos))
                    {
                        unaOpFullSigList.Add(uofsTemp);
                    }
                    unaOpSigIndex += uos.SkipCount;
                }
            }

            if (unaOpFullSigList.Count == 0)
            {
                return BadOperatorTypesError(treeNode, argumentExpr, null, null);
            }

            bestUnaOpFullSigIndex = 0;
            if (unaOpFullSigList.Count == 1)
            {
                goto LMatch;
            }

            // Determine which is best.
            for (unaOpFullSigIndex = 1; unaOpFullSigIndex < unaOpFullSigList.Count; unaOpFullSigIndex++)
            {
                if (bestUnaOpFullSigIndex < 0)
                {
                    bestUnaOpFullSigIndex = unaOpFullSigIndex;
                }
                else
                {
                    int nT = WhichUofsIsBetter(
                        unaOpFullSigList[bestUnaOpFullSigIndex],
                        unaOpFullSigList[unaOpFullSigIndex],
                        typeSym);
                    if (nT == 0)
                    {
                        bestUnaOpFullSigIndex = -1;
                    }
                    else if (nT > 0)
                    {
                        bestUnaOpFullSigIndex = unaOpFullSigIndex;
                    }
                }
            }
            if (bestUnaOpFullSigIndex < 0)
            {
                // Ambigous.
                return AmbiguousOperatorError(treeNode, argumentExpr, null);
            }

            // Verify that our answer works.
            for (unaOpFullSigIndex = 0; unaOpFullSigIndex < unaOpFullSigList.Count; unaOpFullSigIndex++)
            {
                if (unaOpFullSigIndex == bestUnaOpFullSigIndex) continue;
                if (WhichUofsIsBetter(
                    unaOpFullSigList[bestUnaOpFullSigIndex],
                    unaOpFullSigList[unaOpFullSigIndex], typeSym
                    ) >= 0)
                {
                    return AmbiguousOperatorError(treeNode, argumentExpr, null);
                }
            }

        LMatch:
            //DebugUtil.Assert(unaOpFullSigCount < unaOpFullSigMaxCount);
            DebugUtil.Assert(bestUnaOpFullSigIndex < unaOpFullSigList.Count);
            UnaOpFullSig uofs = unaOpFullSigList[bestUnaOpFullSigIndex];

            if (uofs.BindOp == BindUnaOpEnum.None)
            {
                if (unaOpKind == UnaOpKindEnum.IncDec)
                {
                    return BindIncOp(treeNode, exprKind, flags, argumentExpr, uofs);
                }
                return BadOperatorTypesError(treeNode, argumentExpr, null, null);
            }

            expr = argumentExpr;
            NubInfo nubInfo = new NubInfo();

            if (uofs.LiftFlags != 0)
            {
                // Have to lift.
                DebugUtil.Assert(uofs.TypeSym.IsNUBSYM);
                if ((uofs.LiftFlags & LiftFlagsEnum.Lift1) == 0)
                {
                    expr = MustConvert(expr, uofs.TypeSym, 0);
                }

                BindNubCondValBin(
                    treeNode,
                    expr,
                    null,
                    ref nubInfo,
                    LiftFlagsEnum.LiftBoth);
                DebugUtil.Assert(nubInfo.IsActive);
                expr = nubInfo.Val(0);

                if ((uofs.LiftFlags & LiftFlagsEnum.Lift1) != 0)
                {
                    expr = MustConvert(expr, (uofs.TypeSym as NUBSYM).BaseTypeSym, 0);
                }
            }
            else
            {
                expr = MustConvert(expr, uofs.TypeSym, 0);
            }

            EXPR resExpr = BindUnaryOperator(uofs.BindOp, treeNode, exprKind, flags, expr);

            if (uofs.LiftFlags != 0)
            {
                DebugUtil.Assert(nubInfo.IsActive);

                resExpr = BindNubNew(treeNode, resExpr);
                resExpr = BindNubOpRes(
                    treeNode,
                    resExpr.TypeSym as NUBSYM,
                    resExpr.TypeSym,
                    resExpr,
                    ref nubInfo,
                    true);
            }

            return resExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.
        //
        //--------------------------------------------------
        //private EXPR * BindIntUnaOp(BASENODE * tree, EXPRKIND ek, uint flags, EXPR * arg);
        //private EXPR * BindRealUnaOp(BASENODE * tree, EXPRKIND ek, uint flags, EXPR * arg);

        //--------------------------------------------------
        // FUNCBREC.BindDecUnaOp
        //
        /// <summary>
        /// Handles standard unary decimal based operators.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindDecUnaOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr)
        {
            DebugUtil.Assert(argExpr.TypeSym.IsPredefType(PREDEFTYPE.DECIMAL));
            DebugUtil.Assert(exprKind == EXPRKIND.NEG || exprKind == EXPRKIND.UPLUS);

            TYPESYM decimalTypeSym = GetOptionalPredefinedType(PREDEFTYPE.DECIMAL);
            DebugUtil.Assert(decimalTypeSym != null);

            EXPR argConstExpr = argExpr.GetConst();

            if (exprKind == EXPRKIND.UPLUS)
            {
                return argConstExpr != null ? argExpr : NewExprBinop(treeNode, exprKind, decimalTypeSym, argExpr, null);
            }

            if (argConstExpr == null)
            {
                return BindPredefOpAsUD(treeNode, exprKind, argExpr, null);
            }

            decimal dec = (argConstExpr as EXPRCONSTANT).ConstVal.GetDecimal();
            //DECIMAL_SIGN(dec) ^= DECIMAL_NEG;
            dec = -dec;

            // Allocate the result node.
            CONSTVAL cv = new CONSTVAL();

            //cv.decVal = (DECIMAL *)allocator.Alloc(sizeof(DECIMAL));
            cv.SetDecimal(dec);

            EXPR resExpr = NewExprConstant(treeNode, decimalTypeSym, cv);
            return AddSideEffects(treeNode, resExpr, argExpr, true, false);
        }

        //--------------------------------------------------
        // FUNCBREC.BindBoolUnaOp
        //
        /// <summary>
        /// Handles boolean unary operater (!).
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindBoolUnaOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr)
        {
            DebugUtil.Assert(argExpr.TypeSym.IsPredefType(PREDEFTYPE.BOOL));
            DebugUtil.Assert(exprKind == EXPRKIND.LOGNOT);

            // Get the result type and operand type.
            TYPESYM boolTypeSym = GetRequiredPredefinedType(PREDEFTYPE.BOOL);

            // Determine if argExpr has a constant value.
            // Strip off EXPRKIND.SEQUENCE for constant checking.

            EXPR argConstExpr = argExpr.GetConst();

            if (argConstExpr == null)
            {
                return NewExprBinop(treeNode, EXPRKIND.LOGNOT, boolTypeSym, argExpr, null);
            }

            //bool fRes = !!argConstExpr.asCONSTANT().getVal().iVal;
            bool fRes = (argConstExpr as EXPRCONSTANT).ConstVal.GetBool();
            return AddSideEffects(
                treeNode,
                NewExprConstant(treeNode, boolTypeSym, new ConstValInit(!fRes)),
                argExpr,
                true,
                false);
        }

        //--------------------------------------------------
        // FUNCBREC.BindEnumUnaOp
        //
        /// <summary>
        /// <para>Handles enum unary operator (~).</para>
        /// <para>Use as DelegateBindUnaOp</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindEnumUnaOp(BASENODE treeNode, EXPRKIND exprKind, EXPRFLAG flags, EXPR argExpr)
        {
            DebugUtil.Assert(argExpr.TypeSym.IsEnumType());
            DebugUtil.Assert(exprKind == EXPRKIND.BITNOT);

            PREDEFTYPE predefTypeID;
            TYPESYM enumTypeSym = argExpr.TypeSym;

            switch (enumTypeSym.FundamentalType())
            {
                default:
                    // Promote all smaller types to int.
                    predefTypeID = PREDEFTYPE.INT;
                    break;

                case FUNDTYPE.U4:
                    predefTypeID = PREDEFTYPE.UINT;
                    break;

                case FUNDTYPE.I8:
                    predefTypeID = PREDEFTYPE.LONG;
                    break;

                case FUNDTYPE.U8:
                    predefTypeID = PREDEFTYPE.ULONG;
                    break;
            }

            TYPESYM opTypeSym = this.GetRequiredPredefinedType(predefTypeID);
            argExpr = MustCast(argExpr, opTypeSym, ConvertTypeEnum.NOUDC);

            EXPR resExpr = BindIntOp(treeNode, exprKind, flags, argExpr, null, predefTypeID);

            if (!resExpr.IsOK)
            {
                return NewError(treeNode, enumTypeSym);
            }

            CHECKEDCONTEXT context = new CHECKEDCONTEXT(this, false);
            resExpr = MustCast(resExpr, enumTypeSym, ConvertTypeEnum.NOUDC);
            context.Restore(this);

            return resExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindIncOp
        //
        /// <summary>
        /// Handles standard increment and decrement operators.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="argExpr"></param>
        /// <param name="unfSig"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindIncOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR argExpr,
            UnaOpFullSig unfSig)
        {
            DebugUtil.Assert(exprKind == EXPRKIND.ADD || exprKind == EXPRKIND.SUB);

            if (!CheckLvalue(argExpr, true))
            {
                return NewError(treeNode, argExpr.TypeSym);
            }

            TYPESYM rawTypeSym = unfSig.TypeSym.StripNubs();

            // The type of the 1.
            TYPESYM typeSym1 = rawTypeSym;
            if (typeSym1.IsEnumType())
            {
                typeSym1 = typeSym1.UnderlyingEnumType();
            }

            EXPRMULTIGET getExpr = NewExpr(argExpr.TreeNode, EXPRKIND.MULTIGET, argExpr.TypeSym) as EXPRMULTIGET;
            getExpr.Flags |= EXPRFLAG.ASSGOP;

            NubInfo nubInfo = new NubInfo();
            EXPR valueExpr = getExpr;

            if (unfSig.LiftFlags != 0)
            {
                // Have to lift.
                DebugUtil.Assert(unfSig.TypeSym.IsNUBSYM);

                if ((unfSig.LiftFlags & LiftFlagsEnum.Lift1) == 0)
                {
                    valueExpr = MustConvert(valueExpr, unfSig.TypeSym, 0);
                }

                BindNubCondValBin(
                    treeNode,
                    valueExpr,
                    null,
                    ref nubInfo,
                    LiftFlagsEnum.LiftBoth);

                DebugUtil.Assert(nubInfo.IsActive);
                valueExpr = nubInfo.Val(0);

                if ((unfSig.LiftFlags & LiftFlagsEnum.Lift1) != 0)
                {
                    valueExpr = MustConvert(valueExpr, (unfSig.TypeSym as NUBSYM).BaseTypeSym, 0);
                }
            }
            else
            {
                DebugUtil.Assert(!unfSig.TypeSym.IsNUBSYM);
                valueExpr = MustConvert(valueExpr, unfSig.TypeSym, 0);
            }

            CONSTVAL cv = new CONSTVAL();
            FUNDTYPE ft;
            TYPESYM tmpTypeSym = rawTypeSym;

            switch (ft = rawTypeSym.FundamentalType())
            {
                default:
                    DebugUtil.Assert(rawTypeSym.IsPredefType(PREDEFTYPE.DECIMAL));
                    valueExpr = BindPredefOpAsUD(
                        treeNode,
                        exprKind == EXPRKIND.ADD ? EXPRKIND.INC : EXPRKIND.DEC,
                        valueExpr,
                        null);
                    break;

                case FUNDTYPE.PTR:
                    cv.SetInt(1);
                    valueExpr = BindPtrBinOp(
                        treeNode,
                        exprKind,
                        flags,
                        valueExpr,
                        NewExprConstant(treeNode, GetRequiredPredefinedType(PREDEFTYPE.INT), cv));
                    break;

                case FUNDTYPE.I1:
                case FUNDTYPE.I2:
                case FUNDTYPE.U1:
                case FUNDTYPE.U2:
                    tmpTypeSym = GetRequiredPredefinedType(PREDEFTYPE.INT);
                    // Fall through.
                    goto case FUNDTYPE.U4;

                case FUNDTYPE.I4:
                case FUNDTYPE.U4:
                    cv.SetInt(1);
                    goto LScalar;

                case FUNDTYPE.I8:
                case FUNDTYPE.U8:
                    //cv.longVal = (__int64 *) allocator.Alloc(sizeof(__int64));
                    //*cv.longVal = (__int64)1;
                    cv.SetLong((long)1);
                    goto LScalar;

                case FUNDTYPE.R4:
                case FUNDTYPE.R8:
                    flags &= ~EXPRFLAG.CHECKOVERFLOW;
                    //cv.doubleVal = (double*) allocator.Alloc(sizeof(double));
                    //*cv.doubleVal = 1.0;
                    cv.SetDouble(1.0);

                LScalar:
                    valueExpr = NewExprBinop(
                        treeNode,
                        exprKind,
                        tmpTypeSym,
                        valueExpr,
                        NewExprConstant(treeNode, typeSym1, cv));
                    valueExpr.Flags |= flags;
                    if (tmpTypeSym != rawTypeSym)
                    {
                        valueExpr = MustCast(valueExpr, rawTypeSym, ConvertTypeEnum.NOUDC);
                    }
                    break;
            }
            DebugUtil.Assert(!valueExpr.TypeSym.IsNUBSYM);

            EXPRMULTI multiExpr = NewExpr(treeNode, EXPRKIND.MULTI, argExpr.TypeSym) as EXPRMULTI;
            getExpr.MultiExpr = multiExpr;
            multiExpr.LeftExpr = argExpr;
            multiExpr.Flags |= EXPRFLAG.ASSGOP | flags;

            // Convert to the destination type.
            if (!nubInfo.IsActive)
            {
                valueExpr = MustConvert(valueExpr, argExpr.TypeSym, 0);
            }
            else
            {
                // The operator is lifted.
                EXPR nullExpr = NewExprZero(treeNode, unfSig.TypeSym);

                // First convert to the nullable type, then the argExpr type.
                valueExpr = MustConvert(valueExpr, unfSig.TypeSym, 0);
                valueExpr = MustConvert(valueExpr, argExpr.TypeSym, 0);

                // If exprRes is an error expr, just use it - don't try to cast the nullExpr and
                // risk a duplicate error message.
                nullExpr = valueExpr.IsOK ? MustCast(nullExpr, argExpr.TypeSym, 0) : valueExpr;
                valueExpr = BindNubOpRes(treeNode, argExpr.TypeSym, valueExpr, nullExpr, ref nubInfo);
            }

            multiExpr.OperandExpr = valueExpr;
            return multiExpr;
        }

        // Used to bind predefined operators that are implemented as "user-defined" operators.

        //--------------------------------------------------
        // FUNCBREC.BindPredefOpAsUD
        //
        /// <summary>
        /// Handles binding a predefined operator that is implemented as a "user-defined" operator.
        /// For example, decimal ops and delegate equality ops.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPredefOpAsUD(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPR argExpr1,
            EXPR argExpr2)
        {
            DebugUtil.Assert(argExpr2 == null || argExpr1.TypeSym == argExpr2.TypeSym);

            TYPESYM typeSym = argExpr1.TypeSym;
            DebugUtil.Assert(typeSym.IsPredefined());

            string name = ExprKindName(exprKind);
            DebugUtil.Assert(name != null);

            MemberLookup mem = new MemberLookup();
            if (!mem.Lookup(Compiler, typeSym, null, this.parentDeclSym, name, 0, MemLookFlagsEnum.Operator))
            {
                mem.ReportErrors(treeNode);
                return NewError(treeNode, null);
            }
            DebugUtil.Assert(mem.FirstSym.IsMETHSYM && (mem.FirstSym as METHSYM).IsOperator);
            mem.ReportWarnings(treeNode);

            EXPRMEMGRP grp = NewExprMemGrp(treeNode, treeNode, mem);
            EXPR args = argExpr2 != null ? NewExprBinop(null, EXPRKIND.LIST, null, argExpr1, argExpr2) : argExpr1;

            return BindGrpToArgs(treeNode, 0, grp, args);
        }

        //--------------------------------------------------
        // FUNCBREC.BindUDUnop
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="argExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindUDUnop(BASENODE treeNode, EXPRKIND exprKind, EXPR argExpr)
        {
            string name = ExprKindName(exprKind);
            DebugUtil.Assert(name != null);
            TYPESYM srcTypeSym = argExpr.TypeSym;

        LAgain:
            Compiler.EnsureState(srcTypeSym, AggStateEnum.Prepared);
            switch (srcTypeSym.Kind)
            {
                case SYMKIND.NUBSYM:
                    srcTypeSym = srcTypeSym.StripNubs();
                    goto LAgain;

                case SYMKIND.TYVARSYM:
                    srcTypeSym = (srcTypeSym as TYVARSYM).BaseClassSym;
                    goto LAgain;

                case SYMKIND.AGGTYPESYM:
                    if (!srcTypeSym.IsClassType() && !srcTypeSym.IsStructType() ||
                        (srcTypeSym as AGGTYPESYM).GetAggregate().SkipUserDefinedOperators)
                    {
                        return null;
                    }
                    break;

                default:
                    return null;
            }

            //ArgInfos * info = (ArgInfos *)_alloca(sizeof(ArgInfos) + sizeof(EXPR*) * 1);
            ArgInfos info = new ArgInfos();

            //info.carg = 1;
            FillInArgInfoFromArgList(info, argExpr);

            METHLIST firstMethList = null;
            METHLIST lastMethList = null;
            METHSYM currentMethSym = null;
            AGGTYPESYM currentAggTypeSym = srcTypeSym as AGGTYPESYM;

            for (; ; )
            {
                // Find the next operator.
                currentMethSym = (currentMethSym == null) ?
                    Compiler.MainSymbolManager.LookupAggMember(
                        name, currentAggTypeSym.GetAggregate(), SYMBMASK.METHSYM) as METHSYM :
                    BSYMMGR.LookupNextSym(
                        currentMethSym, currentAggTypeSym.GetAggregate(), SYMBMASK.METHSYM) as METHSYM;

                if (currentMethSym == null)
                {
                    // Find the next type.
                    // If we've found some applicable methods in a class then we don't need to look any further.
                    if (firstMethList != null) break;
                    currentAggTypeSym = currentAggTypeSym.GetBaseClass();
                    if (currentAggTypeSym == null) break;
                    continue;
                }

                // Only look at operators with 1 args.
                if (!currentMethSym.IsOperator || currentMethSym.ParameterTypes.Count != 1)
                {
                    continue;
                }
                DebugUtil.Assert(currentMethSym.TypeVariables.Count == 0);

                TypeArray currentParamArray = Compiler.MainSymbolManager.SubstTypeArray(
                    currentMethSym.ParameterTypes,
                    currentAggTypeSym,
                    null);
                TYPESYM paramTypeSym1 = currentParamArray[0];
                NUBSYM paramNubSym;
                METHLIST methList = null;

                if (CanConvert(argExpr, paramTypeSym1, 0))
                {
                    //methList = STACK_ALLOC(METHLIST, 1);
                    methList = new METHLIST();
                    methList.MethPropWithInst.Set(currentMethSym, currentAggTypeSym, BSYMMGR.EmptyTypeArray);
                    methList.LiftedTypeCount = 0;
                    methList.IsExpanded = false;
                    methList.ParameterTypes = currentParamArray;
                }
                else if (Compiler.FCanLift() &&
                    paramTypeSym1.IsNonNullableValueType() &&
                    Compiler.MainSymbolManager.SubstType(
                        currentMethSym.ReturnTypeSym,
                        currentAggTypeSym,
                        null).IsNonNullableValueType() &&
                    CanConvert(
                        argExpr,
                        paramNubSym = Compiler.MainSymbolManager.GetNubType(paramTypeSym1)
                        , 0))
                {
                    //methList = STACK_ALLOC(METHLIST, 1);
                    methList = new METHLIST();
                    methList.MethPropWithInst.Set(currentMethSym, currentAggTypeSym, BSYMMGR.EmptyTypeArray);
                    methList.LiftedTypeCount = 1;
                    methList.IsExpanded = false;
                    methList.ParameterTypes = Compiler.MainSymbolManager.AllocParams(paramNubSym);
                }

                if (methList != null)
                {
                    // Link it in.
                    //DebugUtil.Assert(!*lastMethList);
                    //*lastMethList = methList;
                    //methList.next = null;
                    //lastMethList = &methList.next;
                    if (firstMethList == null)
                    {
                        firstMethList = methList;
                        lastMethList = methList;
                    }
                    else
                    {
                        DebugUtil.Assert(firstMethList != null && lastMethList != null);
                        lastMethList.Next = methList;
                        lastMethList = methList;
                    }
                }
            }

            if (firstMethList == null)
            {
                return null;
            }

            METHLIST ambigMethList1;
            METHLIST ambigMethList2;
            METHLIST bestMethList = FindBestMethod(firstMethList, info, out ambigMethList1, out ambigMethList2);

            if (bestMethList == null)
            {
                // No winner, so its an ambiguous callExpr...
                Compiler.Error(treeNode, CSCERRID.ERR_AmbigCall,
                    new ErrArg(ambigMethList1.MethPropWithInst),
                    new ErrArg(ambigMethList2.MethPropWithInst));
                return NewError(treeNode, null);
            }

            if (Compiler.CheckBogus(bestMethList.MethPropWithInst.MethSym))
            {
                Compiler.ErrorRef(treeNode, CSCERRID.ERR_BindToBogus,
                    new ErrArgRef(bestMethList.MethPropWithInst));
                return NewError(treeNode, null);
            }

            if (bestMethList.MethPropWithInst.MethSym.IsDeprecated())
            {
                ReportDeprecated(treeNode, bestMethList.MethPropWithInst);
            }

            NubInfo nubInfo = new NubInfo();
            EXPR valueExpr = argExpr;
            TYPESYM paramTypeSym2 = bestMethList.ParameterTypes[0];
            TYPESYM rawTypeSym = paramTypeSym2;

            if (bestMethList.LiftedTypeCount > 0)
            {
                // This is a lifted user defined operator.
                rawTypeSym = paramTypeSym2.StripNubs();

                if (!argExpr.TypeSym.IsNUBSYM ||
                    !CanConvert(argExpr.TypeSym.StripNubs(), rawTypeSym, ConvertTypeEnum.NOUDC))
                {
                    // Convert then lift.
                    valueExpr = MustConvert(argExpr, paramTypeSym2, 0);
                }
                DebugUtil.Assert(valueExpr.TypeSym.IsNUBSYM);

                BindNubCondValBin(
                    treeNode,
                    valueExpr,
                    null,
                    ref nubInfo,
                    LiftFlagsEnum.LiftBoth);

                DebugUtil.Assert(nubInfo.IsActive);
                valueExpr = nubInfo.Val(0);
                DebugUtil.Assert(!valueExpr.TypeSym.IsNUBSYM);
            }

            valueExpr = MustConvert(valueExpr, rawTypeSym, 0);

            EXPRCALL callExpr = NewExpr(
                treeNode,
                EXPRKIND.CALL,
                Compiler.MainSymbolManager.SubstType(
                    bestMethList.MethPropWithInst.MethSym.ReturnTypeSym,
                    bestMethList.MethPropWithInst.AggTypeSym,
                    null)
                ) as EXPRCALL;
            callExpr.ObjectExpr = null;
            callExpr.MethodWithInst = MethWithInst.Convert(bestMethList.MethPropWithInst);
            callExpr.ArgumentsExpr = valueExpr;

            VerifyMethodArgs(callExpr);

            EXPR resExpr = callExpr;

            if (bestMethList.LiftedTypeCount > 0)
            {
                // The lifted case.
                TYPESYM resTypeSym = resExpr.TypeSym;
                if (!resTypeSym.IsNUBSYM)
                {
                    resTypeSym = Compiler.MainSymbolManager.GetNubType(resTypeSym);
                }

                resExpr = BindNubOpRes(
                    treeNode,
                    resTypeSym as NUBSYM,
                    resTypeSym,
                    resExpr,
                    ref nubInfo,
                    true);
            }

            return resExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindUDBinop
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <param name="dontLift"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindUDBinop(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPR argExpr1,
            EXPR argExpr2,
            bool dontLift)  // = false
        {
            string name = ExprKindName(exprKind);
            DebugUtil.Assert(name != null);

            AGGTYPESYM[] atsArray = { null, null };
            int cats = 0;
            TYPESYM retTypeSym;

            for (int i = 0; i < 2; i++)
            {
                TYPESYM type = (i == 0) ? argExpr1.TypeSym : argExpr2.TypeSym;
            LAgain:
                Compiler.EnsureState(type, AggStateEnum.Prepared);
                switch (type.Kind)
                {
                    case SYMKIND.NUBSYM:
                        type = type.StripNubs();
                        goto LAgain;

                    case SYMKIND.TYVARSYM:
                        type = (type as TYVARSYM).BaseClassSym;
                        goto LAgain;

                    case SYMKIND.AGGTYPESYM:
                        if ((type.IsClassType() || type.IsStructType()) &&
                            !(type as AGGTYPESYM).GetAggregate().SkipUserDefinedOperators)
                        {
                            DebugUtil.Assert(cats < 2,
                                "This will be hit no more than twice per the loop termination condition");
                            atsArray[cats++] = type as AGGTYPESYM;
                        }
                        break;

                    default:
                        break;
                }
            }

            if (cats == 0) return null;

            if (cats == 2 && atsArray[0] == atsArray[1])
            {
                // Common case: they're the same.
                cats = 1;
            }

            EXPR argsExpr = NewExprBinop(null, EXPRKIND.LIST, null, argExpr1, argExpr2);
            //ArgInfos * argInfos = (ArgInfos*)_alloca(sizeof(ArgInfos) + sizeof(EXPR*) * 2);
            ArgInfos argInfos = new ArgInfos();

            //argInfos.TypeArgumentCount = 2;
            FillInArgInfoFromArgList(argInfos, argsExpr);

            bool isEqOp = false;
            bool isRelOp = false;

            switch (exprKind)
            {
                case EXPRKIND.EQ:
                case EXPRKIND.NE:
                    isEqOp = true;
                    break;

                case EXPRKIND.GT:
                case EXPRKIND.GE:
                case EXPRKIND.LT:
                case EXPRKIND.LE:
                    isRelOp = true;
                    break;

                default:
                    break;
            }

            //METHLIST * firstMethList = null;
            //METHLIST ** lastMethList = &firstMethList;
            METHLIST firstMethList = null;
            METHLIST lastMethList = null;
            bool foundSomeInType = false;
            int iats = 0;
            METHSYM currentMethSym = null;
            AGGTYPESYM currentAggTypeSym = atsArray[0];

            for (; ; )
            {
                if (firstMethList != null && iats > 0 && currentAggTypeSym == atsArray[0])
                {
                    // We're searching the 2nd type hierarchy and we've hit
                    // the type in the 1st hieararchy where we found some. So we're done.
                    break;
                }

                // Find the next operator.
                currentMethSym = (currentMethSym == null) ?
                    Compiler.MainSymbolManager.LookupAggMember(
                        name, currentAggTypeSym.GetAggregate(), SYMBMASK.METHSYM) as METHSYM :
                    BSYMMGR.LookupNextSym(
                        currentMethSym, currentAggTypeSym.GetAggregate(), SYMBMASK.METHSYM) as METHSYM;

                if (currentMethSym == null)
                {
                    // Find the next type.
                    // If we've found some applicable methods in a class then we don't need to look any further.
                    if (!foundSomeInType)
                    {
                        currentAggTypeSym = currentAggTypeSym.GetBaseClass();
                        if (currentAggTypeSym != null) continue;
                    }

                    // Get the next type.
                    if (++iats >= cats)
                    {
                        // Done with types.
                        break;
                    }
                    currentAggTypeSym = atsArray[iats];
                    foundSomeInType = false;
                    continue;
                }

                // Only look at operators with 2 args.
                if (!currentMethSym.IsOperator || currentMethSym.ParameterTypes.Count != 2)
                {
                    continue;
                }
                DebugUtil.Assert(currentMethSym.TypeVariables.Count == 0);
                TypeArray currentParamArray = Compiler.MainSymbolManager.SubstTypeArray(
                    currentMethSym.ParameterTypes,
                    currentAggTypeSym,
                    null);
                METHLIST methList = null;
                bool fConv1;

                if ((fConv1 = CanConvert(argExpr1, currentParamArray[0], 0)) &&
                    CanConvert(argExpr2, currentParamArray[1], 0))
                {
                    //methList = STACK_ALLOC(METHLIST, 1);
                    methList = new METHLIST();
                    methList.LiftedTypeCount = 0;
                    methList.ParameterTypes = currentParamArray;
                }
                else
                {
                    // Check whether any lifted operator is applicable.
                    if (!Compiler.FCanLift() || dontLift) continue;
                    if (!currentParamArray[0].IsNonNullableValueType() ||
                        !currentParamArray[1].IsNonNullableValueType())
                    {
                        continue;
                    }

                    // If the return type isn't a value type we can't lift.
                    retTypeSym = Compiler.MainSymbolManager.SubstType(
                        currentMethSym.ReturnTypeSym,
                        currentAggTypeSym,
                        null);
                    if (!retTypeSym.IsNonNullableValueType()) continue;

                    if (isEqOp &&
                        (!retTypeSym.IsPredefType(PREDEFTYPE.BOOL) ||
                        currentParamArray[0] != currentParamArray[1]))
                    {
                        continue;
                    }
                    if (isRelOp && !retTypeSym.IsPredefType(PREDEFTYPE.BOOL))
                    {
                        continue;
                    }

                    TYPESYM[] rgtype = { null, null };

                    rgtype[0] = Compiler.MainSymbolManager.GetNubType(currentParamArray[0]);
                    rgtype[1] = Compiler.MainSymbolManager.GetNubType(currentParamArray[1]);

                    if (!fConv1 && !CanConvert(argExpr1, rgtype[0], 0) || !CanConvert(argExpr2, rgtype[1], 0))
                    {
                        continue;
                    }

                    //methList = STACK_ALLOC(METHLIST, 1);
                    methList = new METHLIST();
                    methList.LiftedTypeCount = 2;
                    methList.ParameterTypes = Compiler.MainSymbolManager.AllocParams(rgtype);
                }
                methList.MethPropWithInst.Set(currentMethSym, currentAggTypeSym, BSYMMGR.EmptyTypeArray);
                methList.IsExpanded = false;

                // Link it in.
                //DebugUtil.Assert(!*lastMethList);
                //*lastMethList = methList;
                //methList.next = null;
                //lastMethList = &methList.next;
                if (firstMethList == null)
                {
                    firstMethList = methList;
                    lastMethList = methList;
                }
                else
                {
                    lastMethList.Next = methList;
                    lastMethList = methList;
                }
                lastMethList.Next = null;

                foundSomeInType = true;
                atsArray[iats] = currentAggTypeSym;
            }

            if (firstMethList == null) return null;

            METHLIST ambigMethList1;
            METHLIST ambigMethList2;
            METHLIST bestMethList = FindBestMethod(
                firstMethList, argInfos, out ambigMethList1, out ambigMethList2);

            if (bestMethList == null)
            {
                // No winner, so its an ambiguous callExpr...
                Compiler.Error(treeNode, CSCERRID.ERR_AmbigCall,
                    new ErrArg(ambigMethList1.MethPropWithInst),
                    new ErrArg(ambigMethList2.MethPropWithInst));
                return NewError(treeNode, null);
            }

            if (Compiler.CheckBogus(bestMethList.MethPropWithInst.MethSym))
            {
                Compiler.ErrorRef(treeNode, CSCERRID.ERR_BindToBogus, new ErrArgRef(bestMethList.MethPropWithInst));
                return NewError(treeNode, null);
            }

            if (bestMethList.MethPropWithInst.MethSym.IsDeprecated())
            {
                ReportDeprecated(treeNode, bestMethList.MethPropWithInst);
            }

            EXPR valueExpr1 = argExpr1;
            EXPR valueExpr2 = argExpr2;
            TypeArray paramArray = bestMethList.ParameterTypes;
            TypeArray rawParamArray = paramArray;
            TYPESYM rawRetTypeSym = Compiler.MainSymbolManager.SubstType(
                bestMethList.MethPropWithInst.MethSym.ReturnTypeSym,
                bestMethList.MethPropWithInst.AggTypeSym,
                null);

            NubInfo nubInfo = new NubInfo();

            if (bestMethList.LiftedTypeCount > 0)
            {
                DebugUtil.Assert(bestMethList.LiftedTypeCount == 2);
                DebugUtil.Assert(!dontLift);

                // This is a lifted user defined operator.
                rawParamArray = Compiler.MainSymbolManager.SubstTypeArray(
                    bestMethList.MethPropWithInst.MethSym.ParameterTypes,
                    bestMethList.MethPropWithInst.AggTypeSym,
                    null);
                DebugUtil.Assert(paramArray != rawParamArray);
                LiftFlagsEnum liftFlags;

                DebugUtil.Assert(rawParamArray[0] == paramArray[0].ParentSym);
                DebugUtil.Assert(rawParamArray[1] == paramArray[1].ParentSym);
                liftFlags = LiftFlagsEnum.LiftBoth;

                if (!CanConvert(argExpr1.TypeSym.StripNubs(), rawParamArray[0], ConvertTypeEnum.NOUDC))
                {
                    // Need to convert first.
                    valueExpr1 = MustConvert(argExpr1, paramArray[0], 0);
                }
                if (!CanConvert(argExpr2.TypeSym.StripNubs(), rawParamArray[1], ConvertTypeEnum.NOUDC))
                {
                    // Need to convert first.
                    valueExpr2 = MustConvert(argExpr2, paramArray[1], 0);
                }

                BindNubCondValBin(treeNode, valueExpr1, valueExpr2, ref nubInfo, liftFlags);
                DebugUtil.Assert(nubInfo.IsActive);

                // Equality operators are special. If the return type is bool and the parameter types
                // are the same then they treat null as a value and return bool.
                if (isEqOp && nubInfo.FAlwaysNull())
                {
                    DebugUtil.Assert(
                        (exprKind == EXPRKIND.EQ || exprKind == EXPRKIND.NE) &&
                        rawRetTypeSym.IsPredefType(PREDEFTYPE.BOOL) &&
                        rawParamArray[0] == rawParamArray[1]);

                    // At least one of them is a constant null.
                    EXPR resExpr;

                    if (nubInfo.IsNull[0] && nubInfo.IsNull[1])
                    {
                        // Both are constant nulls.
                        resExpr = NewExprConstant(
                            treeNode, rawRetTypeSym, new ConstValInit(exprKind == EXPRKIND.EQ));
                        resExpr = AddSideEffects(treeNode, resExpr, valueExpr2, true, true);
                        return AddSideEffects(treeNode, resExpr, valueExpr1, true, true);
                    }

                    if (nubInfo.IsNull[0] ? !valueExpr2.TypeSym.IsNUBSYM : !valueExpr1.TypeSym.IsNUBSYM)
                    {
                        // One is null and the other is not nullable.
                        resExpr = NewExprConstant(
                            treeNode, rawRetTypeSym, new ConstValInit(exprKind == EXPRKIND.NE));
                        resExpr = AddSideEffects(treeNode, resExpr, valueExpr2, true, true);
                        return AddSideEffects(treeNode, resExpr, valueExpr1, true, true);
                    }

                    // Generate seq(a, !b.HasValue) or rev(!a.HasValue, b).
                    resExpr = BindNubHasValue(
                        treeNode, nubInfo.IsNull[0] ? valueExpr2 : valueExpr1, exprKind == EXPRKIND.NE);
                    return AddSideEffects(
                        treeNode,
                        resExpr,
                        nubInfo.IsNull[0] ? valueExpr1 : valueExpr2,
                        nubInfo.IsNull[0],
                        true);
                }

                valueExpr1 = nubInfo.Val(0);
                valueExpr2 = nubInfo.Val(1);
            }

            valueExpr1 = MustConvert(valueExpr1, rawParamArray[0], 0);
            valueExpr2 = MustConvert(valueExpr2, rawParamArray[1], 0);
            if (argsExpr.AsBIN.Operand1 != valueExpr1 || argsExpr.AsBIN.Operand2 != valueExpr2)
            {
                argsExpr = NewExprBinop(null, EXPRKIND.LIST, null, valueExpr1, valueExpr2);
            }

            EXPRCALL callExpr = NewExpr(treeNode, EXPRKIND.CALL, rawRetTypeSym) as EXPRCALL;
            callExpr.ObjectExpr = null;
            callExpr.MethodWithInst = MethWithInst.Convert(bestMethList.MethPropWithInst);
            callExpr.ArgumentsExpr = argsExpr;

            VerifyMethodArgs(callExpr);

            if (bestMethList.LiftedTypeCount == 0)
            {
                return callExpr;
            }

            // The lifted case.
            retTypeSym = rawRetTypeSym;

            if (isEqOp)
            {
                DebugUtil.Assert(
                    (exprKind == EXPRKIND.EQ || exprKind == EXPRKIND.NE) &&
                    rawRetTypeSym.IsPredefType(PREDEFTYPE.BOOL) &&
                    rawParamArray[0] == rawParamArray[1]);
                EXPR resExpr;

                if (nubInfo.FAlwaysNonNull())
                {
                    return callExpr;
                }

                // Generate tmp1.HasValue == tmp2.HasValue && (!tmp1.HasValue || op_Equal(tmp1.Value, tmp2.Value))
                // When one of them is not nullable this simplifies to: tmp1.HasValue && op_Equal(tmp1.Value, tmp2)
                DebugUtil.Assert(
                    nubInfo.CombinedConditionExpr != null &&
                    (nubInfo.CombinedConditionExpr.Kind == EXPRKIND.BITAND) ==
                    (nubInfo.ConditionExpr[0] != null && nubInfo.ConditionExpr[1] != null && !nubInfo.IsSameTemp));

                if (nubInfo.CombinedConditionExpr.Kind == EXPRKIND.BITAND)
                {
                    // Generate tmp1.HasValue == tmp2.HasValue && (!tmp1.HasValue || op_Equal(tmp1.Value, tmp2.Value))
                    DebugUtil.Assert(!nubInfo.IsSameTemp);
                    nubInfo.CombinedConditionExpr.Kind = exprKind;
                    resExpr = nubInfo.ConditionExpr[0];
                    if (exprKind == EXPRKIND.EQ)
                    {
                        resExpr = NewExprBinop(treeNode, EXPRKIND.LOGNOT, retTypeSym, resExpr, null);
                    }

                    resExpr = NewExprBinop(
                        treeNode,
                        exprKind == EXPRKIND.EQ ? EXPRKIND.LOGOR : EXPRKIND.LOGAND,
                        retTypeSym,
                        resExpr,
                        callExpr);
                    resExpr = NewExprBinop(
                        treeNode,
                        exprKind == EXPRKIND.NE ? EXPRKIND.LOGOR : EXPRKIND.LOGAND,
                        retTypeSym,
                        nubInfo.CombinedConditionExpr,
                        resExpr);
                    return BindNubAddTmps(treeNode, resExpr, ref nubInfo);
                }
                if (nubInfo.IsSameTemp)
                {
                    // They share the same local so have a single HasValue check.
                    // Generate: !tmp.HasValue || op_Equal(tmp1.Value, dup)
                    DebugUtil.Assert(nubInfo.CombinedConditionExpr == nubInfo.ConditionExpr[0]);

                    resExpr = nubInfo.CombinedConditionExpr;
                    if (exprKind == EXPRKIND.EQ)
                    {
                        resExpr = NewExprBinop(treeNode, EXPRKIND.LOGNOT, retTypeSym, resExpr, null);
                    }
                    resExpr = NewExprBinop(
                        treeNode,
                        exprKind == EXPRKIND.EQ ? EXPRKIND.LOGOR : EXPRKIND.LOGAND,
                        retTypeSym,
                        resExpr,
                        callExpr);
                    return BindNubAddTmps(treeNode, resExpr, ref nubInfo);
                }

                // One of them is not nullable so generate: tmp1.HasValue && op_Equal(tmp1.Value, tmp2)
                if (exprKind == EXPRKIND.NE)
                {
                    nubInfo.CombinedConditionExpr = NewExprBinop(
                        treeNode, EXPRKIND.LOGNOT, retTypeSym, nubInfo.CombinedConditionExpr, null);
                }
                resExpr = NewExprBinop(
                    treeNode,
                    exprKind == EXPRKIND.NE ? EXPRKIND.LOGOR : EXPRKIND.LOGAND,
                    retTypeSym,
                    nubInfo.CombinedConditionExpr,
                    callExpr);
                return BindNubAddTmps(treeNode, resExpr, ref nubInfo);
            }

            if (isRelOp)
            {
                DebugUtil.Assert(
                    retTypeSym.IsPredefType(PREDEFTYPE.BOOL) &&
                    (exprKind == EXPRKIND.GT ||
                    exprKind == EXPRKIND.GE ||
                    exprKind == EXPRKIND.LT ||
                    exprKind == EXPRKIND.LE));

                // These ones don't lift the return type. Instead, if either side
                // is null, the result is false.
                return BindNubOpRes(
                    treeNode,
                    retTypeSym,
                    callExpr,
                    NewExprZero(treeNode, retTypeSym),
                    ref nubInfo);
            }

            if (!retTypeSym.IsNUBSYM)
            {
                retTypeSym = Compiler.MainSymbolManager.GetNubType(retTypeSym);
            }

            return BindNubOpRes(
                treeNode,
                retTypeSym as NUBSYM,
                retTypeSym,
                callExpr,
                ref nubInfo,
                true);
        }

        //--------------------------------------------------
        // FUNCBREC.BindUserBoolOp
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="callExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindUserBoolOp(BASENODE treeNode, EXPRKIND exprKind, EXPR callExpr)
        {
            DebugUtil.Assert(exprKind == EXPRKIND.LOGAND || exprKind == EXPRKIND.LOGOR);
            if (callExpr.Kind != EXPRKIND.CALL)
            {
                DebugUtil.Assert(callExpr.Kind == EXPRKIND.ERROR);
                return callExpr;
            }

            TYPESYM retTypeSym = callExpr.TypeSym;

            DebugUtil.Assert((callExpr as EXPRCALL).MethodWithInst.MethSym.ParameterTypes.Count == 2);
            if (!Compiler.MainSymbolManager.SubstEqualTypes(
                    retTypeSym,
                    (callExpr as EXPRCALL).MethodWithInst.MethSym.ParameterTypes[0],
                    retTypeSym,
                    null) ||
                !Compiler.MainSymbolManager.SubstEqualTypes(
                    retTypeSym,
                    (callExpr as EXPRCALL).MethodWithInst.MethSym.ParameterTypes[1],
                    retTypeSym,
                    null))
            {
                Compiler.Error(treeNode, CSCERRID.ERR_BadBoolOp, new ErrArg((callExpr as EXPRCALL).MethodWithInst));
                return NewError(treeNode, retTypeSym);
            }

            DebugUtil.Assert((callExpr as EXPRCALL).ArgumentsExpr.AsBIN.Operand1.TypeSym == retTypeSym);
            DebugUtil.Assert((callExpr as EXPRCALL).ArgumentsExpr.AsBIN.Operand2.TypeSym == retTypeSym);

            EXPR expr1 = (callExpr as EXPRCALL).ArgumentsExpr.AsBIN.Operand1;
            EXPR wrapExpr = expr1;

            wrapExpr = NewExprWrap(expr1, TEMP_KIND.SHORTLIVED);
            (callExpr as EXPRCALL).ArgumentsExpr.AsBIN.Operand1 = wrapExpr;

            EXPR callT = BindUDUnop(treeNode, EXPRKIND.TRUE, wrapExpr);
            EXPR callF = BindUDUnop(treeNode, EXPRKIND.FALSE, wrapExpr);

            if (callT == null || callF == null)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_MustHaveOpTF, new ErrArg(retTypeSym));
                return NewError(treeNode, retTypeSym);
            }

            callT = MustConvert(callT, GetRequiredPredefinedType(PREDEFTYPE.BOOL), 0);
            callF = MustConvert(callF, GetRequiredPredefinedType(PREDEFTYPE.BOOL), 0);

            EXPRUSERLOGOP rval = NewExpr(treeNode, EXPRKIND.USERLOGOP, retTypeSym) as EXPRUSERLOGOP;
            rval.OpX = expr1;
            rval.CallTF = exprKind == EXPRKIND.LOGAND ? callF : callT;
            rval.CallOp = callExpr;
            rval.Flags |= EXPRFLAG.ASSGOP;

            return rval;
        }

        // Utility methods for operator overload resolution.

        //--------------------------------------------------
        // FUNCBREC.GetBokAndFlags
        //
        /// <summary>
        /// Given a binary operator EXPRKIND, get the BinOpKind and flags.
        /// </summary>
        /// <remarks>
        /// REVIEW ShonK: Use a lookup table of some sort. It'd work best if we had the OPERATOR instead
        /// of EXPRKIND.
        /// </remarks>
        /// <param name="exprKind"></param>
        /// <param name="binOpKind"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool GetBokAndFlags(EXPRKIND exprKind, out BinOpKindEnum binOpKind, out EXPRFLAG flags)
        {
            binOpKind = 0;
            flags = 0;
            EXPRFLAG tempFlags = 0;

            switch (exprKind)
            {
                case EXPRKIND.ADD:
                    if (this.CheckedContext.IsNormal)
                    {
                        tempFlags |= EXPRFLAG.CHECKOVERFLOW;
                    }
                    binOpKind = BinOpKindEnum.Add;
                    break;

                case EXPRKIND.SUB:
                    if (this.CheckedContext.IsNormal)
                    {
                        tempFlags |= EXPRFLAG.CHECKOVERFLOW;
                    }
                    binOpKind = BinOpKindEnum.Sub;
                    break;

                case EXPRKIND.DIV:
                case EXPRKIND.MOD:
                    tempFlags |= EXPRFLAG.ASSGOP;
                    goto case EXPRKIND.MUL;

                case EXPRKIND.MUL:
                    if (this.CheckedContext.IsNormal)
                    {
                        tempFlags |= EXPRFLAG.CHECKOVERFLOW;
                    }
                    binOpKind = BinOpKindEnum.Mul;
                    break;

                case EXPRKIND.BITAND:
                case EXPRKIND.BITOR:
                    binOpKind = BinOpKindEnum.Bitwise;
                    break;

                case EXPRKIND.BITXOR:
                    binOpKind = BinOpKindEnum.BitXor;
                    break;

                case EXPRKIND.LSHIFT:
                case EXPRKIND.RSHIFT:
                    binOpKind = BinOpKindEnum.Shift;
                    break;

                case EXPRKIND.LOGOR:
                case EXPRKIND.LOGAND:
                    binOpKind = BinOpKindEnum.Logical;
                    break;

                case EXPRKIND.LT:
                case EXPRKIND.LE:
                case EXPRKIND.GT:
                case EXPRKIND.GE:
                    binOpKind = BinOpKindEnum.Compare;
                    break;

                case EXPRKIND.EQ:
                case EXPRKIND.NE:
                    binOpKind = BinOpKindEnum.Equal;
                    break;

                default:
                    DebugUtil.Assert(false, "Bad exprKind");
                    return false;
            }

            flags = tempFlags;
            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.CanConvertArg1
        //
        /// <summary>
        /// Utility method to determine whether arg1 is convertible to typeDst,
        /// either in a regular scenario or lifted scenario.
        /// Sets *pgrflt, *ptypeSig1 and *ptypeSig2 accordingly.
        /// </summary>
        /// <param name="binOpArgInfo"></param>
        /// <param name="dstTypeSym"></param>
        /// <param name="liftFlags"></param>
        /// <param name="sigTypeSym1"></param>
        /// <param name="sigTypeSym2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool CanConvertArg1(
            BinOpArgInfo binOpArgInfo,
            TYPESYM dstTypeSym,
            ref LiftFlagsEnum liftFlags,
            ref TYPESYM sigTypeSym1,
            ref TYPESYM sigTypeSym2)
        {
            DebugUtil.Assert(!dstTypeSym.IsNUBSYM);

            if (CanConvert(binOpArgInfo.ArgumentExpr1, dstTypeSym, 0))
            {
                liftFlags = LiftFlagsEnum.None;
            }
            else
            {
                if (!Compiler.FCanLift())
                {
                    return false;
                }
                dstTypeSym = Compiler.MainSymbolManager.GetNubType(dstTypeSym);
                if (!CanConvert(binOpArgInfo.ArgumentExpr1, dstTypeSym, 0))
                {
                    return false;
                }
                liftFlags = LiftFlagsEnum.Convert1;
            }
            sigTypeSym1 = dstTypeSym;

            if (binOpArgInfo.TypeSym2.IsNUBSYM)
            {
                liftFlags = liftFlags | LiftFlagsEnum.Lift2;
                sigTypeSym2 = Compiler.MainSymbolManager.GetNubType(binOpArgInfo.RawTypeSym2);
            }
            else
            {
                sigTypeSym2 = binOpArgInfo.RawTypeSym2;
            }

            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.CanConvertArg2
        //
        /// <summary>
        /// Same as CanConvertArg1 but with the indices interchanged!
        /// </summary>
        /// <param name="binOpArgInfo"></param>
        /// <param name="dstTypeSym"></param>
        /// <param name="liftFlags"></param>
        /// <param name="sigTypeSym1"></param>
        /// <param name="sigTypeSym2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool CanConvertArg2(
            BinOpArgInfo binOpArgInfo,
            TYPESYM dstTypeSym,
            ref LiftFlagsEnum liftFlags,
            ref TYPESYM sigTypeSym1,
            ref TYPESYM sigTypeSym2)
        {
            DebugUtil.Assert(!dstTypeSym.IsNUBSYM);

            if (CanConvert(binOpArgInfo.ArgumentExpr2, dstTypeSym, 0))
            {
                liftFlags = LiftFlagsEnum.None;
            }
            else
            {
                if (!Compiler.FCanLift())
                {
                    return false;
                }
                dstTypeSym = Compiler.MainSymbolManager.GetNubType(dstTypeSym);
                if (!CanConvert(binOpArgInfo.ArgumentExpr2, dstTypeSym, 0))
                {
                    return false;
                }
                liftFlags = LiftFlagsEnum.Convert2;
            }
            sigTypeSym2 = dstTypeSym;

            if (binOpArgInfo.TypeSym1.IsNUBSYM)
            {
                liftFlags = liftFlags | LiftFlagsEnum.Lift1;
                sigTypeSym1 = Compiler.MainSymbolManager.GetNubType(binOpArgInfo.RawTypeSym1);
            }
            else
            {
                sigTypeSym1 = binOpArgInfo.RawTypeSym1;
            }

            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.RecordBinOpSigFromArgs
        //
        /// <summary>
        /// Record the appropriate binary operator full signature from the given BinOpArgInfo.
        /// This assumes that any NUBSYM valued args should be lifted.
        /// </summary>
        /// <param name="bofsList"></param>
        /// <param name="binOpArgInfo"></param>
        /// <param name="binOpID"></param>
        //--------------------------------------------------
        private void RecordBinOpSigFromArgs(
            List<BinOpFullSig> bofsList,
            BinOpArgInfo binOpArgInfo,
            //PfnBindBinOp binOpID
            BindBinOpEnum binOpID)
        {
            LiftFlagsEnum liftFlags = LiftFlagsEnum.None;
            TYPESYM typeSig1;
            TYPESYM typeSig2;

            if (binOpArgInfo.TypeSym1 != binOpArgInfo.RawTypeSym1)
            {
                DebugUtil.Assert(binOpArgInfo.TypeSym1.IsNUBSYM);
                liftFlags = liftFlags | LiftFlagsEnum.Lift1;
                typeSig1 = Compiler.MainSymbolManager.GetNubType(binOpArgInfo.RawTypeSym1);
            }
            else
            {
                typeSig1 = binOpArgInfo.RawTypeSym1;
            }

            if (binOpArgInfo.TypeSym2 != binOpArgInfo.RawTypeSym2)
            {
                DebugUtil.Assert(binOpArgInfo.TypeSym2.IsNUBSYM);
                liftFlags = liftFlags | LiftFlagsEnum.Lift2;
                typeSig2 = Compiler.MainSymbolManager.GetNubType(binOpArgInfo.RawTypeSym2);
            }
            else
            {
                typeSig2 = binOpArgInfo.RawTypeSym2;
            }

            BinOpFullSig bofs = new BinOpFullSig();
            bofs.Set(typeSig1, typeSig2, binOpID, OpSigFlagsEnum.Value, liftFlags);
            bofsList.Add(bofs);
        }

        //--------------------------------------------------
        // FUNCBREC.GetDelBinOpSigs
        //
        /// <summary>
        /// Get the special signatures when at least one of the args is a delegate instance.
        /// Returns true iff an exact signature match is found.
        /// </summary>
        /// <param name="bofsList"></param>
        /// <param name="binOpArgInfo"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool GetDelBinOpSigs(List<BinOpFullSig> bofsList, BinOpArgInfo binOpArgInfo)
        {
            DebugUtil.Assert((binOpArgInfo.BinOpMask & BinOpMaskEnum.Delegate) != 0);
            DebugUtil.Assert(
                binOpArgInfo.TypeSym1.IsDelegateType() ||
                binOpArgInfo.TypeSym2.IsDelegateType());

            // Don't allow comparison with an anonymous method. It's just too weird.
            if ((binOpArgInfo.BinOpMask & BinOpMaskEnum.Equal) != 0 &&
                (binOpArgInfo.TypeSym1.IsANONMETHSYM || binOpArgInfo.TypeSym2.IsANONMETHSYM))
            {
                return false;
            }

            // No conversions needed. Determine the lifting. This is the common case.
            if (binOpArgInfo.TypeSym1 == binOpArgInfo.TypeSym2)
            {
                BinOpFullSig bofs = new BinOpFullSig();
                bofs.Set(
                    binOpArgInfo.TypeSym1,
                    binOpArgInfo.TypeSym2,
                    BindBinOpEnum.Delegate,
                    OpSigFlagsEnum.Reference,
                    LiftFlagsEnum.None);
                bofsList.Add(bofs);
                return true;
            }

            TYPESYM delTypeSym;

            // Conversions needed. Since there are no conversions between distinct delegate types
            // we never need to check both cases.
            if (binOpArgInfo.TypeSym1.IsDelegateType() ?
                    CanConvert(binOpArgInfo.ArgumentExpr2, delTypeSym = binOpArgInfo.TypeSym1, 0) :
                    CanConvert(binOpArgInfo.ArgumentExpr1, delTypeSym = binOpArgInfo.TypeSym2, 0))
            {
                BinOpFullSig bofs = new BinOpFullSig();
                bofs.Set(
                    delTypeSym,
                    delTypeSym,
                    BindBinOpEnum.Delegate,
                    OpSigFlagsEnum.Reference,
                    LiftFlagsEnum.None);
                bofsList.Add(bofs);
            }
            DebugUtil.Assert(delTypeSym.IsDelegateType());

            // Might be ambiguous so return false.
            return false;
        }

        //--------------------------------------------------
        // FUNCBREC.GetEnumBinOpSigs
        //
        /// <summary>
        /// Get the special signatures when at least one of the args is an enum.
        /// </summary>
        /// <param name="bofsList"></param>
        /// <param name="binOpArgInfo"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool GetEnumBinOpSigs(List<BinOpFullSig> bofsList, BinOpArgInfo binOpArgInfo)
        {
            DebugUtil.Assert(
                binOpArgInfo.RawTypeSym1.IsEnumType() ||
                binOpArgInfo.RawTypeSym2.IsEnumType());

            // (enum,      enum)       :         -         == != < > <= >= & | ^
            // (enum,      under)      :       + -
            // (under,     enum)       :       +
            TYPESYM sigTypeSym1 = null;
            TYPESYM sigTypeSym2 = null;
            LiftFlagsEnum liftFlags = 0;

            // Look for the no conversions cases. Still need to determine the lifting. These are the common case.
            if (binOpArgInfo.RawTypeSym1 == binOpArgInfo.RawTypeSym2)
            {
                if ((binOpArgInfo.BinOpMask & BinOpMaskEnum.Enum) == 0)
                {
                    return false;
                }
                RecordBinOpSigFromArgs(bofsList, binOpArgInfo, BindBinOpEnum.Enum);
                return true;
            }

            if (binOpArgInfo.RawTypeSym1.IsEnumType() ?
                binOpArgInfo.RawTypeSym2 == binOpArgInfo.RawTypeSym1.UnderlyingEnumType() &&
                (binOpArgInfo.BinOpMask & BinOpMaskEnum.EnumUnder) != 0
                :
                binOpArgInfo.RawTypeSym1 == binOpArgInfo.RawTypeSym2.UnderlyingEnumType() &&
                (binOpArgInfo.BinOpMask & BinOpMaskEnum.UnderEnum) != 0)
            {
                RecordBinOpSigFromArgs(bofsList, binOpArgInfo, BindBinOpEnum.Enum);
                return true;
            }

            // Now deal with the conversion cases. Since there are no conversions from enum types to other
            // enum types we never need to do both cases.
            if (binOpArgInfo.RawTypeSym1.IsEnumType() ?
                ((binOpArgInfo.BinOpMask & BinOpMaskEnum.Enum) != 0 &&
                CanConvertArg2(binOpArgInfo, binOpArgInfo.RawTypeSym1, ref liftFlags, ref sigTypeSym1, ref sigTypeSym2) ||
                (binOpArgInfo.BinOpMask & BinOpMaskEnum.EnumUnder) != 0 &&
                CanConvertArg2(
                    binOpArgInfo,
                    binOpArgInfo.RawTypeSym1.UnderlyingEnumType(),
                    ref liftFlags,
                    ref sigTypeSym1,
                    ref sigTypeSym2))
                :
                ((binOpArgInfo.BinOpMask & BinOpMaskEnum.Enum) != 0 &&
                CanConvertArg1(binOpArgInfo, binOpArgInfo.RawTypeSym2, ref liftFlags, ref sigTypeSym1, ref sigTypeSym2) ||
                (binOpArgInfo.BinOpMask & BinOpMaskEnum.EnumUnder) != 0 &&
                CanConvertArg1(
                    binOpArgInfo,
                    binOpArgInfo.RawTypeSym2.UnderlyingEnumType(),
                    ref liftFlags,
                    ref sigTypeSym1,
                    ref sigTypeSym2)))
            {
                BinOpFullSig bofs = new BinOpFullSig();
                bofs.Set(sigTypeSym1, sigTypeSym2, BindBinOpEnum.Enum, OpSigFlagsEnum.Value, liftFlags);
                bofsList.Add(bofs);
            }

            return false;
        }

        //--------------------------------------------------
        // FUNCBREC.GetRefEqualSigs
        //
        /// See if standard reference equality applies. Make sure not to return true if another == operator
        /// may be applicable and better (or ambiguous)! This also handles == on System.Delegate, since
        /// it has special rules as well.
        //--------------------------------------------------
        private bool GetRefEqualSigs(List<BinOpFullSig> bofsList, BinOpArgInfo binOpArgInfo)
        {
            DebugUtil.Assert(binOpArgInfo.BinOpMask == BinOpMaskEnum.Equal);
            BinOpFullSig bofs;

            if (binOpArgInfo.TypeSym1 != binOpArgInfo.RawTypeSym1 ||
                binOpArgInfo.TypeSym2 != binOpArgInfo.RawTypeSym2)
            {
                return false;
            }

            bool fRet = false;

            TYPESYM typeSym1 = binOpArgInfo.TypeSym1;
            TYPESYM typeSym2 = binOpArgInfo.TypeSym2;
            TYPESYM objTypeSym = GetRequiredPredefinedType(PREDEFTYPE.OBJECT);
            TYPESYM clsTypeSym = null;

            if (typeSym1.IsNULLSYM && typeSym2.IsNULLSYM)
            {
                clsTypeSym = objTypeSym;
                fRet = true;
                goto LRecord;
            }

            // Check for: operator ==(System.Delegate, System.Delegate).
            TYPESYM delTypeSym = GetRequiredPredefinedType(PREDEFTYPE.DELEGATE);

            if (CanConvert(binOpArgInfo.ArgumentExpr1, delTypeSym, 0) &&
                CanConvert(binOpArgInfo.ArgumentExpr2, delTypeSym, 0) &&
                !typeSym1.IsDelegateType() && !typeSym2.IsDelegateType())
            {
                bofs = new BinOpFullSig();
                bofs.Set(
                    delTypeSym,
                    delTypeSym,
                    BindBinOpEnum.Delegate,
                    OpSigFlagsEnum.Convert,
                    LiftFlagsEnum.None);
                bofsList.Add(bofs);
            }

            // The reference type equality operators only handle reference types.
            FUNDTYPE fundType1 = typeSym1.FundamentalType();
            FUNDTYPE fundType2 = typeSym2.FundamentalType();

            switch (fundType1)
            {
                default:
                    return false;

                case FUNDTYPE.REF:
                    break;

                case FUNDTYPE.VAR:
                    if ((typeSym1 as TYVARSYM).IsValueType() ||
                        (!(typeSym1 as TYVARSYM).IsReferenceType() && !typeSym2.IsNULLSYM))
                    {
                        return false;
                    }
                    typeSym1 = (typeSym1 as TYVARSYM).BaseClassSym;
                    break;
            }
            if (typeSym2.IsNULLSYM)
            {
                fRet = true;
                // We don't need to determine the actual best type since we're
                // returning true - indicating that we've found the best operator.
                clsTypeSym = objTypeSym;
                goto LRecord;
            }

            switch (fundType2)
            {
                default:
                    return false;

                case FUNDTYPE.REF:
                    break;

                case FUNDTYPE.VAR:
                    if ((typeSym2 as TYVARSYM).IsValueType() ||
                        (!(typeSym2 as TYVARSYM).IsReferenceType() && !typeSym1.IsNULLSYM))
                    {
                        return false;
                    }
                    typeSym2 = (typeSym2 as TYVARSYM).BaseClassSym;
                    break;
            }
            if (typeSym1.IsNULLSYM)
            {
                fRet = true;
                // We don't need to determine the actual best type since we're
                // returning true - indicating that we've found the best operator.
                clsTypeSym = objTypeSym;
                goto LRecord;
            }

            if (!CanCast(typeSym1, typeSym2, ConvertTypeEnum.NOUDC) &&
                !CanCast(typeSym2, typeSym1, ConvertTypeEnum.NOUDC))
            {
                return false;
            }

            if (typeSym1.IsInterfaceType() ||
                typeSym1.IsPredefType(PREDEFTYPE.STRING) ||
                Compiler.IsBaseType(typeSym1, delTypeSym))
            {
                typeSym1 = objTypeSym;
            }
            else if (typeSym1.IsARRAYSYM)
            {
                typeSym1 = GetRequiredPredefinedType(PREDEFTYPE.ARRAY);
            }
            else if (!typeSym1.IsClassType())
            {
                return false;
            }

            if (typeSym2.IsInterfaceType() ||
                typeSym2.IsPredefType(PREDEFTYPE.STRING) ||
                Compiler.IsBaseType(typeSym2, delTypeSym))
            {
                typeSym2 = objTypeSym;
            }
            else if (typeSym2.IsARRAYSYM)
            {
                typeSym2 = GetRequiredPredefinedType(PREDEFTYPE.ARRAY);
            }
            else if (!typeSym2.IsClassType())
            {
                return false;
            }

            DebugUtil.Assert(
                typeSym1.IsClassType() &&
                !typeSym1.IsPredefType(PREDEFTYPE.STRING) &&
                !typeSym1.IsPredefType(PREDEFTYPE.DELEGATE));
            DebugUtil.Assert(
                typeSym2.IsClassType() &&
                !typeSym2.IsPredefType(PREDEFTYPE.STRING) &&
                !typeSym2.IsPredefType(PREDEFTYPE.DELEGATE));

            if (Compiler.IsBaseType(typeSym2, typeSym1))
            {
                clsTypeSym = typeSym1;
            }
            else if (Compiler.IsBaseType(typeSym1, typeSym2))
            {
                clsTypeSym = typeSym2;
            }

        LRecord:
            bofs = new BinOpFullSig();
            bofs.Set(
                clsTypeSym,
                clsTypeSym,
                BindBinOpEnum.ReferenceCompare,
                OpSigFlagsEnum.None,
                LiftFlagsEnum.None);
            bofsList.Add(bofs);
            return fRet;
        }

        //--------------------------------------------------
        // FUNCBREC.GetPtrBinOpSigs
        //
        /// <summary>
        /// Get the special signatures when at least one of the args is a pointer.
        /// Since pointers can't be type arguments, a nullable pointer is illegal,
        /// so no sense trying to lift any of these.
        /// </summary>
        /// <remarks>
        /// NOTE: We don't filter out bad operators on void pointers since BindPtrBinOp gives better
        /// error messages than the operator overload resolution does.
        /// </remarks>
        /// <param name="bofsList"></param>
        /// <param name="binOpArgInfo"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool GetPtrBinOpSigs(List<BinOpFullSig> bofsList, BinOpArgInfo binOpArgInfo)
        {
            DebugUtil.Assert(binOpArgInfo.TypeSym1.IsPTRSYM || binOpArgInfo.TypeSym2.IsPTRSYM);
            BinOpFullSig bofs;

            // (ptr,       ptr)        :         -
            // (ptr,       int)        :       + -
            // (ptr,       uint)       :       + -
            // (ptr,       long)       :       + -
            // (ptr,       ulong)      :       + -
            // (int,       ptr)        :       +
            // (uint,      ptr)        :       +
            // (long,      ptr)        :       +
            // (ulong,     ptr)        :       +
            // (void*,     void*)      :                   == != < > <= >=

            // Check the common case first.
            if (binOpArgInfo.TypeSym1.IsPTRSYM && binOpArgInfo.TypeSym2.IsPTRSYM)
            {
                if ((binOpArgInfo.BinOpMask & BinOpMaskEnum.VoidPtr) != 0)
                {
                    bofs = new BinOpFullSig();
                    bofs.Set(
                        binOpArgInfo.TypeSym1,
                        binOpArgInfo.TypeSym2,
                        BindBinOpEnum.PointerCompare,
                        OpSigFlagsEnum.None,
                        LiftFlagsEnum.None);
                    bofsList.Add(bofs);
                    return true;
                }
                if (binOpArgInfo.TypeSym1 == binOpArgInfo.TypeSym2 &&
                    (binOpArgInfo.BinOpMask & BinOpMaskEnum.Ptr) != 0)
                {
                    bofs = new BinOpFullSig();
                    bofs.Set(
                        binOpArgInfo.TypeSym1,
                        binOpArgInfo.TypeSym2,
                        BindBinOpEnum.Pointer,
                        OpSigFlagsEnum.None,
                        LiftFlagsEnum.None);
                    bofsList.Add(bofs);
                    return true;
                }
                return false;
            }

            TYPESYM tmpTypeSym;

            if (binOpArgInfo.TypeSym1.IsPTRSYM)
            {
                if (binOpArgInfo.TypeSym2.IsNULLSYM)
                {
                    if ((binOpArgInfo.BinOpMask & BinOpMaskEnum.VoidPtr) == 0)
                    {
                        return false;
                    }
                    bofs = new BinOpFullSig();
                    bofs.Set(
                        binOpArgInfo.TypeSym1,
                        binOpArgInfo.TypeSym1,
                        BindBinOpEnum.PointerCompare,
                        OpSigFlagsEnum.Convert,
                        LiftFlagsEnum.None);
                    bofsList.Add(bofs);
                    return true;
                }
                if ((binOpArgInfo.BinOpMask & BinOpMaskEnum.PtrNum) == 0)
                {
                    return false;
                }

                for (int i = 0; i < rgptIntOp.Length; i++)
                {
                    if (CanConvert(
                        binOpArgInfo.ArgumentExpr2,
                        tmpTypeSym = GetRequiredPredefinedType(rgptIntOp[i]),
                        0))
                    {
                        bofs = new BinOpFullSig();
                        bofs.Set(
                            binOpArgInfo.TypeSym1,
                            tmpTypeSym,
                            BindBinOpEnum.Pointer,
                            OpSigFlagsEnum.Convert,
                            LiftFlagsEnum.None);
                        bofsList.Add(bofs);
                        return true;
                    }
                }
                return false;
            }

            DebugUtil.Assert(binOpArgInfo.TypeSym2.IsPTRSYM);
            if (binOpArgInfo.TypeSym1.IsNULLSYM)
            {
                if ((binOpArgInfo.BinOpMask & BinOpMaskEnum.VoidPtr) == 0)
                {
                    return false;
                }
                bofs = new BinOpFullSig();
                bofs.Set(
                    binOpArgInfo.TypeSym2,
                    binOpArgInfo.TypeSym2,
                    BindBinOpEnum.PointerCompare,
                    OpSigFlagsEnum.Convert,
                    LiftFlagsEnum.None);
                bofsList.Add(bofs);
                return true;
            }
            if ((binOpArgInfo.BinOpMask & BinOpMaskEnum.NumPtr) == 0)
            {
                return false;
            }

            for (int i = 0; i < rgptIntOp.Length; i++)
            {
                if (CanConvert(
                    binOpArgInfo.ArgumentExpr1,
                    tmpTypeSym = GetRequiredPredefinedType(rgptIntOp[i]),
                    0))
                {
                    bofs = new BinOpFullSig();
                    bofs.Set(
                        tmpTypeSym,
                        binOpArgInfo.TypeSym2,
                        BindBinOpEnum.Pointer,
                        OpSigFlagsEnum.Convert,
                        LiftFlagsEnum.None);
                    bofsList.Add(bofs);
                    return true;
                }
            }
            return false;
        }

        //--------------------------------------------------
        // FUNCBREC.WhichBofsIsBetter
        //
        /// <summary>
        /// <para>Determine which BinOpSig is better for overload resolution.
        /// Better means: at least as good in all params, and better in at least one param.</para>
        /// <para>Better w/r to a param means:
        /// 1) same type as argument
        /// 2) implicit conversion from this one's param type to the other's param type
        /// Because of user defined conversion operators this relation is not transitive.</para>
        /// <para>Returns negative if ibos1 is better, positive if ibos2 is better, 0 if neither.</para>
        /// </summary>
        /// <param name="bofs1"></param>
        /// <param name="bofs2"></param>
        /// <param name="type1"></param>
        /// <param name="type2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private int WhichBofsIsBetter(
            BinOpFullSig bofs1,
            BinOpFullSig bofs2,
            TYPESYM type1,
            TYPESYM type2)
        {
            BetterTypeEnum bt1;
            BetterTypeEnum bt2;

            if (bofs1.FPreDef() && bofs2.FPreDef())
            {
                // Faster to compare predefs.
                bt1 = WhichTypeIsBetter(bofs1.PredefinedType1, bofs2.PredefinedType1, type1);
                bt2 = WhichTypeIsBetter(bofs1.PredefinedType2, bofs2.PredefinedType2, type2);
            }
            else
            {
                bt1 = WhichTypeIsBetter(bofs1.TypeSym1, bofs2.TypeSym1, type1);
                bt2 = WhichTypeIsBetter(bofs1.TypeSym2, bofs2.TypeSym2, type2);
            }

            int res = 0;

            switch (bt1)
            {
                default:
                    DebugUtil.Assert(false, "Shouldn't happen");
                    goto case BetterTypeEnum.Neither;

                case BetterTypeEnum.Same:
                case BetterTypeEnum.Neither:
                    break;

                case BetterTypeEnum.Left:
                    res--;
                    break;
                case BetterTypeEnum.Right:
                    res++;
                    break;
            }

            switch (bt2)
            {
                default:
                    DebugUtil.Assert(false, "Shouldn't happen");
                    goto case BetterTypeEnum.Neither;

                case BetterTypeEnum.Same:
                case BetterTypeEnum.Neither:
                    break;

                case BetterTypeEnum.Left:
                    res--;
                    break;

                case BetterTypeEnum.Right:
                    res++;
                    break;
            }

            return res;
        }

        //--------------------------------------------------
        // FUNCBREC.WhichUofsIsBetter
        //
        /// <summary>
        /// Determine which UnaOpSig is better for overload resolution.
        /// Returns negative if iuos1 is better, positive if iuos2 is better, 0 if neither.
        /// </summary>
        /// <param name="uofs1"></param>
        /// <param name="uofs2"></param>
        /// <param name="argTypeSym"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private int WhichUofsIsBetter(
            UnaOpFullSig uofs1,
            UnaOpFullSig uofs2,
            TYPESYM argTypeSym)
        {
            BetterTypeEnum bt;

            if (uofs1.FPreDef() && uofs2.FPreDef())
            {
                // Faster to compare predefs.
                bt = WhichTypeIsBetter(uofs1.PredefinedType, uofs2.PredefinedType, argTypeSym);
            }
            else
            {
                bt = WhichTypeIsBetter(uofs1.TypeSym, uofs2.TypeSym, argTypeSym);
            }

            switch (bt)
            {
                default:
                    DebugUtil.Assert(false, "Shouldn't happen");
                    goto case BetterTypeEnum.Neither;

                case BetterTypeEnum.Same:
                case BetterTypeEnum.Neither:
                    return 0;

                case BetterTypeEnum.Left:
                    return -1;

                case BetterTypeEnum.Right:
                    return +1;
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindIntOp
        //
        /// <summary>
        /// Convert and constant fold an expression involving I4, U4, I8 or U8 operands.
        /// The operands are assumed to be already converted to the correct types.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="flags"></param>
        /// <param name="operand1"></param>
        /// <param name="operand2"></param>
        /// <param name="predefTypeID"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindIntOp(
            BASENODE treeNode,
            EXPRKIND exprKind,
            EXPRFLAG flags,
            EXPR operand1,
            EXPR operand2,
            PREDEFTYPE predefTypeID)
        {
            DebugUtil.Assert(
                EXPRKIND.RELATIONAL_MIN <= exprKind && exprKind <= EXPRKIND.RELATIONAL_MAX ||
                EXPRKIND.ARITH_MIN <= exprKind && exprKind <= EXPRKIND.ARITH_MAX ||
                EXPRKIND.BIT_MIN <= exprKind && exprKind <= EXPRKIND.BIT_MAX);
            DebugUtil.Assert(
                predefTypeID == PREDEFTYPE.INT ||
                predefTypeID == PREDEFTYPE.UINT ||
                predefTypeID == PREDEFTYPE.LONG ||
                predefTypeID == PREDEFTYPE.ULONG);

            TYPESYM opTypeSym = this.GetRequiredPredefinedType(predefTypeID);

            DebugUtil.Assert(opTypeSym != null);
            DebugUtil.Assert(operand1 != null && operand1.TypeSym == opTypeSym);
            DebugUtil.Assert(operand2 == null || operand2.TypeSym == opTypeSym);
            DebugUtil.Assert(
                (operand2 == null) == (
                    exprKind == EXPRKIND.NEG ||
                    exprKind == EXPRKIND.UPLUS ||
                    exprKind == EXPRKIND.BITNOT));

            bool isLong = (predefTypeID == PREDEFTYPE.LONG || predefTypeID == PREDEFTYPE.ULONG);

            // Check for constants.
            EXPR opConstExpr1 = operand1.GetConst();
            EXPR opConstExpr2 = ((operand2 != null) ? operand2.GetConst() : null);

            // Zero as second operand
            if (opConstExpr2 != null && opConstExpr2.IsZero(false))
            {
                switch (exprKind)
                {
                    case EXPRKIND.ADD:
                    case EXPRKIND.SUB:
                    case EXPRKIND.BITOR:
                    case EXPRKIND.BITXOR:
                        // Result is operand1.
                        return AddSideEffects(treeNode, operand1, operand2, false, false);

                    case EXPRKIND.DIV:
                    case EXPRKIND.MOD:
                        // Integer division by zero -- an error.
                        Compiler.Error(treeNode, CSCERRID.ERR_IntDivByZero);
                        return NewError(treeNode, opTypeSym);

                    case EXPRKIND.MUL:
                    case EXPRKIND.BITAND:
                        // Result is zero.
                        return AddSideEffects(treeNode, operand2, operand1, true, false);

                    default:
                        break;
                }
            }

            // Zero as first operand
            if (opConstExpr1 != null && opConstExpr1.IsZero(false))
            {
                switch (exprKind)
                {
                    case EXPRKIND.ADD:
                    case EXPRKIND.BITOR:
                    case EXPRKIND.BITXOR:
                        // These are no-ops.
                        return AddSideEffects(treeNode, operand2, operand1, true, false);

                    case EXPRKIND.DIV:
                    case EXPRKIND.MOD:
                        if (opConstExpr2 == null)
                        {
                            // Since operand2 isn't constant, if operand2 is zero at runtime an exception
                            // should be thrown.
                            break;
                        }
                        // Fall through
                        goto case EXPRKIND.BITAND;

                    case EXPRKIND.MUL:
                    case EXPRKIND.BITAND:
                        // Result is zero.
                        return AddSideEffects(treeNode, operand1, operand2, false, false);

                    case EXPRKIND.SUB:
                        if ((predefTypeID == PREDEFTYPE.INT || predefTypeID == PREDEFTYPE.LONG) &&
                            (flags & EXPRFLAG.CHECKOVERFLOW) == 0)
                        {
                            // Convert (0 - x) to -x.
                            exprKind = EXPRKIND.NEG;
                            operand1 = AddSideEffects(treeNode, operand2, operand1, true, false);
                            opConstExpr1 = operand1.GetConst();
                            operand2 = null;
                            opConstExpr2 = null;
                        }
                        break;

                    default:
                        break;
                }
            }

            // Fold operation if both args are constant.
            if (opConstExpr1 != null && (operand2 == null || opConstExpr2 != null))
            {
                return (
                    isLong ?
                    FoldConstI8Op(treeNode, exprKind, operand1, opConstExpr1, operand2, opConstExpr2, predefTypeID) :
                    FoldConstI4Op(treeNode, exprKind, operand1, opConstExpr1, operand2, opConstExpr2, predefTypeID));
            }

            TYPESYM destTypeSym = opTypeSym;

            switch (exprKind)
            {
                case EXPRKIND.MUL:
                    if (opConstExpr1 != null &&
                        (!isLong && (opConstExpr1 as EXPRCONSTANT).ConstVal.GetInt() == 1 ||
                        isLong && (opConstExpr1 as EXPRCONSTANT).ConstVal.GetLong() == 1))
                    {
                        return AddSideEffects(treeNode, operand2, operand1, true, false);
                    }
                    if (opConstExpr2 != null &&
                        (!isLong && (opConstExpr2 as EXPRCONSTANT).ConstVal.GetInt() == 1 ||
                        isLong && (opConstExpr2 as EXPRCONSTANT).ConstVal.GetLong() == 1))
                    {
                        return AddSideEffects(treeNode, operand1, operand2, false, false);
                    }
                    break;

                case EXPRKIND.NEG:
                    switch (predefTypeID)
                    {
                        case PREDEFTYPE.INT:
                        case PREDEFTYPE.LONG:
                            if ((flags & EXPRFLAG.CHECKOVERFLOW) != 0)
                            {
                                operand2 = operand1;
                                operand1 = NewExprZero(treeNode, opTypeSym);
                                exprKind = EXPRKIND.SUB;
                            }
                            break;

                        case PREDEFTYPE.UINT:
                            if (operand1.TypeSym.FundamentalType() == FUNDTYPE.U4)
                            {
                                destTypeSym = this.GetRequiredPredefinedType(PREDEFTYPE.LONG);
                                operand1 = MustConvertCore(operand1, destTypeSym, treeNode, ConvertTypeEnum.NOUDC);
                            }
                            break;

                        case PREDEFTYPE.ULONG:
                            return BadOperatorTypesError(treeNode, operand1, operand2, null);

                        default:
                            break;
                    }
                    break;

                case EXPRKIND.BITOR:
                    {
                        // Want to warn about code like:
                        //        int hi = 1;
                        //        int lo = -1;
                        //        long value = (((long)hi) << 32) | lo;   // bad
                        FUNDTYPE ft1 = FUNDTYPE.NONE;
                        FUNDTYPE ft2 = FUNDTYPE.NONE;

                        if (operand1.Kind == EXPRKIND.CAST)
                        {
                            ft1 = (operand1 as EXPRCAST).Operand.TypeSym.FundamentalType();
                            if (ft1 != FUNDTYPE.I1 && ft1 != FUNDTYPE.I2 && (ft1 != FUNDTYPE.I4 || !isLong))
                            {
                                ft1 = FUNDTYPE.NONE;
                            }
                        }
                        if (operand2.Kind == EXPRKIND.CAST)
                        {
                            ft2 = (operand2 as EXPRCAST).Operand.TypeSym.FundamentalType();
                            if (ft2 != FUNDTYPE.I1 && ft2 != FUNDTYPE.I2 && (ft2 != FUNDTYPE.I4 || !isLong))
                            {
                                ft2 = FUNDTYPE.NONE;
                            }
                        }
                        if (ft1 == ft2) break;

                        // Don't error if one is a constant within the range of the other.
                        if (opConstExpr1 != null || opConstExpr2 != null)
                        {
                            long ln;	// __int64 ln;
                            long lnLim;	// __int64 lnLim;

                            if (opConstExpr1 != null)
                            {
                                DebugUtil.Assert(ft1 == FUNDTYPE.NONE);
                                ln = (opConstExpr1 as EXPRCONSTANT).ConstVal.GetLong();
                                ft1 = ft2;
                            }
                            else
                            {
                                DebugUtil.Assert(ft2 == FUNDTYPE.NONE);
                                ln = (opConstExpr2 as EXPRCONSTANT).ConstVal.GetLong();
                            }

                            // See if ln is in the range of ft1.
                            switch (ft1)
                            {
                                case FUNDTYPE.I1:
                                    lnLim = 0x80;
                                    break;
                                case FUNDTYPE.I2:
                                    lnLim = 0x8000;
                                    break;
                                default:
                                    lnLim = (long)0x0000000080000000;	// I64(0x0000000080000000);
                                    break;
                            }
                            if (ln >= -lnLim && ln < lnLim) break;
                        }

                        Compiler.Error(treeNode, CSCERRID.WRN_BitwiseOrSignExtend);
                    }
                    break;

                default:
                    if (EXPRKIND.RELATIONAL_MIN <= exprKind && exprKind <= EXPRKIND.RELATIONAL_MAX)
                    {
                        destTypeSym = this.GetRequiredPredefinedType(PREDEFTYPE.BOOL);

                        // Give warning if comparing to a constant that isn't in range.  E.g., int i; i < 0x80000000000.
                        if (opConstExpr1 != null && operand2.Kind == EXPRKIND.CAST)
                        {
                            CheckVacuousIntegralCompare(treeNode, operand2, opConstExpr1);
                        }
                        else if (opConstExpr2 != null && operand1.Kind == EXPRKIND.CAST)
                        {
                            CheckVacuousIntegralCompare(treeNode, operand1, opConstExpr2);
                        }
                    }
                    break;
            }

            // Allocate the result expression.
            EXPR resExpr = NewExprBinop(treeNode, exprKind, destTypeSym, operand1, operand2);
            resExpr.Flags |= flags;
            DebugUtil.Assert((resExpr.Flags & EXPRFLAG.LVALUE) == 0);
            return resExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.FoldConstI4Op
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="kind"></param>
        /// <param name="op1"></param>
        /// <param name="opConst1"></param>
        /// <param name="op2"></param>
        /// <param name="opConst2"></param>
        /// <param name="ptOp"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR FoldConstI4Op(
            BASENODE tree,
            EXPRKIND kind,
            EXPR op1,
            EXPR opConst1,
            EXPR op2,
            EXPR opConst2,
            PREDEFTYPE ptOp)
        {
            DebugUtil.Assert(ptOp == PREDEFTYPE.INT || ptOp == PREDEFTYPE.UINT);
            DebugUtil.Assert(opConst1.Kind == EXPRKIND.CONSTANT);
            DebugUtil.Assert(op1.TypeSym.IsPredefType(ptOp) && op1.TypeSym == opConst1.TypeSym);
            DebugUtil.Assert(
                op2 == null && opConst2 == null
                ||
                op2 != null &&
                opConst2 != null &&
                opConst2.Kind == EXPRKIND.CONSTANT &&
                op1.TypeSym == op2.TypeSym && op1.TypeSym == opConst2.TypeSym);

            bool fSigned = (ptOp == PREDEFTYPE.INT);

            // Get the operands
            uint u1 = (opConst1 as EXPRCONSTANT).ConstVal.GetUInt();
            uint u2 = opConst2 != null ? (opConst2 as EXPRCONSTANT).ConstVal.GetUInt(): 0;
            uint uRes = 0;
            bool fRes = false;
            DebugUtil.Assert(sizeof(uint) == 4);

            // The sign bit.
            const uint uSign = 0x80000000;

            // Do the operation.
            switch (kind)
            {
                case EXPRKIND.ADD:
                    uRes = u1 + u2;
                    // For signed, we want either sign(u1) != sign(u2) or sign(u1) == sign(uRes).
                    // For unsigned, the result should be at least as big as either operand (if it's bigger than
                    // one, it will be bigger than the other as well).
                    if (this.CheckedContext.IsConstant &&
                        (fSigned ? (((u1 ^ u2) | (u1 ^ uRes ^ uSign)) & uSign) == 0 : !(uRes >= u1)))
                    {
                        Compiler.Error(tree, CSCERRID.ERR_CheckedOverflow);
                    }
                    else
                    {
                        //(void)0;
                    }
                    break;

                case EXPRKIND.SUB:
                    uRes = u1 - u2;
                    // For signed, we want either sign(u1) == sign(u2) or sign(u1) == sign(uRes).
                    // For unsigned, the result should be no bigger than the first operand.
                    if (this.CheckedContext.IsConstant &&
                        (fSigned ? (((u1 ^ u2 ^ uSign) | (u1 ^ uRes ^ uSign)) & uSign) == 0 : !(uRes <= u1)))
                    {
                        Compiler.Error(tree, CSCERRID.ERR_CheckedOverflow);
                    }
                    else
                    {
                        //(void)0;
                    }
                    break;

                case EXPRKIND.MUL:
                    // Multiply mod 2^32 doesn't depend on signed vs unsigned.
                    uRes = u1 * u2;
                    // Note that divide depends on signed-ness.
                    // For signed, the first check detects 0x80000000 / 0xFFFFFFFF == 0x80000000.
                    // This test needs to come first to avoid an integer overflow exception - yes we get this
                    // in native code.
                    if (this.CheckedContext.IsConstant &&
                        (fSigned ? !((u2 != uRes || u1 == 1) && (int)uRes / (int)u1 == (int)u2) : !(uRes / u1 == u2)))
                    {
                        Compiler.Error(tree, CSCERRID.ERR_CheckedOverflow);
                    }
                    else
                    {
                        //(void)0;
                    }
                    break;

                case EXPRKIND.DIV:
                    DebugUtil.Assert(u2 != 0); // Caller should have handled this.
                    if (!fSigned)
                    {
                        uRes = u1 / u2;
                    }
                    else if (u2 != unchecked((uint)~0))
                    {
                        uRes = (uint)((int)u1 / (int)u2);
                    }
                    else
                    {
                        uRes = (uint)(-((int)u1));
                        if (this.CheckedContext.IsConstant && !(u1 != uSign))
                        {
                            Compiler.Error(tree, CSCERRID.ERR_CheckedOverflow);
                        }
                        else
                        {
                            //(void)0;
                        }
                    }
                    break;

                case EXPRKIND.MOD:
                    DebugUtil.Assert(u2 != 0); // Caller should have handled this.
                    if (!fSigned)
                    {
                        uRes = u1 % u2;
                    }
                    else if (u2 != unchecked((uint)~0))
                    {
                        uRes = (uint)((int)u1 % (int)u2);
                    }
                    else
                    {
                        uRes = 0;
                    }
                    break;

                case EXPRKIND.NEG:
                    if (!fSigned)
                    {
                        // Special case: a unary minus promotes a uint to a long
                        CONSTVAL cv = new CONSTVAL();
                        //cv.longVal = (__int64 *) allocator.Alloc(sizeof(__int64));
                        //*cv.longVal = -(__int64)u1;
                        cv.SetLong(-(long)u1);
                        return NewExprConstant(tree, this.GetRequiredPredefinedType(PREDEFTYPE.LONG), cv);
                    }

                    uRes = (uint)-(int)u1;
                    if (this.CheckedContext.IsConstant && !(u1 != uSign))
                    {
                        Compiler.Error(tree, CSCERRID.ERR_CheckedOverflow);
                    }
                    else
                    {
                        //(void)0;
                    }
                    break;

                case EXPRKIND.UPLUS:
                    uRes = u1;
                    break;

                case EXPRKIND.BITAND:
                    uRes = u1 & u2;
                    break;

                case EXPRKIND.BITOR:
                    uRes = u1 | u2;
                    break;

                case EXPRKIND.BITXOR:
                    uRes = u1 ^ u2;
                    break;

                case EXPRKIND.BITNOT:
                    uRes = ~u1;
                    break;

                case EXPRKIND.EQ:
                    //uRes = (uint)((u1 == u2) ? 1 : 0);
                    fRes = (u1 == u2);
                    break;

                case EXPRKIND.NE:
                    //uRes = (uint)((u1 != u2) ? 1 : 0);
                    fRes = (u1 != u2);
                    break;

                case EXPRKIND.LE:
                    //uRes = (uint)((fSigned ? (int)u1 <= (int)u2 : u1 <= u2) ? 1 : 0);
                    fRes = (fSigned ? (int)u1 <= (int)u2 : u1 <= u2);
                    break;

                case EXPRKIND.LT:
                    //uRes = (uint)((fSigned ? (int)u1 < (int)u2 : u1 < u2) ? 1 : 0);
                    fRes = (fSigned ? (int)u1 < (int)u2 : u1 < u2);
                    break;

                case EXPRKIND.GE:
                    //uRes = (uint)((fSigned ? (int)u1 >= (int)u2 : u1 >= u2) ? 1 : 0);
                    fRes = (fSigned ? (int)u1 >= (int)u2 : u1 >= u2);
                    break;
                case EXPRKIND.GT:
                    //uRes = (uint)((fSigned ? (int)u1 > (int)u2 : u1 > u2) ? 1 : 0);
                    fRes = (fSigned ? (int)u1 > (int)u2 : u1 > u2);
                    break;

                default:
                    DebugUtil.Assert(false, "Unknown op");
                    uRes = 0;
                    break;
            }

            TYPESYM typeDest = null;
            //TYPESYM typeDest = this.GetOptionalPredefinedType(
            //    EXPRKIND.RELATIONAL_MIN <= kind && kind <= EXPRKIND.RELATIONAL_MAX ? PREDEFTYPE.BOOL : ptOp);
            //DebugUtil.Assert(typeDest != null);

            // Allocate the result node.
            EXPR exprRes;
            if (EXPRKIND.RELATIONAL_MIN <= kind && kind <= EXPRKIND.RELATIONAL_MAX)
            {
                typeDest = this.GetRequiredPredefinedType(PREDEFTYPE.BOOL);
                exprRes = NewExprConstant(tree, typeDest, new ConstValInit(fRes));
            }
            else
            {
                typeDest = this.GetOptionalPredefinedType(ptOp);
                if (ptOp == PREDEFTYPE.INT)
                {
                    exprRes = NewExprConstant(tree, typeDest, new ConstValInit((int)uRes));
                }
                else
                {
                    exprRes = NewExprConstant(tree, typeDest, new ConstValInit(uRes));
                }
            }
            exprRes = AddSideEffects(tree, exprRes, op2, true, false);
            return AddSideEffects(tree, exprRes, op1, true, false);
        }

        //--------------------------------------------------
        // FUNCBREC.FoldConstI8Op
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="kind"></param>
        /// <param name="op1"></param>
        /// <param name="opConst1"></param>
        /// <param name="op2"></param>
        /// <param name="opConst2"></param>
        /// <param name="ptOp"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR FoldConstI8Op(
            BASENODE tree,
            EXPRKIND kind,
            EXPR op1,
            EXPR opConst1,
            EXPR op2,
            EXPR opConst2,
            PREDEFTYPE ptOp)
        {
            DebugUtil.Assert(ptOp == PREDEFTYPE.LONG || ptOp == PREDEFTYPE.ULONG);
            DebugUtil.Assert(opConst1.Kind == EXPRKIND.CONSTANT);
            DebugUtil.Assert(op1.TypeSym.IsPredefType(ptOp) && op1.TypeSym == opConst1.TypeSym);
            DebugUtil.Assert(
                op2 == null && opConst2 == null
                ||
                op2 != null &&
                opConst2 != null &&
                opConst2.Kind == EXPRKIND.CONSTANT &&
                op1.TypeSym == op2.TypeSym &&
                op1.TypeSym == opConst2.TypeSym);

            bool fSigned = (ptOp == PREDEFTYPE.LONG);

            // Get the operands
            ulong u1 = (opConst1 as EXPRCONSTANT).ConstVal.GetULong();
            ulong u2 = opConst2 != null ? (opConst2 as EXPRCONSTANT).ConstVal.GetULong() : (ulong)0;
            ulong uRes = 0;
            bool fRes = false;
            DebugUtil.Assert(sizeof(ulong) == 8);

            // The sign bit.
            const ulong uSign = (ulong)(0x8000000000000000);

            // Do the operation.
            switch (kind)
            {
                case EXPRKIND.ADD:
                    uRes = u1 + u2;
                    // For signed, we want either sign(u1) != sign(u2) or sign(u1) == sign(uRes).
                    // For unsigned, the result should be at least as big as either operand (if it's bigger than
                    // one, it will be bigger than the other as well).
                    if (this.CheckedContext.IsConstant &&
                        (fSigned ? (((u1 ^ u2) | (u1 ^ uRes ^ uSign)) & uSign) == 0 : !(uRes >= u1)))
                    {
                        Compiler.Error(tree, CSCERRID.ERR_CheckedOverflow);
                    }
                    else
                    {
                        //(void)0;
                    }
                    break;

                case EXPRKIND.SUB:
                    uRes = u1 - u2;
                    // For signed, we want either sign(u1) == sign(u2) or sign(u1) == sign(uRes).
                    // For unsigned, the result should be no bigger than the first operand.
                    if (this.CheckedContext.IsConstant &&
                        (fSigned ? (((u1 ^ u2 ^ uSign) | (u1 ^ uRes ^ uSign)) & uSign) == 0 : !(uRes <= u1)))
                    {
                        Compiler.Error(tree, CSCERRID.ERR_CheckedOverflow);
                    }
                    else
                    {
                        //(void)0;
                    }
                    break;

                case EXPRKIND.MUL:
                    // Multiply mod 2^32 doesn't depend on signed vs unsigned.
                    uRes = u1 * u2;
                    // Note that divide depends on signed-ness.
                    // For signed, the first check detects 0x8000000000000000 / 0xFFFFFFFFFFFFFFFF == 0x8000000000000000.
                    if (this.CheckedContext.IsConstant &&
                        (fSigned ? !((u2 != uRes || u1 == 1) && (long)uRes / (long)u1 == (long)u2) : !(uRes / u1 == u2)))
                    {
                        Compiler.Error(tree, CSCERRID.ERR_CheckedOverflow);
                    }
                    else
                    {
                        //(void)0;
                    }
                    break;

                case EXPRKIND.DIV:
                    DebugUtil.Assert(u2 != 0); // Caller should have handled this.
                    if (!fSigned)
                    {
                        uRes = u1 / u2;
                    }
                    else if (u2 != ~((ulong)0))
                    {
                        uRes = (ulong)((long)u1 / (long)u2);
                    }
                    else
                    {
                        uRes = (ulong)(-((long)u1));
                        if (this.CheckedContext.IsConstant && !(u1 != uSign))
                        {
                            Compiler.Error(tree, CSCERRID.ERR_CheckedOverflow);
                        }
                        else
                        {
                            //(void)0;
                        }
                    }
                    break;

                case EXPRKIND.MOD:
                    DebugUtil.Assert(u2 != 0); // Caller should have handled this.
                    if (!fSigned)
                    {
                        uRes = u1 % u2;
                    }
                    else if (u2 != ~((ulong)0))
                    {
                        uRes = (ulong)((long)u1 % (long)u2);
                    }
                    else
                    {
                        uRes = 0;
                    }
                    break;

                case EXPRKIND.NEG:
                    if (!fSigned)
                    {
                        //You can't do this!
                        return BadOperatorTypesError(tree, op1, op2, null);
                    }

                    uRes = (ulong)(-((long)u1));
                    if (this.CheckedContext.IsConstant && !(u1 != uSign))
                    {
                        Compiler.Error(tree, CSCERRID.ERR_CheckedOverflow);
                    }
                    else
                    {
                        //(void)0;
                    }
                    break;

                case EXPRKIND.UPLUS:
                    uRes = u1;
                    break;

                case EXPRKIND.BITAND:
                    uRes = u1 & u2;
                    break;

                case EXPRKIND.BITOR:
                    uRes = u1 | u2;
                    break;

                case EXPRKIND.BITXOR:
                    uRes = u1 ^ u2;
                    break;

                case EXPRKIND.BITNOT:
                    uRes = ~u1;
                    break;

                case EXPRKIND.EQ:
                    fRes = (u1 == u2);
                    break;

                case EXPRKIND.NE:
                    fRes = (u1 != u2);
                    break;

                case EXPRKIND.LE:
                    fRes = fSigned ? (long)u1 <= (long)u2 : u1 <= u2;
                    break;

                case EXPRKIND.LT:
                    fRes = fSigned ? (long)u1 < (long)u2 : u1 < u2;
                    break;

                case EXPRKIND.GE:
                    fRes = fSigned ? (long)u1 >= (long)u2 : u1 >= u2;
                    break;

                case EXPRKIND.GT:
                    fRes = fSigned ? (long)u1 > (long)u2 : u1 > u2;
                    break;

                default:
                    DebugUtil.Assert(false, "Unknown op");
                    uRes = 0;
                    break;
            }

            // Allocate the result node.
            TYPESYM typeDest;
            CONSTVAL cv = new CONSTVAL();

            if (EXPRKIND.RELATIONAL_MIN <= kind && kind <= EXPRKIND.RELATIONAL_MAX)
            {
                cv.SetBool(fRes);
                typeDest = this.GetRequiredPredefinedType(PREDEFTYPE.BOOL);
            }
            else
            {
                //cv.longVal = (ulong *) allocator.Alloc(sizeof(ulong));
                //*cv.ulongVal = uRes;
                if (ptOp == PREDEFTYPE.LONG)
                {
                    cv.SetLong((long)uRes);
                }
                else
                {
                    cv.SetULong(uRes);
                }
                typeDest = this.GetOptionalPredefinedType(ptOp);
                DebugUtil.Assert(typeDest != null);
            }

            // Allocate the result node.
            EXPR exprRes = NewExprConstant(tree, typeDest, cv);
            exprRes = AddSideEffects(tree, exprRes, op2, true, false);
            return AddSideEffects(tree, exprRes, op1, true, false);
        }

        //--------------------------------------------------
        // FUNCBREC.BindPtrToArray
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="localExpr"></param>
        /// <param name="arrayExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPtrToArray(BASENODE treeNode, EXPRLOCAL localExpr, EXPR arrayExpr)
        {
            TYPESYM elementTypeSym = (arrayExpr.TypeSym as ARRAYSYM).ElementTypeSym;
            TYPESYM pointerElementTypeSym = Compiler.MainSymbolManager.GetPtrType(elementTypeSym);

            // element must be unmanaged...
            if (IsManagedType(elementTypeSym))
            {
                Compiler.Error(treeNode, CSCERRID.ERR_ManagedAddr, new ErrArg(elementTypeSym));
            }

            SetExternalRef(elementTypeSym);

            EXPR testExpr = null;
            EXPR wrapArrayExpr = NewExprWrap(arrayExpr, TEMP_KIND.SHORTLIVED);
            (wrapArrayExpr as EXPRWRAP).DoNotFree = true;
            EXPR saveExpr = NewExprBinop(treeNode, EXPRKIND.SAVE, arrayExpr.TypeSym, arrayExpr, wrapArrayExpr);
            EXPR nullTestExpr = NewExprBinop(
                treeNode,
                EXPRKIND.NE,
                this.GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                saveExpr,
                NewExprConstant(treeNode, wrapArrayExpr.TypeSym, new ConstValInit((int)0)));
            EXPR lengthTextExpr;

            if ((arrayExpr.TypeSym as ARRAYSYM).Rank == 1)
            {
                EXPR lengthExpr = NewExprBinop(
                    treeNode,
                    EXPRKIND.ARRLEN,
                    this.GetRequiredPredefinedType(PREDEFTYPE.INT),
                    wrapArrayExpr,
                    null);
                lengthTextExpr = NewExprBinop(
                    treeNode,
                    EXPRKIND.NE,
                    this.GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                    lengthExpr,
                    NewExprConstant(treeNode, this.GetRequiredPredefinedType(PREDEFTYPE.INT), new ConstValInit((int)0)));
            }
            else
            {
                EXPR callExpr = BindPredefMethToArgs(
                    null,
                    PREDEFNAME.GETLENGTH,
                    this.GetRequiredPredefinedType(PREDEFTYPE.ARRAY),
                    wrapArrayExpr,
                    null,
                    null);
                lengthTextExpr = NewExprBinop(
                    treeNode,
                    EXPRKIND.NE,
                    this.GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                    callExpr,
                    NewExprConstant(treeNode, this.GetRequiredPredefinedType(PREDEFTYPE.INT), new ConstValInit((int)0)));
            }

            testExpr = NewExprBinop(
                treeNode,
                EXPRKIND.LOGAND,
                this.GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                nullTestExpr,
                lengthTextExpr);

            //EXPR * list = null;
            //EXPR ** pList = &list;
            EXPR listExpr = null;
            EXPR lastExpr = null;
            for (int cc = 0; cc < (arrayExpr.TypeSym as ARRAYSYM).Rank; cc++)
            {
                NewList(
                    NewExprConstant(treeNode, this.GetRequiredPredefinedType(PREDEFTYPE.INT), new ConstValInit((int)0)),
                    //&pList);
                    ref listExpr, ref lastExpr);
            }
            DebugUtil.Assert(listExpr != null);
            NoteReference(localExpr);

            EXPR addrExpr = NewExprBinop(
                treeNode,
                EXPRKIND.ADDR,
                pointerElementTypeSym,
                NewExprBinop(treeNode, EXPRKIND.ARRINDEX, elementTypeSym, wrapArrayExpr, listExpr),
                null);
            addrExpr.Flags |= EXPRFLAG.ADDRNOCONV;
            addrExpr = MustConvert(addrExpr, localExpr.TypeSym, ConvertTypeEnum.NOUDC);
            addrExpr = NewExprBinop(treeNode, EXPRKIND.ASSG, localExpr.TypeSym, localExpr, addrExpr);
            addrExpr.Flags |= EXPRFLAG.ASSGOP;
            addrExpr = NewExprBinop(
                null,
                EXPRKIND.SEQREV,
                localExpr.TypeSym,
                addrExpr,
                NewExprWrap(wrapArrayExpr, TEMP_KIND.SHORTLIVED)); // free the temp

            EXPR nullExpr = NewExprZero(null, localExpr.TypeSym);
            nullExpr = NewExprBinop(null, EXPRKIND.ASSG, localExpr.TypeSym, localExpr, nullExpr);
            nullExpr.Flags |= EXPRFLAG.ASSGOP;

            EXPR resExpr = NewExprBinop(null, EXPRKIND.BINOP, null, addrExpr, nullExpr);
            return NewExprBinop(treeNode, EXPRKIND.QMARK, localExpr.TypeSym, testExpr, resExpr);
        }

        //--------------------------------------------------
        // FUNCBREC.bindPtrToString
        //
        //--------------------------------------------------
        private EXPR BindPtrToString(BASENODE treeNode, EXPR stringNode)
        {
            TYPESYM returnTypeSym = Compiler.MainSymbolManager.GetPtrType(this.GetRequiredPredefinedType(PREDEFTYPE.CHAR));

            if (Compiler.MainSymbolManager.StringOffsetMethSym == null)
            {
                string name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.OFFSETTOSTRINGDATA);
                AGGTYPESYM helpersSym = this.GetOptionalPredefinedType(PREDEFTYPE.RUNTIMEHELPERS);
                if (helpersSym == null)
                {
                    return NewError(treeNode, returnTypeSym);
                }

                MemberLookup mem = new MemberLookup();
                if (!mem.Lookup(Compiler, helpersSym, null, this.parentDeclSym, name, 0, MemLookFlagsEnum.UserCallable) ||
                    !mem.FirstSym.IsPROPSYM ||
                    (mem.FirstSym as PROPSYM).GetMethodSym == null)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_MissingPredefinedMember,
                        new ErrArg(helpersSym), new ErrArg(name));
                    return NewError(treeNode, returnTypeSym);
                }
                mem.ReportWarnings(treeNode);
                Compiler.MainSymbolManager.StringOffsetMethSym = (mem.FirstSym as PROPSYM).GetMethodSym;
            }

            CheckFieldUse(stringNode, true);
            return NewExprBinop(treeNode, EXPRKIND.ADDR, returnTypeSym, stringNode, null);
        }

        //--------------------------------------------------
        // FUNCBREC.BindAssignment
        //
        /// <summary>
        /// <para>Bind the simple assignment operator =.</para>
        /// <para>(In sscli, allowExplicit has the default value false.</para>
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="operand1"></param>
        /// <param name="operand2"></param>
        /// <param name="allowExplicit"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindAssignment(
            BASENODE treeNode,
            EXPR operand1,
            EXPR operand2,
            bool allowExplicit) // = false
        {
            EXPR expr;
            bool isOp2NotAddrOp = false;
            bool wasOp2Cast = false;

            if (FncBindUtil.IsSameLocalOrField(operand1, operand2))
            {
                Compiler.Error(treeNode, CSCERRID.WRN_AssignmentToSelf);
            }

            if (operand1.Kind != EXPRKIND.LOCAL ||
                !(operand1 as EXPRLOCAL).LocVarSym.LocSlotInfo.MustBePinned)
            {
                if (!CheckLvalue(operand1, true))
                {
                    return NewError(treeNode, operand1.TypeSym);
                }
            }
            else
            {
                (operand1 as EXPRLOCAL).LocVarSym.LocSlotInfo.MustBePinned = false;
                (operand1 as EXPRLOCAL).LocVarSym.LocSlotInfo.IsPinned = true;

                if (operand2.TypeSym.IsARRAYSYM)
                {
                    return BindPtrToArray(treeNode, operand1 as EXPRLOCAL, operand2);
                }

                if (operand2.TypeSym == this.GetRequiredPredefinedType(PREDEFTYPE.STRING))
                {
                    operand2 = BindPtrToString(treeNode, operand2);
                }
                else if (operand2.Kind == EXPRKIND.ADDR)
                {
                    operand2.Flags |= EXPRFLAG.ADDRNOCONV;
                }
                else if (operand2.Kind != EXPRKIND.ERROR)
                {
                    isOp2NotAddrOp = true;
                    wasOp2Cast = (operand2.Kind == EXPRKIND.CAST);
                }
            }

            BASENODE op2TreeNode =
                (operand2.TreeNode != null ? operand2.TreeNode : treeNode);
#if false
            if (operand1.Kind == EXPRKIND.RUNTIMEBINDEDMEMBER ||
                operand2.Kind == EXPRKIND.RUNTIMEBINDEDMEMBER ||
                operand1.Kind == EXPRKIND.RUNTIMEBINDEDINVOCATION ||
                operand2.Kind == EXPRKIND.RUNTIMEBINDEDINVOCATION)  // CS4
            {
                // do not check
            }
#endif
            if (IsRuntimeBindingExpr(operand1) || IsRuntimeBindingExpr(operand2))
            {
                // do not check
            }
            else
            {
                operand2 = MustConvertCore(operand2, operand1.TypeSym, op2TreeNode, 0);
            }

            if (operand2.IsOK && isOp2NotAddrOp)
            {
                // Only report these errors if the convert succeeded
                if (wasOp2Cast)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_BadCastInFixed);
                }
                else
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_FixedNotNeeded);
                }
            }

            EXPR valueExpr2 = operand2.GetSeqVal();

            if (valueExpr2.Kind == EXPRKIND.CONSTANT ||
                valueExpr2.Kind == EXPRKIND.ZEROINIT ||
                valueExpr2.TypeSym.IsNUBSYM &&
                valueExpr2.Kind == EXPRKIND.CALL &&
                (valueExpr2 as EXPRCALL).MethodWithInst.MethSym == Compiler.MainSymbolManager.NullableCtorMethodSym &&
                (valueExpr2 as EXPRCALL).ArgumentsExpr.GetConst() != null)
            {
                // A constant, zero-init, or nullable constant, possibly with side effects.
                if (operand1.Kind == EXPRKIND.LOCAL)
                {
                    (operand1 as EXPRLOCAL).LocVarSym.LocSlotInfo.IsReferencedAssignement = true;
                }
            }
            else
            {
                NoteReference(operand1);
            }

            // Note: we can't do these transformations if operand2 contains side effects other
            // than the zero-init or call (when valueExpr2 contains other things sequenced in).
            if (operand2.Kind == EXPRKIND.CALL &&
                (operand2.Flags & EXPRFLAG.NEWOBJCALL) != 0 &&
                operand2.TypeSym.IsStructOrEnum() &&
                operand1.Kind == EXPRKIND.LOCAL &&
                !(operand1 as EXPRLOCAL).LocVarSym.LocSlotInfo.IsReferenceParameter &&
                !LocalDeclaredOutsideTry((operand1 as EXPRLOCAL).LocVarSym))
            {
                DebugUtil.Assert((operand2 as EXPRCALL).ObjectExpr == null);

                (operand2 as EXPRCALL).ObjectExpr = operand1;
                operand2.TypeSym = operand1.TypeSym;
                operand2.Flags &= ~EXPRFLAG.NEWOBJCALL;
                operand2.Flags |= EXPRFLAG.IMPLICITSTRUCTASSG;
                expr = operand2;
            }
            else if (
                operand2.Kind == EXPRKIND.ZEROINIT &&
                (operand2 as EXPRZEROINIT).Operand == null &&
                operand1.Kind != EXPRKIND.PROP &&
                (operand1.Kind != EXPRKIND.ARRINDEX || !operand1.TypeSym.IsTYVARSYM) &&
                CheckFieldUse(operand1, false))
            {
                (operand2 as EXPRZEROINIT).Operand = operand1;
                expr = operand2;
            }
            else
            {
                expr = NewExprBinop(treeNode, EXPRKIND.ASSG, operand1.TypeSym, operand1, operand2);
                expr.Flags |= EXPRFLAG.ASSGOP;
            }

            return expr;
        }

        //--------------------------------------------------
        // FUNCBREC.LocalDeclaredOutsideTry
        //
        /// <summary></summary>
        /// <param name="local"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool LocalDeclaredOutsideTry(LOCVARSYM local)
        {
            SCOPESYM declarationScope = local.DeclarationScope();

            for (SCOPESYM currentScope = this.currentScopeSym;
                (declarationScope != currentScope) && currentScope != null;
                currentScope = currentScope.ParentSym as SCOPESYM)
            {
                if ((currentScope.ScopeFlags & SCOPEFLAGS.TRYSCOPE) != 0)
                {
                    return true;
                }
            }
            return false;
        }

        //--------------------------------------------------
        // FUNCBREC.BindArrayIndex
        //
        /// <summary>
        /// Bind an array being dereferenced by one or more indexes: a[x], a[x,y], ...
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindArrayIndex(
            BINOPNODE treeNode,
            BindFlagsEnum bindFlags)	// = BindFlagsEnum.RValueRequired
        {
            EXPR expr;
            EXPR operand1;
            EXPR operand2;

            // base[foobar] is actually valid...
            if (treeNode.Operand1.Kind == NODEKIND.OP && treeNode.Operand1.Operator == OPERATOR.BASE)
            {
                operand1 = SetNodeExpr(treeNode.Operand1, BindBase(treeNode.Operand1));
                operand2 = BindExpr(treeNode.Operand2, BindFlagsEnum.RValueRequired);
                if (!operand1.IsOK || !operand2.IsOK)
                {
                    return NewError(treeNode, null);
                }
                expr = BindIndexer(treeNode, operand1, operand2, bindFlags | BindFlagsEnum.BaseCall);
                expr.Flags |= EXPRFLAG.BASECALL;
                return expr;
            }

            operand1 = BindExpr(treeNode.Operand1, BindFlagsEnum.RValueRequired);
            operand2 = BindExpr(treeNode.Operand2, BindFlagsEnum.RValueRequired);
            if (!operand1.IsOK || !operand2.IsOK)
            {
                return NewError(treeNode, null);
            }

            if (treeNode.Operand1 != null &&
                treeNode.Operand1.Kind == NODEKIND.UNOP &&
                treeNode.Operand1.Operator == OPERATOR.DEFAULT &&
                (operand1.TypeSym.IsReferenceType() || operand1.TypeSym.IsPTRSYM))
            {
                Compiler.Error(treeNode, CSCERRID.WRN_DotOnDefault, new ErrArg(operand1.TypeSym));
            }

            TYPESYM intTypeSym = this.GetRequiredPredefinedType(PREDEFTYPE.INT);

            // Array indexing must occur on an array type.
            Compiler.EnsureState(operand1.TypeSym, AggStateEnum.Prepared);
            if (!operand1.TypeSym.IsARRAYSYM)
            {
                if (operand1.TypeSym.IsPTRSYM)
                {
                    return BindPtrArrayIndexer(treeNode, operand1, operand2);
                }
                return BindIndexer(treeNode, operand1, operand2, bindFlags);
            }

            ARRAYSYM arrayTypeSym = operand1.TypeSym as ARRAYSYM;

            // Check the rank of the array against the number of indices provided, and
            // convert the indexes to ints

            TYPESYM destTypeSym = ChooseArrayIndexType(treeNode, operand2);

            if (destTypeSym == null)
            {
                // using int as the type will allow us to give a better error...
                destTypeSym = intTypeSym;
            }

            int rank = arrayTypeSym.Rank;

            int count = 0;
            //EXPR temp;
            //EXPR ** next = &operand2;
            //EXPR ** first;
            //AGAIN:
            //if (next[0].Kind == EXPRKIND.LIST) {
            //    first = &(next[0].AsBIN.p1);
            //    next = &(next[0].AsBIN.p2);
            //LASTONE:
            //    count++;
            //    temp = mustConvert(*first, destTypeSym);
            //    if (rank == 1) {
            //        checkNegativeConstant(first[0].tree, temp, CSCERRID.WRN_NegativeArrayIndex);
            //    }
            //    if (destTypeSym == intTypeSym) {
            //        *first = temp;
            //    } else {
            //        first[0] = newExpr(first[0].treeNode, EXPRKIND.CAST, destTypeSym);
            //        first[0].AsCAST.flags |= EXPRFLAG.INDEXEXPR;
            //        first[0].AsCAST.p1 = temp;
            //    }
            //    if (first != next) goto AGAIN;
            //} else {
            //    first = next;
            //    goto LASTONE;
            //}

            EXPR next = operand2;
            EXPR first;
            while (next != null)
            {
                if (next.Kind == EXPRKIND.LIST)
                {
                    first = next.AsBIN.Operand1;
                    next = next.AsBIN.Operand2;
                }
                else
                {
                    first = next;
                    next = null;
                }

                ++count;
                EXPR temp = MustConvert(first, destTypeSym, 0);
                if (rank == 1)
                {
                    CheckNegativeConstant(first.TreeNode, temp, CSCERRID.WRN_NegativeArrayIndex);
                }

                if (destTypeSym == intTypeSym)
                {
                    first = temp;
                }
                else
                {
                    first = NewExpr(first.TreeNode, EXPRKIND.CAST, destTypeSym);
                    (first as EXPRCAST).Flags |= EXPRFLAG.INDEXEXPR;
                    (first as EXPRCAST).Operand = temp;
                }
            }

            if (count != rank)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_BadIndexCount, new ErrArg(rank));
                return NewError(treeNode, arrayTypeSym.ElementTypeSym);
            }

            // Allocate a new expression, the type is the element type of the array.
            // Array index operations are always lvalues.
            expr = NewExprBinop(treeNode, EXPRKIND.ARRINDEX, arrayTypeSym.ElementTypeSym, operand1, operand2);
            expr.Flags |= EXPRFLAG.LVALUE | EXPRFLAG.ASSGOP;

            return expr;
        }

        //--------------------------------------------------
        // FUNCBREC.ChooseArrayIndexType
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private TYPESYM ChooseArrayIndexType(BASENODE tree, EXPR args)
        {
            // first, select the allowable types
            for (int ipt = 0; ipt < rgptIntOp.Length; ipt++)
            {
                TYPESYM type = GetRequiredPredefinedType(rgptIntOp[ipt]);

                EXPR tempExpr = args;
                while (tempExpr != null)
                {
                    EXPR arg;
                    if (tempExpr.Kind == EXPRKIND.LIST)
                    {
                        arg = tempExpr.AsBIN.Operand1;
                        tempExpr = tempExpr.AsBIN.Operand2;
                    }
                    else
                    {
                        arg = tempExpr;
                        tempExpr = null;
                    }
                    if (!CanConvert(arg, type, 0))
                    {
                        goto NEXTI;
                    }
                }
                return type;
            NEXTI: ;
            }

            return null;
        }

        //--------------------------------------------------
        // FUNCBREC.BindBinOp
        //
        /// <summary>
        /// Bind a binary expression (or statement...)
        /// </summary>
        /// <param name="treeBinOpNode"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindBinOp(
            BINOPNODE treeBinOpNode,
            BindFlagsEnum bindFlags)	// = BindFlagsEnum.RVALUEREQUIRED
        {
#if DEBUG
            if (treeBinOpNode.NodeID == 28108)
            {
                ;
            }
#endif
            DebugUtil.Assert(treeBinOpNode.IsAnyBinaryOperator);

            OPERATOR operatorID = treeBinOpNode.Operator;
            EXPR operand1;
            EXPR operand2;

            switch (operatorID)
            {
                //----------------------------------------------------
                // CALL
                //----------------------------------------------------
                case OPERATOR.CALL:
                    //return BindCall(treeBinOpNode as CALLNODE, bindFlags);
                    EXPR expr = BindCall(treeBinOpNode as CALLNODE, bindFlags);
                    if (expr.Kind != EXPRKIND.CALL)
                    {
                        return expr;
                    }
                    EXPRCALL callExpr = expr as EXPRCALL;
                    DebugUtil.Assert(callExpr != null);
                    METHSYM methSym = callExpr.MethodWithInst.MethSym;
                    if (methSym != null && methSym.IsInstanceExtensionMethod)
                    {
                        return BindExtensionMethod(callExpr);
                    }
                    return expr;

                //----------------------------------------------------
                // REFVALUE
                //----------------------------------------------------
                case OPERATOR.REFVALUE:
                    return BindRefValue(treeBinOpNode);

                //----------------------------------------------------
                // ASSIGN
                //----------------------------------------------------
                case OPERATOR.ASSIGN:
                    DebugUtil.Assert(treeBinOpNode.Operand1 != null && treeBinOpNode.Operand2 != null);
                    // Simple assignment.
                    operand1 = BindExpr(treeBinOpNode.Operand1, BindFlagsEnum.MemberSet);
                    operand2 = BindExpr(treeBinOpNode.Operand2, BindFlagsEnum.RValueRequired);
                    DebugUtil.Assert(operand1 != null && operand2 != null);
                    if (!operand1.IsOK || !operand2.IsOK)
                    {
                        return NewError(treeBinOpNode, operand1.TypeSym);
                    }
                    return BindAssignment(treeBinOpNode, operand1, operand2, false);

                //----------------------------------------------------
                // DEREF
                //----------------------------------------------------
                case OPERATOR.DEREF:
                    // Array indexing
                    return BindArrayIndex(treeBinOpNode, bindFlags);

                //----------------------------------------------------
                // CAST
                //----------------------------------------------------
                case OPERATOR.CAST:
                    {
                        // p1 is the type to cast to. p2 is the thing to cast.
                        TYPESYM destTypeSym = BindType(treeBinOpNode.Operand1.AsANYTYPE);
                        return MustCastCore(
                            BindExpr(
                                treeBinOpNode.Operand2,
                                BindFlagsEnum.RValueRequired | (bindFlags & BindFlagsEnum.FixedValue)),
                            destTypeSym,
                            treeBinOpNode,
                            0);
                    }

                //----------------------------------------------------
                // ADDEQ, SUMEQ
                // These are special if LHS is an event. Bind the LHS, but allow events.
                // If we get an event, then process specially, otherwise, bind +=, -= as usual.
                //----------------------------------------------------
                case OPERATOR.ADDEQ:
                case OPERATOR.SUBEQ:
                    {
                        DebugUtil.Assert(
                            treeBinOpNode.Operand1 != null &&
                            treeBinOpNode.Operand2 != null);

                        BASENODE p1 = treeBinOpNode.Operand1;

                        // A METHSYM isn't really valid here,
                        // but we'll report a better error message by allowing it through.
                        if (p1.IsAnyName)
                        {
                            operand1 = SetNodeExpr(p1, BindName(p1.AsANYNAME,
                                SYMBMASK.METHSYM |
                                SYMBMASK.EVENTSYM |
                                SYMBMASK.MEMBVARSYM |
                                SYMBMASK.LOCVARSYM |
                                SYMBMASK.PROPSYM,
                                BindFlagsEnum.RValueRequired));
                        }
                        else if (p1.Kind == NODEKIND.DOT)
                        {
                            operand1 = SetNodeExpr(p1, BindDot(p1.AsDOT,
                                SYMBMASK.METHSYM |
                                SYMBMASK.EVENTSYM |
                                SYMBMASK.MEMBVARSYM |
                                SYMBMASK.PROPSYM,
                                BindFlagsEnum.RValueRequired));
                        }
                        else
                        {
                            operand1 = BindExpr(p1, BindFlagsEnum.RValueRequired);
                        }

                        if (operand1.Kind == EXPRKIND.EVENT)
                        {
                            operand2 = BindExpr(treeBinOpNode.Operand2, BindFlagsEnum.RValueRequired);
                            DebugUtil.Assert(operand1.IsOK);
                            if (!operand2.IsOK)
                            {
                                return NewError(treeBinOpNode, operand1.TypeSym);
                            }
                            return BindEventAccess(
                                treeBinOpNode,
                                (operatorID == OPERATOR.ADDEQ),
                                operand1 as EXPREVENT,
                                operand2);
                        }
                    }
                    // LHS isn't an event; go into regular +=, -= processing.
                    goto BOUND_OP1;

                default:
                    break;
            }

            // Then normal binop expressions where both children are always bound first:
            if (operatorID == OPERATOR.SUB)
            {
                operand1 = BindExpr(
                    treeBinOpNode.Operand1,
                    BindFlagsEnum.RValueRequired | BindFlagsEnum.MaybeConfusedNegativeCast);
            }
            else
            {
                operand1 = BindExpr(treeBinOpNode.Operand1, BindFlagsEnum.RValueRequired);
            }

        BOUND_OP1:

            if (operatorID == OPERATOR.IS)
            {
                return BindIs(treeBinOpNode, operand1);
            }

            if (operatorID == OPERATOR.AS)
            {
                return BindAs(treeBinOpNode, operand1);
            }

            operand2 = BindExpr(treeBinOpNode.Operand2, BindFlagsEnum.RValueRequired);
            if (!operand1.IsOK || !operand2.IsOK)
            {
                return NewError(treeBinOpNode, null);
            }

            //--------------------------------------------------------
            // (CS4) Runtimebinding
            //--------------------------------------------------------
            if (FoundRuntimeBindedObject() &&
                (operand1.IsRuntimeBinded || operand2.IsRuntimeBinded))
            {
                return BindRuntimeBindedBinOp(
                    treeNode,
                    operatorID,
                    operand1,
                    operand2);
            }

            //--------------------------------------------------------
            // Otherwise, process as usual.
            //--------------------------------------------------------
            EXPRKIND ek = OP2EK[(int)operatorID];

            switch (ek)
            {
                case EXPRKIND.LT:
                case EXPRKIND.LE:
                case EXPRKIND.GT:
                case EXPRKIND.GE:
                case EXPRKIND.EQ:
                case EXPRKIND.NE:
                    if (FncBindUtil.IsSameLocalOrField(operand1, operand2))
                    {
                        Compiler.Error(treeBinOpNode, CSCERRID.WRN_ComparisonToSelf);
                    }
                    break;

                default:
                    break;
            }

            if (ek != EXPRKIND.COUNT)
            {
                if (ek > EXPRKIND.MULTIOFFSET)
                {
                    ek = (EXPRKIND)(ek - EXPRKIND.MULTIOFFSET);
                    return BindMultiOp(treeBinOpNode, ek, operand1, operand2);
                }
                bool isUserDef = false;
                NubInfo nin = null;
                return BindStdBinOp(treeBinOpNode, ek, operand1, operand2, ref isUserDef, ref nin);
            }

            switch (operatorID)
            {
                case OPERATOR.QUESTION:
                    return BindQMark(treeBinOpNode, operand1, operand2 as EXPRBINOP);

                case OPERATOR.COLON:
                    return NewExprBinop(treeBinOpNode, EXPRKIND.BINOP, null, operand1, operand2);

                case OPERATOR.VALORDEF:
                    return BindValOrDefOp(treeBinOpNode, operand1, operand2);

                default:
                    break;
            }

            Compiler.Error(treeBinOpNode, CSCERRID.ERR_UnimplementedOp, new ErrArg(OpName(operatorID)));
            return NewError(treeBinOpNode, null);
        }

        //--------------------------------------------------
        // FUNCBREC.BindCall
        //
        /// <summary>
        /// Bind a function call
        /// </summary>
        /// <param name="callNode"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindCall(CALLNODE callNode, BindFlagsEnum bindFlags)
        {
#if DEBUG
            if (callNode.NodeID == 7384)
            {
                ;
            }
#endif
            DebugUtil.Assert(callNode.Operator == OPERATOR.CALL);
            EXPR argsExpr;

            // __arglist
            if (callNode.Operand1.Kind == NODEKIND.OP && callNode.Operand1.Operator == OPERATOR.ARGS)
            {
                if ((bindFlags & BindFlagsEnum.Arguments) == 0)
                {
                    Compiler.Error(callNode, CSCERRID.ERR_IllegalArglist);
                }
                argsExpr = BindExpr(callNode.Operand2, BindFlagsEnum.RValueRequired | BindFlagsEnum.Arguments);
                if (argsExpr != null && !argsExpr.IsOK)
                {
                    return NewError(callNode, Compiler.MainSymbolManager.ArgListSym);
                }
                return NewExprBinop(
                    callNode,
                    EXPRKIND.ARGLIST,
                    Compiler.MainSymbolManager.ArgListSym,
                    argsExpr,
                    null);
            }

            EXPR expr = BindMethodName(callNode.Operand1);
            argsExpr = BindExpr(callNode.Operand2, BindFlagsEnum.RValueRequired | BindFlagsEnum.Arguments);

            if (!expr.IsOK)
            {
                return NewError(callNode, null);
            }
            //--------------------------------------------------------
            // (CS4) RUNTIMEBINDEDINVOCATION
            //--------------------------------------------------------
            if (expr.Kind == EXPRKIND.RUNTIMEBINDEDINVOCATION)
            {
                EXPRRUNTIMEBINDEDINVOCATION invokeExpr = expr as EXPRRUNTIMEBINDEDINVOCATION;
                DebugUtil.Assert(invokeExpr != null);
                invokeExpr.ArgumentsExpr = argsExpr;
                return invokeExpr;
            }

            EXPRMEMGRP grp = expr as EXPRMEMGRP;
            DebugUtil.Assert(grp.SymKind == SYMKIND.METHSYM);
            return BindGrpToArgs(callNode, bindFlags, grp, argsExpr);
        }

        //--------------------------------------------------
        // FUNCBREC.BindDot
        //
        /// <summary>
        /// <para>Bind the dot operator.  mask indicates allowed return values</para>
        /// <para>(In sscli, bindFlags has the default value BindFlagsEnum.RVALUEREQUIRED.)</para>
        /// </summary>
        /// <param name="binOpNode"></param>
        /// <param name="symMask"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindDot(
            BINOPNODE binOpNode,
            SYMBMASK symMask,
            BindFlagsEnum bindFlags)    //  = BindFlagsEnum.RVALUEREQUIRED
        {
            // The only valid masks are:
            // SYMBMASK.PROPSYM where we want a property
            // SYMBMASK.METHSYM where we want a method name, and we return an EXPRGRP
            // SYMBMASK.AGGTYPESYM | SYMBMASK.NUBSYM where we want a class name, and we return an EXPRCLASS
            // SYMBMASK.NSSSYM where we want a namespace, and we return an EXPRNSPACE
            // SYMBMASK.MEMBVARSYM where we want a field

            DebugUtil.Assert(symMask != 0);
            DebugUtil.Assert((symMask & ~(
                SYMBMASK.EVENTSYM |
                SYMBMASK.METHSYM |
                SYMBMASK.AGGTYPESYM |
                SYMBMASK.NUBSYM |
                SYMBMASK.NSAIDSYM |
                SYMBMASK.MEMBVARSYM |
                SYMBMASK.PROPSYM)) == 0);
            DebugUtil.Assert(((symMask & SYMBMASK.AGGTYPESYM) == 0) == ((symMask & SYMBMASK.NUBSYM) == 0));
            DebugUtil.Assert(binOpNode.Operand1 != null && binOpNode.Operand2 != null);

            BASENODE leftNode = binOpNode.Operand1;
            NAMENODE nameNode = binOpNode.Operand2.AsANYNAME;
            EXPR rval;
            bool isBase = false;

            EXPR leftExpr;

            const SYMBMASK leftSymMask =
                SYMBMASK.AGGTYPESYM |
                SYMBMASK.NUBSYM |
                SYMBMASK.NSAIDSYM |
                SYMBMASK.MEMBVARSYM |
                SYMBMASK.PROPSYM;

            if (binOpNode.Kind == NODEKIND.ARROW)
            {
                leftExpr = BindExpr(leftNode, BindFlagsEnum.RValueRequired);
                if (!leftExpr.IsOK)
                {
                    goto LHaveLeft;
                }
                if (!leftExpr.TypeSym.IsPTRSYM)
                {
                    Compiler.Error(binOpNode, CSCERRID.ERR_PtrExpected);
                    // Treat the . like a .
                    goto LHaveLeft;
                }

                leftExpr = NewExprBinop(
                    leftExpr.TreeNode,
                    EXPRKIND.INDIR,
                    (leftExpr.TypeSym as PTRSYM).BaseTypeSym,
                    leftExpr,
                    null);
                leftExpr.Flags |= EXPRFLAG.ASSGOP | EXPRFLAG.LVALUE;
                goto LHaveLeft;
            }

            switch (leftNode.Kind)
            {
                case NODEKIND.DOT:
                    // the left side is also a dot...
                    leftExpr = SetNodeExpr(
                        leftNode,
                        BindDot(
                            leftNode.AsDOT,
                            leftSymMask,
                            BindFlagsEnum.RValueRequired | bindFlags));
                    break;

                case NODEKIND.NAME:
                case NODEKIND.GENERICNAME:
                    leftExpr = SetNodeExpr(
                        leftNode,
                        BindName(
                            leftNode.AsANYNAME,
                            leftSymMask | SYMBMASK.LOCVARSYM,
                            BindFlagsEnum.RValueRequired | bindFlags));
                    break;

                case NODEKIND.ALIASNAME:
                    leftExpr = SetNodeExpr(leftNode, BindAliasName(leftNode.AsALIASNAME));
                    break;

                case NODEKIND.OP:
                    if (leftNode.Operator == OPERATOR.BASE)
                    {
                        leftExpr = SetNodeExpr(leftNode, BindBase(leftNode));
                        isBase = true;
                        break;
                    }
                    // Fall through.
                    goto default;

                default:
                    leftExpr = BindExpr(leftNode, BindFlagsEnum.RValueRequired);
                    if (leftNode.Kind == NODEKIND.UNOP &&
                        leftNode.Operator == OPERATOR.DEFAULT &&
                        (leftExpr.TypeSym.IsReferenceType() || leftExpr.TypeSym.IsPTRSYM))
                    {
                        Compiler.Error(
                            binOpNode,
                            CSCERRID.WRN_DotOnDefault,
                            new ErrArg(leftExpr.TypeSym));
                    }
                    break;
            }

        LHaveLeft:
            DebugUtil.Assert(leftExpr != null);

            // bind type parameters
            TypeArray typeArgs = TypeBind.BindTypeArgs(
                Compiler,
                nameNode,
                ContextForTypeBinding(),
                this.typeBindFlags);
            DebugUtil.Assert(typeArgs != null);

            string name = nameNode.Name;
            TYPESYM leftTypeSym = null;
            TypeArray typesGroup = BSYMMGR.EmptyTypeArray;
            SymWithType rightSymWithType = new SymWithType();

            if (leftExpr.Kind == EXPRKIND.NSPACE)
            {
                NSAIDSYM leftNsAidSym = (leftExpr as EXPRNSPACE).NsAidSym;

                SYM rightSym = TypeBind.SearchSingleNamespace(
                    Compiler,
                    nameNode,
                    name,
                    typeArgs,
                    leftNsAidSym,
                    this.parentDeclSym,
                    TypeBindFlagsEnum.None);
                DebugUtil.Assert(rightSym != null);

                if (rightSym.IsERRORSYM)
                {
                    return NewError(binOpNode, rightSym as ERRORSYM);
                }

                // SearchSingleNamespace should have ensured the arity is correct.
                DebugUtil.Assert(
                    rightSym.IsNSAIDSYM && typeArgs.Count == 0 ||
                    rightSym.IsAGGTYPESYM &&
                        (rightSym as AGGTYPESYM).GetAggregate().TypeVariables.Count == typeArgs.Count ||
                    rightSym.IsNUBSYM && typeArgs.Count == 1);
                rightSymWithType.Set(rightSym, null);
            }
            else
            {
                leftTypeSym = leftExpr.TypeSym;
                if (leftTypeSym == null || leftTypeSym.IsERRORSYM)
                {
                    return NewError(binOpNode, null);
                }

                Compiler.EnsureState(leftTypeSym, AggStateEnum.Prepared);

                if (leftTypeSym.IsARRAYSYM)
                {
                    // If leftTypeSym.IsARRAYSYM is true then isBase must be false.
                    DebugUtil.Assert(!isBase);

                    // Length property on rank 1 arrays is converted into the ldlen instruction.
                    if (name == Compiler.NameManager.GetPredefinedName(PREDEFNAME.LENGTH) &&
                        (leftTypeSym as ARRAYSYM).Rank == 1 &&
                        leftExpr.Kind != EXPRKIND.CLASS)
                    {
                        if (typeArgs.Count > 0)
                        {
                            ReportTypeArgsNotAllowedError(
                                nameNode,
                                typeArgs.Count,
                                new ErrArgRef(name),
                                new ErrArgRef(SYMKIND.PROPSYM));
                        }
                        rval = NewExprBinop(
                            binOpNode,
                            EXPRKIND.ARRLEN,
                            this.GetRequiredPredefinedType(PREDEFTYPE.INT),
                            leftExpr,
                            null);
                        rval.Flags |= EXPRFLAG.ASSGOP;
                        return rval;
                    }

                    // (sscli) All other members come from System.Array.
                    // 
                    // 2016/03/30 hirano567@hotmail.co.jp

                    TypeArray ta = new TypeArray();
                    ta.Add((leftTypeSym as ARRAYSYM).ElementTypeSym);
                    ta = Compiler.MainSymbolManager.AllocParams(ta);
                    leftTypeSym = Compiler.MainSymbolManager.GetInstAgg(
                        Compiler.MainSymbolManager.GenericArraySym,
                        ta);
#if false
                    leftTypeSym = this.GetRequiredPredefinedType(PREDEFTYPE.ARRAY);
#endif
                    Compiler.EnsureState(leftTypeSym, AggStateEnum.Prepared);
                }
                else if (leftTypeSym.IsNUBSYM)
                {
                    DebugUtil.Assert(!isBase);
                    TYPESYM leftAggTypeSym = (leftTypeSym as NUBSYM).GetAggTypeSym();
                    DebugUtil.Assert(leftAggTypeSym != null);
                    if (leftAggTypeSym != null)
                    {
                        leftTypeSym = leftAggTypeSym;
                        Compiler.EnsureState(leftTypeSym, AggStateEnum.Prepared);
                    }
                }

                if (!leftTypeSym.IsAGGTYPESYM && !leftTypeSym.IsTYVARSYM)
                {
                    if (!leftTypeSym.IsERRORSYM)
                    {
                        Compiler.Error(binOpNode, CSCERRID.ERR_BadUnaryOp,
                            new ErrArg("."), new ErrArg(leftTypeSym));
                    }
                    return NewError(binOpNode, null);
                }

                //----------------------------------------------------
                // (CS4) leftExpr is dynamic
                //----------------------------------------------------
                if (leftTypeSym.Kind == SYMKIND.DYNAMICSYM)
                {
                    if (nameNode == null)
                    {
                        return NewError(binOpNode, null);
                    }
                    return BindRuntimeBindedMember(
                        binOpNode,
                        leftExpr,
                        nameNode.Name,
                        this.methodSym.ClassSym.GetThisType(),
                        typeArgs,
                        null);
                }

                //----------------------------------------------------
                // Look for members.
                //----------------------------------------------------
                MemberLookup mem = new MemberLookup();

                if (!mem.Lookup(
                    Compiler,
                    leftTypeSym,
                    leftExpr,
                    this.parentDeclSym,
                    name,
                    typeArgs.Count,
                    isBase ?
                        (MemLookFlagsEnum.BaseCall | MemLookFlagsEnum.UserCallable) :
                        MemLookFlagsEnum.UserCallable))
                {
                    mem.ReportErrors(nameNode);
                    return NewError(binOpNode, null);
                }
                mem.ReportWarnings(nameNode);

                if (mem.FirstSym.IsAGGSYM)
                {
                    rightSymWithType.Set(mem.FirstSymAsAggTypeSym(typeArgs), null);
                    TypeBind.CheckConstraints(
                        Compiler,
                        binOpNode,
                        rightSymWithType.Sym as AGGTYPESYM,
                        CheckConstraintsFlagsEnum.None);

                    // Can only reference type names through their containing type.
                    if (leftExpr.Kind != EXPRKIND.CLASS && leftExpr.IsOK)
                    {
                        // This could be the weird E.M case
                        // where E can be either the class name or a prop / field / variable.
                        if ((leftExpr.Flags & EXPRFLAG.SAMENAMETYPE) == 0)
                        {
                            Compiler.Error(
                                nameNode,
                                CSCERRID.ERR_BadTypeReference,
                                new ErrArg(nameNode),
                                new ErrArg(rightSymWithType));
                            return NewError(nameNode, rightSymWithType.Sym as AGGTYPESYM);
                        }
                    }
                }
                else
                {
                    rightSymWithType = mem.FirstSymWithType;

                    if (mem.FirstSym.IsMETHSYM)
                    {
                        typesGroup = mem.GetAllTypes();
                    }
                    else
                    {
                        DebugUtil.Assert(typeArgs.Count == 0);
                        DebugUtil.Assert(!mem.IsMultiKind && mem.TypeCount == 1);
                    }
                }
            }

            DebugUtil.Assert(rightSymWithType != null && !rightSymWithType.Sym.IsAGGSYM);
            // should never be an AGGSYM (AGGTYPESYM instead).

            if ((rightSymWithType.Sym.Mask & symMask) == 0)
            {
                ErrorBadSK(nameNode, rightSymWithType, symMask, bindFlags);
                return NewError(nameNode, null);
            }

            EXPR expr = (leftExpr.Kind == EXPRKIND.CLASS) ? null : leftExpr;

            switch (rightSymWithType.Sym.Kind)
            {
                case SYMKIND.MEMBVARSYM:
                    DebugUtil.Assert(leftExpr.Kind != EXPRKIND.NSPACE);
                    rval = BindToField(
                        binOpNode,
                        expr,
                        FieldWithType.Convert(rightSymWithType),
                        bindFlags);
                    break;

                case SYMKIND.PROPSYM:
                    DebugUtil.Assert(leftExpr.Kind != EXPRKIND.NSPACE);
                    rval = BindToProperty(
                        binOpNode,
                        expr,
                        PropWithType.Convert(rightSymWithType),
                        isBase ? (bindFlags | BindFlagsEnum.BaseCall) : bindFlags,
                        null,
                        null);
                    break;

                case SYMKIND.EVENTSYM:
                    DebugUtil.Assert(leftExpr.Kind != EXPRKIND.NSPACE);
                    rval = BindToEvent(
                        binOpNode,
                        expr,
                        EventWithType.Convert(rightSymWithType),
                        isBase ? (bindFlags | BindFlagsEnum.BaseCall) : bindFlags);
                    break;

                case SYMKIND.NSAIDSYM:
                    rval = NewExpr(binOpNode, EXPRKIND.NSPACE, null);
                    (rval as EXPRNSPACE).NsAidSym = rightSymWithType.Sym as NSAIDSYM;
                    break;

                case SYMKIND.NUBSYM:
                case SYMKIND.AGGTYPESYM:
                    rval = NewExpr(binOpNode, EXPRKIND.CLASS, rightSymWithType.Sym as TYPESYM);
                    Compiler.EnsureState(rightSymWithType.Sym as TYPESYM, AggStateEnum.Prepared);
                    if (rightSymWithType.Sym.IsDeprecated())
                    {
                        ReportDeprecated(binOpNode, rightSymWithType);
                    }
                    break;

                case SYMKIND.METHSYM:
                    rval = NewExpr(binOpNode, EXPRKIND.MEMGRP, Compiler.MainSymbolManager.MethodGroupTypeSym);
                    EXPRMEMGRP grpExpr = rval as EXPRMEMGRP;
                    grpExpr.NameNode = nameNode;
                    grpExpr.Name = name;
                    grpExpr.SymKind = SYMKIND.METHSYM;
                    grpExpr.TypeArguments = typeArgs;
                    grpExpr.ParentTypeSym = leftTypeSym;
                    grpExpr.MethPropSym = null;
                    grpExpr.ObjectExpr = expr;
                    grpExpr.ContainingTypeArray = typesGroup;
                    rval.Flags |= EXPRFLAG.USERCALLABLE;

                    if (isBase)
                    {
                        rval.Flags |= EXPRFLAG.BASECALL;
                    }
                    break;

                default:
                    DebugUtil.Assert(false, "bad kind");
                    rval = null;
                    break;
            }

            if (rval != null && rval.TypeSym != null)
            {
                CheckUnsafe(binOpNode, rval.TypeSym, CSCERRID.ERR_UnsafeNeeded, null);
            }

            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.BindAliasName
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindAliasName(NAMENODE treeNode)
        {
            DebugUtil.Assert(treeNode.Kind == NODEKIND.ALIASNAME);

            SYM sym = TypeBind.BindName(Compiler, treeNode, ContextForTypeBinding(), this.typeBindFlags);
            DebugUtil.Assert(sym != null);

            if (sym.IsERRORSYM)
            {
                return NewError(treeNode, sym as ERRORSYM);
            }

            EXPR expr;

            switch (sym.Kind)
            {
                case SYMKIND.NSAIDSYM:
                    expr = NewExpr(treeNode, EXPRKIND.NSPACE, GetVoidType());
                    (expr as EXPRNSPACE).NsAidSym = sym as NSAIDSYM;
                    break;

                case SYMKIND.AGGTYPESYM:
                    expr = NewExpr(treeNode, EXPRKIND.CLASS, sym as AGGTYPESYM);
                    break;

                default:
                    DebugUtil.Assert(false, "bad kind");
                    return NewError(treeNode, null);
            }
            DebugUtil.Assert(expr != null);
            return expr;
        }

        //--------------------------------------------------
        // FUNCBREC.bindEventAccess
        //
        /// <summary>
        /// Bind an event add (+=) or event remove (-=) expression.
        /// Becomes a call to the adder or remover accessor.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="isAdd"></param>
        /// <param name="eventExpr"></param>
        /// <param name="rightExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindEventAccess(BASENODE treeNode, bool isAdd, EXPREVENT eventExpr, EXPR rightExpr)
        {
            // Convert RHS to the type of the event.
            EVENTSYM eventSym = eventExpr.EventWithType.EventSym;
            rightExpr = MustConvert(rightExpr, eventExpr.TypeSym, 0);

            // Get the correct accessorSym to callExpr.
            METHSYM accessorSym = isAdd ? eventSym.AddMethodSym : eventSym.RemoveMethodSym;

            if ((eventExpr.Flags & EXPRFLAG.BASECALL) != 0 && accessorSym.IsAbstract)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_AbstractBaseCall, new ErrArg(eventExpr.EventWithType));
            }

            // Call the accessorSym.
            EXPRCALL callExpr = NewExpr(treeNode, EXPRKIND.CALL, GetVoidType()) as EXPRCALL;
            callExpr.ObjectExpr = eventExpr.ObjectExpr;
            callExpr.Flags |= (eventExpr.Flags & EXPRFLAG.BASECALL);
            callExpr.MethodWithInst.Set(accessorSym, eventExpr.EventWithType.AggTypeSym, null);
            callExpr.ArgumentsExpr = rightExpr;

            return callExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindToField
        //
        /// <summary>
        /// Construct the EXPR node which corresponds to a field expression
        /// for a given field and object pointer.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="expr"></param>
        /// <param name="fieldWithType"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindToField(
            BASENODE treeNode,
            EXPR expr,
            FieldWithType fieldWithType,
            BindFlagsEnum bindFlags)	// = BindFlagsEnum.RVALUEREQUIRED
        {
            DebugUtil.Assert(
                fieldWithType.AggTypeSym != null &&
                fieldWithType.FieldSym.ClassSym == fieldWithType.AggTypeSym.GetAggregate());

            EXPR retExpr;
            EXPR origExpr = expr;

            if (fieldWithType.FieldSym.IsDeprecated())
            {
                ReportDeprecated(treeNode, fieldWithType);
            }

            TYPESYM fieldTypeSym = Compiler.MainSymbolManager.SubstType(
                fieldWithType.FieldSym.TypeSym,
                fieldWithType.AggTypeSym,
                null);

            if (expr != null && !expr.IsOK)
            {
                return NewError(treeNode, fieldTypeSym);
            }

            bool isConstrained = false;
            AdjustMemberObj(treeNode, fieldWithType, ref expr, ref isConstrained);
            if (fieldWithType.FieldSym.IsUnevaled &&
                !BindUnevaledConstantField(fieldWithType.FieldSym))
            {
                return NewError(treeNode, fieldTypeSym);
            }

            CheckFieldUse(origExpr, true);

            if ((bindFlags & BindFlagsEnum.RValueRequired) != 0)
            {
                fieldWithType.FieldSym.IsReferenced = true;
            }

            if (fieldWithType.FieldSym.IsConst)
            {
                // Special enum rule:
                // if we're evaluating an enumerator initializer, and the constant is any other enumerator,
                // it's treated as a constant of it's underlying ty^pe.

                if (this.methodSym == null &&
                    this.currentFieldSym != null &&
                    this.parentAggSym.IsEnum &&
                    fieldTypeSym.IsEnumType())
                {
                    fieldTypeSym = fieldTypeSym.UnderlyingType();
                }

                retExpr = NewExprConstant(treeNode, fieldTypeSym, fieldWithType.FieldSym.ConstVal);
            }
            else
            {
                retExpr = NewExpr(treeNode, EXPRKIND.FIELD, fieldTypeSym);

                int jbitPar;
                if (expr != null &&
                    (jbitPar = expr.GetOffset()) != 0 &&
                    expr.TypeSym.IsStructType() &&
                    fieldWithType.FieldSym.FixedAggSym == null)
                {
                    (retExpr as EXPRFIELD).Offset = jbitPar + FlowChecker.GetIbit(Compiler, fieldWithType);
                }
                else
                {
                    (retExpr as EXPRFIELD).Offset = 0;
                }

                (retExpr as EXPRFIELD).FieldWithType = fieldWithType;
                (retExpr as EXPRFIELD).ObjectExpr = expr;
                DebugUtil.Assert((int)BindFlagsEnum.MemberSet == (int)EXPRFLAG.MEMBERSET);	// both are 0x02.

                retExpr.Flags |= (EXPRFLAG)(bindFlags & BindFlagsEnum.MemberSet);
                if ((expr != null && expr.TypeSym.IsPTRSYM) || ObjectIsLvalue(expr))
                {
                    retExpr.Flags |= EXPRFLAG.LVALUE;

                    // Exception: a readonly field is not an lvalue
                    // unless we're in the constructor/static constructor appropriate for the field.
                    if (fieldWithType.FieldSym.IsReadOnly)
                    {
                        if (this.parentAggSym == null ||
                            this.methodSym == null ||
                            !this.methodSym.IsCtor ||
                            fieldWithType.FieldSym.ClassSym != this.parentAggSym ||
                            this.methodSym.IsStatic != fieldWithType.FieldSym.IsStatic ||
                            (expr != null && !IsThisPointer(expr)) ||
                            this.currentAnonymousMethodInfo != null)
                        {
                            retExpr.Flags &= ~EXPRFLAG.LVALUE;
                        }
                    }
                }
            }

            if (retExpr.TypeSym != null)
            {
                Compiler.EnsureState(retExpr.TypeSym, AggStateEnum.Prepared);
            }

            if (retExpr.Kind == EXPRKIND.FIELD && fieldWithType.FieldSym.FixedAggSym != null)
            {
                DebugUtil.Assert(fieldWithType.FieldSym.ClassSym.IsStruct);

                LOCVARSYM localSym = null;
                bool needsFixing = !IsFixedExpression(retExpr, out localSym);
                if (!ObjectIsLvalue(expr))
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_FixedNeedsLvalue);
                }
                else if (needsFixing != ((bindFlags & BindFlagsEnum.FixedValue) != 0))
                {
                    Compiler.Error(
                        treeNode,
                        !needsFixing ? CSCERRID.ERR_FixedNotNeeded : CSCERRID.ERR_FixedBufferNotFixed);
                }

                if (!needsFixing && localSym != null)
                {
                    // a localSym doesn't need fixing unless it might get hoisted into an anonymous method
                    if (localSym.UsedInAnonMeth)
                    {
                        if (localSym.NodeUsedInAnonMethod != null)
                        {
                            Compiler.Error(treeNode, CSCERRID.ERR_LocalCantBeFixedAndHoisted,
                                new ErrArg(localSym),
                                new ErrArgRefOnly(localSym.NodeUsedInAnonMethod));
                        }
                        else
                        {
                            Compiler.Error(treeNode, CSCERRID.ERR_LocalCantBeFixedAndHoisted, new ErrArg(localSym));
                        }
                    }
                    else
                    {
                        DebugUtil.Assert(treeNode != null);
                        if (localSym.AddressTakenNode == null)
                        {
                            localSym.AddressTakenNode = treeNode;
                        }
                    }
                }

                // Change the field access into an EXPRKIND.ADDR of the ((FixedBufferType)field).FixedElementField
                TYPESYM typeSym = retExpr.TypeSym;
                EXPRFLAG flags = retExpr.Flags;
                string pnNestedField = Compiler.NameManager.GetPredefinedName(PREDEFNAME.FIXEDELEMENT);

                retExpr.TypeSym = fieldWithType.FieldSym.FixedAggSym.GetThisType();
#if DEBUG
                (retExpr as EXPRFIELD).CheckedMarshalByRef = true;
#endif
                MEMBVARSYM nestedFieldSym = Compiler.MainSymbolManager.LookupAggMember(
                    pnNestedField,
                    fieldWithType.FieldSym.FixedAggSym,
                    SYMBMASK.MEMBVARSYM) as MEMBVARSYM;

                DebugUtil.Assert(nestedFieldSym != null && nestedFieldSym.TypeSym.IsSimpleType());
                DebugUtil.Assert(nestedFieldSym.TypeSym == (typeSym as PTRSYM).BaseTypeSym);

                EXPRFIELD fixedExpr = NewExpr(treeNode, EXPRKIND.FIELD, nestedFieldSym.TypeSym) as EXPRFIELD;
                // don't need to do substitution, since a it's a simple type
#if DEBUG
                fixedExpr.CheckedMarshalByRef = true;
#endif
                fixedExpr.FieldWithType.Set(nestedFieldSym, retExpr.TypeSym as AGGTYPESYM);
                fixedExpr.Flags = flags;
                fixedExpr.ObjectExpr = retExpr;
                fixedExpr.Offset = 0;

                EXPR addrExpr = NewExprBinop(treeNode, EXPRKIND.ADDR, typeSym, fixedExpr, null);
                addrExpr.Flags |= (flags & ~EXPRFLAG.LVALUE);
                DebugUtil.Assert((addrExpr.Flags & EXPRFLAG.LVALUE) == 0);
                retExpr = addrExpr;
            }

            return retExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindToProperty
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="expr"></param>
        /// <param name="propWithType"></param>
        /// <param name="bindFlags"></param>
        /// <param name="argsExpr"></param>
        /// <param name="otherAggTypeSym"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindToProperty(
            BASENODE treeNode,
            EXPR expr,
            PropWithType propWithType,
            BindFlagsEnum bindFlags,	//  = BindFlagsEnum.RVALUEREQUIRED
            EXPR argsExpr,				//  = null
            AGGTYPESYM otherAggTypeSym)	//  = null
        {
            DebugUtil.Assert(
                propWithType.Sym != null &&
                propWithType.Sym.IsPROPSYM &&
                propWithType.AggTypeSym != null &&
                propWithType.PropSym.ClassSym == propWithType.AggTypeSym.GetAggregate());
            DebugUtil.Assert((argsExpr == null) == !propWithType.PropSym.IsIndexer);
            DebugUtil.Assert(propWithType.PropSym.ParameterTypes.Count == 0 || propWithType.PropSym.IsIndexer);
            DebugUtil.Assert(
                otherAggTypeSym == null ||
                !propWithType.PropSym.IsIndexer &&
                otherAggTypeSym.GetAggregate() == propWithType.PropSym.ReturnTypeSym.GetAggregate());

            bool isConstrained = false;
            MethWithType getMwt = new MethWithType();
            MethWithType setMwt = new MethWithType();

            PostBindProp(
                treeNode,
                (bindFlags & BindFlagsEnum.BaseCall) != 0,
                propWithType,
                ref expr,
                ref isConstrained,
                getMwt,
                setMwt);

            TYPESYM returnTypeSym = Compiler.MainSymbolManager.SubstType(
                propWithType.PropSym.ReturnTypeSym,
                propWithType.AggTypeSym,
                null);
            DebugUtil.Assert(otherAggTypeSym == returnTypeSym || otherAggTypeSym == null);
            if (expr != null && !expr.IsOK)
            {
                return NewError(treeNode, returnTypeSym);
            }

            // if we are doing a get on this thing, and there is no get, and
            // most imporantly, we are not leaving the arguments to be bound by the array index
            // then error...
            if ((bindFlags & BindFlagsEnum.RValueRequired) != 0)
            {
                if (getMwt.IsNull)
                {
                    if (otherAggTypeSym != null)
                    {
                        goto LReturnType;
                    }
                    Compiler.ErrorRef(treeNode, CSCERRID.ERR_PropertyLacksGet, new ErrArgRef(propWithType));
                }
                else if ((bindFlags & BindFlagsEnum.BaseCall) != 0 && getMwt.MethSym.IsAbstract)
                {
                    // if the get exists, but is abstract, forbid the call as well...
                    if (otherAggTypeSym != null)
                    {
                        goto LReturnType;
                    }
                    Compiler.Error(treeNode, CSCERRID.ERR_AbstractBaseCall, new ErrArgRef(propWithType));
                }
                else if (!Compiler.ClsDeclRec.CheckAccess(
                    getMwt.MethSym, getMwt.AggTypeSym, this.parentDeclSym, null))
                {
                    // if the get exists, but is not accessible, give an error.
                    if (otherAggTypeSym != null)
                    {
                        goto LReturnType;
                    }
                    Compiler.ErrorRef(treeNode, CSCERRID.ERR_InaccessibleGetter, new ErrArgRef(propWithType));
                }
            }

            EXPRPROP rval = NewExpr(treeNode, EXPRKIND.PROP, returnTypeSym) as EXPRPROP;

            rval.SlotPropWithType = propWithType;
            rval.GetMethodWithType = getMwt;
            rval.SetMethodWithType = setMwt;
            rval.ArgumentsExpr = argsExpr;
            rval.ObjectExpr = expr;


            DebugUtil.Assert((int)EXPRFLAG.BASECALL == (int)BindFlagsEnum.BaseCall);
            // Both are 0x40.
            //if (((int)EXPRFLAG.BASECALL & (int)bindFlags) != 0)
            if ((BindFlagsEnum.BaseCall & bindFlags) != 0)
            {
                rval.Flags |= EXPRFLAG.BASECALL;
            }
            else if (isConstrained && expr != null)
            {
                // Use the constrained prefix.
                rval.Flags |= EXPRFLAG.CONSTRAINED;
            }

            if (rval.ArgumentsExpr != null)
            {
                VerifyMethodArgs(rval);
            }

            if (setMwt != null && setMwt.IsNotNull && ObjectIsLvalue(rval.ObjectExpr))
            {
                rval.Flags |= EXPRFLAG.LVALUE;
            }
            if (otherAggTypeSym != null)
            {
                rval.Flags |= EXPRFLAG.SAMENAMETYPE;
            }

            if (rval.TypeSym != null)
            {
                Compiler.EnsureState(rval.TypeSym, AggStateEnum.Prepared);
            }

            return rval;

        LReturnType:
            return NewExpr(treeNode, EXPRKIND.CLASS, otherAggTypeSym);
        }

        //--------------------------------------------------
        // FUNCBREC.BindToMethod
        //
        /// <summary>
        /// <para>Binds a call to a method,
        /// return type is an error or an EXPRCALL.</para>
        /// <para>(In sscli, default value flags = MemLookFlagsEnum.None</para>
        /// </summary>
        /// <param name="treeNode">
        /// <para>(sscli) tree - ParseTree for error messages</para>
        /// </param>
        /// <param name="expr">
        /// <para>(sscli) object - object to call method on</para>
        /// </param>
        /// <param name="methWithInst">
        /// <para>(sscli) pmwi - Meth to bind to.
        /// This will be morphed when we remap to an override.</para>
        /// </param>
        /// <param name="argsExpr">
        /// <para>(sscli) args - arguments</para>
        /// </param>
        /// <param name="flags">
        /// <para>(sscli) exprFlags - Flags to put on the generated expr</para>
        /// </param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindToMethod(
            BASENODE treeNode,
            EXPR expr,
            MethWithInst methWithInst,
            EXPR argsExpr,
            MemLookFlagsEnum flags)	// = MemLookFlagsEnum.None
        {
            DebugUtil.Assert(
                methWithInst != null &&
                methWithInst.IsNotNull &&
                methWithInst.Sym != null &&
                methWithInst.Sym.IsMETHSYM &&
                (!methWithInst.MethSym.IsOverride || methWithInst.MethSym.IsHideByName()));

            // Get the conditionals before mapping to an override.
            List<string> conditionalNameList
                = Compiler.ClsDeclRec.GetConditionalSymbols(methWithInst.MethSym);

            bool isConstrained = false;
            PostBindMeth(
                treeNode,
                (flags & MemLookFlagsEnum.BaseCall) != 0,
                methWithInst,
                ref expr,
                ref isConstrained);

            TYPESYM returnTypeSym = null;
            if ((flags & (MemLookFlagsEnum.Ctor | MemLookFlagsEnum.NewObj))
                == (MemLookFlagsEnum.Ctor | MemLookFlagsEnum.NewObj))
            {
                returnTypeSym = methWithInst.AggTypeSym;
            }
            else
            {
                returnTypeSym = Compiler.MainSymbolManager.SubstType(
                    methWithInst.MethSym.ReturnTypeSym,
                    methWithInst.AggTypeSym,
                    methWithInst.TypeArguments);
            }

            EXPRCALL callExpr = NewExpr(
                treeNode,
                EXPRKIND.CALL,
                returnTypeSym) as EXPRCALL;
            callExpr.MethodWithInst = methWithInst;
            callExpr.ArgumentsExpr = argsExpr;
            callExpr.ObjectExpr = expr;

            // Set the return type and flags for constructors.
            if ((flags & MemLookFlagsEnum.Ctor) != 0)
            {
                if ((flags & MemLookFlagsEnum.NewObj) != 0)
                {
                    callExpr.Flags |= EXPRFLAG.NEWOBJCALL | EXPRFLAG.CANTBENULL;
                }
                else
                {
                    DebugUtil.Assert(callExpr.TypeSym == this.GetVoidType());
                }
            }

            if ((flags & MemLookFlagsEnum.BaseCall) != 0)
            {
                callExpr.Flags |= EXPRFLAG.BASECALL;
            }
            else if (isConstrained && expr != null)
            {
                // Use the constrained prefix.
                callExpr.Flags |= EXPRFLAG.CONSTRAINED;
            }

            VerifyMethodArgs(callExpr);
            Compiler.EnsureState(callExpr.TypeSym, AggStateEnum.Prepared);

            if (conditionalNameList != null && conditionalNameList.Count > 0)
            {
                INFILESYM infile = null;
                if (this.methodSym != null)
                {
                    infile = this.methodSym.GetInputFile();
                }
                else if (this.currentFieldSym != null)
                {
                    infile = this.currentFieldSym.GetInputFile();
                }
                if (conditionalNameList != null &&
                    conditionalNameList.Count > 0 &&
                    infile != null)
                {
                    string defined = null;
                    foreach (string name in conditionalNameList)
                    {
                        if (infile.IsSymbolDefined(name))
                        {
                            defined = name;
                            break;
                        }
                    }
                    if (defined == null)
                    {
                        // Turn this call into a no-op
                        return NewExpr(treeNode, EXPRKIND.NOOP, GetVoidType());
                    }
                }
            }

            return callExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindToEvent
        //
        /// Construct the EXPR node which corresponds to an event expression
        /// for a given event and object pointer.
        //--------------------------------------------------
        private EXPR BindToEvent(
            BASENODE treeNode,
            EXPR expr,
            EventWithType eventWithType,
            BindFlagsEnum bindFlags)	//  BindFlagsEnum.RVALUEREQUIRED
        {
            DebugUtil.Assert(
                eventWithType.AggTypeSym != null &&
                eventWithType.EventSym.ClassSym == eventWithType.AggTypeSym.GetAggregate());

            EventWithType origEwt = eventWithType;
            EXPR origExpr = expr;

            // If it is virtual, find a remap of the method to something more specific.  This
            // may alter where the method is found.
            if ((bindFlags & BindFlagsEnum.BaseCall) != 0 && expr != null)
            {
                RemapToOverride(eventWithType, expr.TypeSym);
            }

            bool isConstrained = false;
            AdjustMemberObj(treeNode, eventWithType, ref expr, ref isConstrained);

            CheckFieldUse(origExpr, true);

            if (origEwt.EventSym.IsDeprecated())
            {
                ReportDeprecated(treeNode, origEwt);
            }
            else if (eventWithType.EventSym.IsDeprecated())
            {
                ReportDeprecated(treeNode, eventWithType);
            }

            TYPESYM eventTypeSym = Compiler.MainSymbolManager.SubstType(
                eventWithType.EventSym.TypeSym,
                eventWithType.AggTypeSym,
                null);
            Compiler.EnsureState(eventTypeSym, AggStateEnum.Prepared);

            if (expr != null && !expr.IsOK)
            {
                return NewError(treeNode, eventTypeSym);
            }

            EXPREVENT retExpr = NewExpr(treeNode, EXPRKIND.EVENT, eventTypeSym) as EXPREVENT;
            retExpr.ObjectExpr = expr;
            retExpr.EventWithType = eventWithType;

            DebugUtil.Assert((int)EXPRFLAG.BASECALL == (int)BindFlagsEnum.BaseCall);
            retExpr.Flags = (EXPRFLAG.BASECALL & (EXPRFLAG)bindFlags);

            return retExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.bindToLocal
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="localSym"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindToLocal(BASENODE treeNode, LOCVARSYM localSym, BindFlagsEnum bindFlags)
        {
            EXPR expr;

            if (localSym.IsConst)
            {
                expr = NewExprConstant(treeNode, localSym.TypeSym, localSym.ConstVal);
            }
            else
            {
                expr = MakeLocal(treeNode, localSym,
                    !localSym.LocSlotInfo.IsPinned && !localSym.IsNonWriteable ||
                    (bindFlags & BindFlagsEnum.UsingValue) != 0);
                DebugUtil.Assert((int)BindFlagsEnum.MemberSet == (int)EXPRFLAG.MEMBERSET);
                expr.Flags |= (EXPRFLAG)(bindFlags & BindFlagsEnum.MemberSet);
            }

            if ((bindFlags & BindFlagsEnum.RValueRequired) != 0)
            {
                DebugUtil.Assert(
                    localSym.LocSlotInfo.JbitDefAssg() != 0 ||
                    localSym.LocSlotInfo.HasInit ||
                    localSym.IsConst);

                if (!localSym.LocSlotInfo.IsReferenced)
                {
                    localSym.LocSlotInfo.IsReferenced = true;
                    this.unreferencedVarCount--;
                }
            }

            // If we're inside an anonymous delegate block, we need to mark any
            // locals that get used so they can be moved from the lo^cal scope
            // to a heap allocated object for the delegate to access
            if (this.currentAnonymousMethodInfo != null && !localSym.IsConst)
            {
                SYM scopeSym = this.currentScopeSym;
                bool used = true;
                // Only mark this lo^cal if it comes from a scope outside
                // the delegate. So if we don't find it's parent between
                // pCurrentScope and the inner-most delegate scope mark it.
                while (scopeSym != null && scopeSym.IsSCOPESYM)
                {
                    if (scopeSym == localSym.ParentSym)
                    {
                        used = false;
                        break;
                    }
                    else if (((scopeSym as SCOPESYM).ScopeFlags & SCOPEFLAGS.KINDMASK) == SCOPEFLAGS.DELEGATESCOPE)
                    {
                        break;
                    }
                    scopeSym = scopeSym.ParentSym;
                }
                if (used)
                {
                    if (localSym.LocSlotInfo.IsParameter && localSym.LocSlotInfo.IsReferenceParameter)
                    {
                        // Illegal to use ref or out args in anonymous delegate blocks
                        Compiler.Error(treeNode, CSCERRID.ERR_AnonDelegateCantUse, new ErrArg(localSym.Name));
                        return NewError(treeNode, localSym.TypeSym);
                    }

                    // Mark it as used (unless the use is illegal)
                    if (localSym.IsAssumedPinned())
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_LocalCantBeFixedAndHoisted,
                            new ErrArg(localSym), new ErrArgRefOnly(localSym.AddressTakenNode));
                    }
                    else
                    {
                        DebugUtil.Assert(treeNode != null);
                        localSym.UsedInAnonMeth = true;
                        if (localSym.NodeUsedInAnonMethod == null)
                        {
                            localSym.NodeUsedInAnonMethod = treeNode;
                        }
                    }
                }
            }

            return expr;
        }

        //--------------------------------------------------
        // FUNCBREC.CheckForTypeSameName
        //
        /// <summary>
        // For handling the weird E.M case.
        /// </summary>
        /// <param name="nameNode"></param>
        /// <param name="sym"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private AGGTYPESYM CheckForTypeSameName(NAMENODE nameNode, SYM sym, NameCacheFlagsEnum flags)
        {
            DebugUtil.Assert(
                (flags & NameCacheFlagsEnum.TypeSameName) == 0 ||
                (flags & NameCacheFlagsEnum.NoTypeSameName) == 0);

            if ((flags & NameCacheFlagsEnum.NoTypeSameName) != 0 || nameNode.Kind == NODEKIND.GENERICNAME)
            {
                return null;
            }

            TYPESYM typeSym;

            switch (sym.Kind)
            {
                default:
                    DebugUtil.Assert(false);
                    return null;

                case SYMKIND.LOCVARSYM:
                    typeSym = (sym as LOCVARSYM).TypeSym;
                    break;

                case SYMKIND.MEMBVARSYM:
                    typeSym = (sym as MEMBVARSYM).TypeSym;
                    break;

                case SYMKIND.PROPSYM:
                    typeSym = (sym as PROPSYM).ReturnTypeSym;
                    break;
            }

            if (!typeSym.IsAGGTYPESYM)
            {
                return null;
            }
            if ((flags & NameCacheFlagsEnum.TypeSameName) != 0)
            {
                return typeSym as AGGTYPESYM;
            }

            SYM sameSym = TypeBind.BindName(
                Compiler,
                nameNode,
                ContextForTypeBinding(),
                this.typeBindFlags |
                TypeBindFlagsEnum.SuppressErrors |
                TypeBindFlagsEnum.NoBogusCheck |
                TypeBindFlagsEnum.AvoidEnsureState);
            if (sameSym != typeSym)
            {
                StoreFlagsInCache(nameNode.Name, flags | NameCacheFlagsEnum.NoTypeSameName);
                return null;
            }

            StoreFlagsInCache(nameNode.Name, flags | NameCacheFlagsEnum.TypeSameName);
            return typeSym as AGGTYPESYM;
        }

        //--------------------------------------------------
        // FUNCBREC.BindNameToSym
        //
        /// <summary>
        /// Bind the unqualified name.  mask details the allowed return types
        /// </summary>
        /// <param name="symWithType"></param>
        /// <param name="typeArguments"></param>
        /// <param name="typeArray"></param>
        /// <param name="otherAggTypeSym"></param>
        /// <param name="nameNode"></param>
        /// <param name="symMask"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool BindNameToSym(
            SymWithType symWithType,
            ref TypeArray typeArguments,
            ref TypeArray typeArray,
            ref AGGTYPESYM otherAggTypeSym,
            out EXPR objectExpr,
            NAMENODE nameNode,
            SYMBMASK symMask,
            BindFlagsEnum bindFlags)
        {
            DebugUtil.Assert(symWithType != null);
            DebugUtil.Assert(
                ((symMask & SYMBMASK.AGGTYPESYM) == 0) == ((symMask & SYMBMASK.NUBSYM) == 0));

            MemberLookup mem = new MemberLookup();
            AGGSYM errorAggSym = null;
            // The agg in which we found something useful for error reporting....

            string ident = nameNode.Name;
            TypeArray typesMem = null;
            AGGTYPESYM otherAggTypeSym2 = null;
            NameCacheFlagsEnum nameCacheFlags = NameCacheFlagsEnum.None;
            TypeArray typeArgs;
            SYM rval = null;

            symWithType.Clear();
            objectExpr = null;

            // bind type parameters
            typeArgs = TypeBind.BindTypeArgs(
                Compiler,
                nameNode,
                this.ContextForTypeBinding(),
                this.typeBindFlags);
            DebugUtil.Assert(typeArgs != null);

            if ((nameNode.Flags & NODEFLAGS.NAME_MISSING) != 0)
            {
                DebugUtil.Assert(Compiler.ErrorCount() > 0);
                return false;
            }

            if (typeArgs.Count == 0)
            {
                rval = LookupCachedName(
                    nameNode,
                    SYMBMASK.ALL,
                    out typesMem,
                    out objectExpr,
                    out nameCacheFlags);
                if (rval != null)
                {
                    symWithType.Set(
                        rval,
                        TypeArray.Size(typesMem) == 1 ? (typesMem[0] as AGGTYPESYM) : null);
                    goto LHaveIt;
                }
            }
            DebugUtil.Assert(nameCacheFlags == NameCacheFlagsEnum.None);

            // We got a cache miss.

            // See if it is a member in the current agg or an outer class.
            // The idea is to then later report an error
            // if the types of the "this" pointer don't match up.
            for (BAGSYM cls = this.parentAggSym;
                cls != null && cls.IsAGGSYM;
                cls =  (cls as AGGSYM).ParentBagSym)
            {
                AGGTYPESYM clsThisType = (cls as AGGSYM).GetThisType();
                if (!mem.Lookup(
                    Compiler,
                    clsThisType,
                    null,
                    this.parentDeclSym,
                    ident,
                    typeArgs.Count,
                    MemLookFlagsEnum.UserCallable | MemLookFlagsEnum.TypeVarsAllowed))
                {
                    if (mem.FirstSym == null)
                    {
                        if (errorAggSym == null && mem.HasIntelligentErrorInfo)
                        {
                            errorAggSym = cls as AGGSYM;
                        }
                        continue;
                    }
                    // Report the ambiguity then just use the first one.
                    mem.ReportErrors(nameNode);
                }
                else
                {
                    mem.ReportWarnings(nameNode);
                }

                if (mem.FirstSym.IsAGGSYM)
                {
                    symWithType.Set(mem.FirstSymAsAggTypeSym(typeArgs), null);
                    TypeBind.CheckConstraints(
                        Compiler,
                        nameNode,
                        symWithType.Sym as AGGTYPESYM,
                        CheckConstraintsFlagsEnum.None);
                }
                else
                {
                    typesMem = mem.GetAllTypes();
                    symWithType.Set(
                        mem.FirstSym,
                        typesMem.Count == 1 ? (typesMem[0] as AGGTYPESYM) : null);
                }

                // Only store in the cache if the arity is zero.
                if (typeArgs.Count == 0)
                {
                    StoreInCache(nameNode, ident, symWithType.Sym, typesMem, false);
                }
                goto LHaveIt;
            }

            // We didn't find anything in the class search. Do a namespace search.
            {
                DebugUtil.Assert(symWithType.Sym == null);

                TypeBind tb = new TypeBind();
                SYM symRes = tb.SearchNamespacesInst(
                    Compiler,
                    nameNode,
                    ident,
                    typeArgs,
                    this.parentDeclSym,
                    ContextForTypeBinding(),
                    this.typeBindFlags);

                if (symRes == null)
                {
                    if (errorAggSym != null)
                    {
                        // Deal with errors from the class search.
                        // Redo the lookup and report the errors.
                        if (!mem.Lookup(
                                Compiler,
                                errorAggSym.GetThisType(),
                                null,
                                this.parentDeclSym,
                                ident,
                                typeArgs.Count,
                                MemLookFlagsEnum.UserCallable | MemLookFlagsEnum.TypeVarsAllowed))
                        {
                            mem.ReportErrors(nameNode);
                            return false;
                        }
                        DebugUtil.Assert(false, "Why didn't we find a class error?");
                    }

                    if (!tb.HasIntelligentErrorInfo())
                    {
                        // tb.ReportErrors can't give a good message so we try to.
                        if (typeArgs.Count > 0 &&
                            (rval = LookupCachedName(
                                nameNode,
                                SYMBMASK.LOCVARSYM | SYMBMASK.TYVARSYM,
                                out typesMem,
                                out objectExpr,
                                out nameCacheFlags)) != null)
                        {
                            ReportTypeArgsNotAllowedError(
                                nameNode,
                                typeArgs.Count,
                                new ErrArgRef(rval),
                                new ErrArgSymKind(rval));
                        }
                        else
                        {
                            Compiler.Error(nameNode, CSCERRID.ERR_NameNotInContext, new ErrArg(ident));
                        }
                        return false;
                    }
                }

                symRes = tb.ReportErrors(nameNode, ident, null, typeArgs, symRes);
                if (symRes == null || symRes.IsERRORSYM) return false;

                symWithType.Set(symRes, null);
            }

            // Don't store the result in the cache if it is generic or if we're refactoring.
            // The former is because we can't cache the arity information. The latter is so we correctly map
            // using aliases                                         
            if (typeArgs.Count == 0)
            {
                StoreInCache(nameNode, nameNode.Name, symWithType.Sym, null, false);
            }

        LHaveIt:
            DebugUtil.Assert(
                typeArgs.Count == 0 ||
                symWithType.Sym.IsMETHSYM ||
                symWithType.Sym.IsAGGTYPESYM ||
                symWithType.Sym.IsNUBSYM);

            switch (symWithType.Sym.Kind)
            {
                case SYMKIND.TYVARSYM:
                    DebugUtil.Assert(typesMem == null || typesMem.Count == 1);
                    DebugUtil.Assert((symWithType.Sym as TYVARSYM).IsMethodTypeVariable == (typesMem == null));
                    break;

                case SYMKIND.NUBSYM:
                    DebugUtil.Assert(typesMem == null);
                    DebugUtil.Assert(typeArgs.Count == 1 && typeArgs[0] == symWithType.Sym.ParentSym);
                    break;

                case SYMKIND.AGGTYPESYM:
                    // Binding to a using alias may map arity 0 to non-zero arity.
                    DebugUtil.Assert(typesMem == null);
                    DebugUtil.Assert(typeArgs == (symWithType.Sym as AGGTYPESYM).TypeArguments || typeArgs.Count == 0);
                    break;

                case SYMKIND.NSAIDSYM:
                    DebugUtil.Assert(typesMem == null);
                    break;

                case SYMKIND.LOCVARSYM:
                    DebugUtil.Assert(typesMem == null);
                    if ((symMask & SYMBMASK.AGGTYPESYM) != 0)
                    {
                        otherAggTypeSym2 = CheckForTypeSameName(nameNode, symWithType.Sym, nameCacheFlags);
                    }
                    break;

                case SYMKIND.PROPSYM:
#if DEBUG
                    if (!(symWithType.AggTypeSym != null))
                    {
                        ;
                    }
#endif
                    DebugUtil.Assert(symWithType.AggTypeSym != null);
                    if ((symMask & SYMBMASK.AGGTYPESYM) != 0)
                    {
                        otherAggTypeSym2 = CheckForTypeSameName(nameNode, symWithType.Sym, nameCacheFlags);
                    }
                    break;

                case SYMKIND.MEMBVARSYM:
                    DebugUtil.Assert(symWithType.AggTypeSym != null);
                    if ((symMask & SYMBMASK.AGGTYPESYM) != 0 && !(symWithType.Sym as MEMBVARSYM).IsEvent)
                    {
                        otherAggTypeSym2 = CheckForTypeSameName(nameNode, symWithType.Sym, nameCacheFlags);
                    }
                    break;

                case SYMKIND.EVENTSYM:
                    DebugUtil.Assert(symWithType.AggTypeSym != null);
                    break;

                case SYMKIND.METHSYM:
                    DebugUtil.Assert(
                        typeArgs.Count == (symWithType.Sym as METHSYM).TypeVariables.Count ||
                        typeArgs.Count == 0);
                    DebugUtil.Assert(typesMem != null && typesMem.Count >= 1);
                    symWithType.AggTypeSym = null;
                    break;

                default:
                    DebugUtil.Assert(false, "bad kind");
                    return false;
            }

            if ((symWithType.Sym.Mask & symMask) == 0)
            {
                if (otherAggTypeSym2 == null || (symMask & SYMBMASK.AGGTYPESYM) == 0)
                {
                    ErrorBadSK(nameNode, symWithType, symMask, bindFlags);
                    symWithType.Clear();
                    return false;
                }

                // Use the type.
                symWithType.Set(otherAggTypeSym2, null);
                typesMem = null;
                otherAggTypeSym2 = null;
            }

            typeArguments = typeArgs;
            typeArray = typesMem;

            if (otherAggTypeSym2 != null)
            {
                Compiler.EnsureState(otherAggTypeSym2, AggStateEnum.Prepared);
            }
            otherAggTypeSym = otherAggTypeSym2;

            if (symWithType.Sym.IsTYPESYM)
            {
                Compiler.EnsureState(symWithType.Sym as TYPESYM, AggStateEnum.Prepared);
            }

            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.BindName
        //
        /// <summary>
        /// <para>Bind the unqualified name.  mask details the allowed return types</para>
        /// <para>(In sscli, symMask has the default value SYMBMASK.LOOKUPMASK.)</para>
        /// <para>(In sscli, bindFlags has the default value BindFlagsEnum.RVALUEREQUIRED.)</para>
        /// </summary>
        /// <param name="nameNode"></param>
        /// <param name="symMask"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindName(
            NAMENODE nameNode,
            SYMBMASK symMask,			// = SYMBMASK.LOOKUPMASK
            BindFlagsEnum bindFlags)	// = BindFlagsEnum.RVALUEREQUIRED
        {
#if DEBUG
            if (nameNode.NodeID == 7305)
            {
                ;
            }
#endif
            // TYVARSYMs can't be bound to an expression.
            DebugUtil.Assert((symMask & SYMBMASK.TYVARSYM) == 0);

            EXPR objectExpr = null; // thisExpr;
            TypeArray typeArgs = null;
            TypeArray types = null;
            AGGTYPESYM otherAggTypeSym = null;
            SymWithType symWithType = new SymWithType();
            SYM objectSym = null;
            EXPR expr = null;

            if (!BindNameToSym(
                symWithType,
                ref typeArgs,
                ref types,
                ref otherAggTypeSym,  // define in this method.
                out expr,
                nameNode,
                symMask,
                bindFlags)) // arguments
            {
                return NewError(nameNode, null);
            }
            DebugUtil.Assert((symWithType.Sym.Mask & symMask) != 0);

            if (expr != null)
            {
                return expr;
            }

            // First handle the kinds that don't need "this".
            switch (symWithType.Sym.Kind)
            {
                case SYMKIND.NSAIDSYM:
                    DebugUtil.Assert(types == null);
                    expr = NewExpr(nameNode, EXPRKIND.NSPACE, this.GetVoidType());
                    (expr as EXPRNSPACE).NsAidSym = symWithType.Sym as NSAIDSYM;
                    goto LDone;

                case SYMKIND.NUBSYM:
                case SYMKIND.AGGTYPESYM:
                    DebugUtil.Assert(types == null);
                    expr = NewExpr(nameNode, EXPRKIND.CLASS, symWithType.Sym as TYPESYM);
                    goto LDone;

                case SYMKIND.LOCVARSYM:
                    DebugUtil.Assert(types == null);
                    LOCVARSYM locSym = symWithType.Sym as LOCVARSYM;
                    DebugUtil.Assert(locSym != null);

                    expr = BindToLocal(nameNode, symWithType.Sym as LOCVARSYM, bindFlags);
                    if (otherAggTypeSym != null)
                    {
                        expr.Flags |= EXPRFLAG.SAMENAMETYPE;
                    }
                    goto LDone;

                default:
                    break;
            }

            if (objectSym == null)
            {
                // Now bind "this" and handle the kinds that might need "this".
                objectExpr = BindThisImplicit(nameNode);  // thisExpr
            }
            else
            {
                switch (objectSym.Kind)
                {
                    case SYMKIND.LOCVARSYM:
                        objectExpr = BindToLocal(
                            null,
                            objectSym as LOCVARSYM,
                            BindFlagsEnum.RValueRequired);                            
                        break;

                    default:
                        throw new NotImplementedException("");
                }
            }

            switch (symWithType.Sym.Kind)
            {
                case SYMKIND.PROPSYM:
                    DebugUtil.Assert(
                        types != null &&
                        types.Count == 1 &&
                        types[0] == symWithType.AggTypeSym);
                    DebugUtil.Assert(!symWithType.PropSym.IsIndexer);

                    if (otherAggTypeSym != null &&
                        !symWithType.PropSym.IsStatic &&
                        (objectExpr == null ||  // thisExpr
                        !CanConvert(
                            objectExpr.TypeSym, // thisExpr
                            symWithType.AggTypeSym,
                            ConvertTypeEnum.NOUDC)))
                    {
                        // Use the type.
                        expr = NewExpr(nameNode, EXPRKIND.CLASS, otherAggTypeSym);
                        break;
                    }
                    expr = BindToProperty(
                        nameNode,
                        objectExpr, // thisExpr,
                        PropWithType.Convert(symWithType),
                        bindFlags,
                        null,
                        otherAggTypeSym);
                    break;

                case SYMKIND.MEMBVARSYM:
                    DebugUtil.Assert(
                        types != null &&
                        types.Count == 1 &&
                        types[0] == symWithType.AggTypeSym);

                    if (otherAggTypeSym != null &&
                        !symWithType.FieldSym.IsStatic &&
                        (objectExpr == null ||  // thisExpr
                        !CanConvert(
                            objectExpr.TypeSym, // thisExpr
                            symWithType.AggTypeSym,
                            ConvertTypeEnum.NOUDC)))
                    {
                        // Use the type.
                        expr = NewExpr(nameNode, EXPRKIND.CLASS, otherAggTypeSym);
                        break;
                    }
                    expr = BindToField(
                        nameNode,
                        objectExpr, //thisExpr,
                        FieldWithType.Convert(symWithType),
                        bindFlags);
                    if (otherAggTypeSym != null)
                    {
                        expr.Flags |= EXPRFLAG.SAMENAMETYPE;
                    }
                    break;

                case SYMKIND.EVENTSYM:
                    DebugUtil.Assert(
                        types != null &&
                        types.Count == 1 &&
                        types[0] == symWithType.AggTypeSym);

                    expr = BindToEvent(
                        nameNode,
                        objectExpr, // thisExpr,
                        EventWithType.Convert(symWithType),
                        bindFlags);
                    break;

                case SYMKIND.METHSYM:
                    DebugUtil.Assert(types != null && types.Count >= 1);
                    expr = NewExpr(
                        nameNode,
                        EXPRKIND.MEMGRP,
                        Compiler.MainSymbolManager.MethodGroupTypeSym);
                    EXPRMEMGRP grpExpr = expr as EXPRMEMGRP;
                    grpExpr.NameNode = nameNode;
                    grpExpr.Name = nameNode.Name;
                    grpExpr.TypeArguments = typeArgs;
                    grpExpr.SymKind = SYMKIND.METHSYM;
                    grpExpr.ParentTypeSym = null;
                    grpExpr.MethPropSym = null;
                    grpExpr.ObjectExpr = objectExpr;    // thisExpr;
                    grpExpr.ContainingTypeArray = types;
                    grpExpr.Flags |= EXPRFLAG.USERCALLABLE;
                    break;

                default:
                    DebugUtil.Assert(false, "bad kind");
                    return NewError(nameNode, null);
            }

        LDone:
            DebugUtil.Assert(expr != null);
            if (expr.TypeSym != null)
            {
                CheckUnsafe(nameNode, expr.TypeSym, CSCERRID.ERR_UnsafeNeeded, null);
            }

            return expr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindUnevaledConstantField
        //
        /// <summary>
        /// try to bind to a constant field.
        /// returns true on success.
        /// </summary>
        /// <param name="field"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool BindUnevaledConstantField(MEMBVARSYM field)
        {
            DebugUtil.Assert(field.IsUnevaled);
            DebugUtil.Assert(this.methodSym == null);

            // Save and restore state.
            FncBindState state = new FncBindState(this);

            // the below might fail, in which case we will bind to a non-constant
            // expression, and eventually return such, which will cause us to
            // give an approporiate error...
            try
            {
                return Compiler.ClsDeclRec.EvaluateFieldConstant(this.originalFieldSym, field);
            }
            finally
            {
                state.Restore();
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindUnop
        //
        /// <summary>
        /// Bind a unary expression
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindUnop(
            UNOPNODE treeNode,
            BindFlagsEnum bindFlags)	// = BindFlagsEnum.RVALUEREQUIRED
        {
            DebugUtil.Assert(treeNode.Kind == NODEKIND.UNOP && treeNode.Operand != null);
            OPERATOR opID = treeNode.Operator;

            switch (opID)
            {
                case OPERATOR.TYPEOF:
                    return BindTypeOf(treeNode);

                case OPERATOR.SIZEOF:
                    return BindSizeOf(treeNode);

                case OPERATOR.DEFAULT:
                    return BindDefault(treeNode);

                case OPERATOR.CHECKED:
                case OPERATOR.UNCHECKED:
                    return BindCheckedExpr(treeNode, bindFlags);

                default:
                    break;
            }

            // Bind the child node.
            EXPR operandExpr = BindExpr(
                treeNode.Operand,
                BindFlagsEnum.RValueRequired | (bindFlags & BindFlagsEnum.MaybeConfusedNegativeCast));

            DebugUtil.Assert(operandExpr != null);
            if (!operandExpr.IsOK)
            {
                return NewError(treeNode, null);
            }

            switch (opID)
            {
                case OPERATOR.PAREN:
                    // Parenthesises expression is ignored.
                    return operandExpr;

                case OPERATOR.UPLUS:
                case OPERATOR.NEG:
                case OPERATOR.BITNOT:
                case OPERATOR.LOGNOT:
                case OPERATOR.POSTDEC:
                case OPERATOR.PREDEC:
                case OPERATOR.POSTINC:
                case OPERATOR.PREINC:
                    //------------------------------------------------
                    // (CS4) Runtimebinded
                    //------------------------------------------------
                    if (operandExpr.IsRuntimeBinded)
                    {
                        return BindRuntimeBindedUnaOp(
                            treeNode,
                            opID,
                            operandExpr);
                    }

                    return BindStdUnaOp(treeNode, opID, operandExpr);

                case OPERATOR.MAKEREFANY:
                    return BindMakeRefAny(treeNode, operandExpr);

                case OPERATOR.REFTYPE:
                    return BindRefType(treeNode, operandExpr);

                case OPERATOR.INDIR:
                    return BindPtrIndirection(treeNode, operandExpr);

                case OPERATOR.ADDR:
                    return BindPtrAddr(treeNode, operandExpr, bindFlags);

                default:
                    Compiler.Error(treeNode, CSCERRID.ERR_UnimplementedOp, new ErrArg(OpName(opID)));
                    return NewError(treeNode, null);
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindTypeOf
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindTypeOf(UNOPNODE treeNode)
        {
            BASENODE operandNode = treeNode.Operand;

            TYPESYM typeSym = BindType(operandNode.AsANYTYPE);
            DebugUtil.Assert(typeSym != null);
            if (typeSym.IsERRORSYM)
            {
                goto LERROR;
            }

            if (typeSym == GetVoidType())
            {
                typeSym = this.GetRequiredPredefinedType(PREDEFTYPE.SYSTEMVOID);
            }

            // CS4
            if (typeSym.Kind == SYMKIND.DYNAMICSYM)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_DynamicOnTypeof);
                return NewError(treeNode, null);
            }

            EXPRTYPEOF rval;
            rval = NewExpr(
                treeNode,
                EXPRKIND.TYPEOF,
                this.GetRequiredPredefinedType(PREDEFTYPE.TYPE)) as EXPRTYPEOF;
            rval.SourceTypeSym = typeSym;
            if (operandNode.Kind == NODEKIND.OPENTYPE)
            {
                DebugUtil.Assert(
                    typeSym.IsAGGTYPESYM &&
                    (typeSym as AGGTYPESYM).AllTypeArguments.Count > 0 &&
                    (typeSym as AGGTYPESYM).AllTypeArguments[(typeSym as AGGTYPESYM).AllTypeArguments.Count - 1].IsUNITSYM);
                rval.Flags |= EXPRFLAG.OPENTYPE;
            }

            if (!FixupTypeOfExpr(treeNode, rval))
            {
                goto LERROR;
            }

            rval.Flags |= EXPRFLAG.CANTBENULL;

            return rval;

        LERROR:
            return NewError(treeNode, this.GetRequiredPredefinedType(PREDEFTYPE.TYPE));
        }

        //--------------------------------------------------
        // FUNCBREC.FixupTypeOfExpr
        //
        /// <summary>
        /// Find the METHSYM instance
        /// which represents System.Type.GetTypeFromHandle method,
        /// and set it to FUNCBREC.methodSym. 
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="typeofExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool FixupTypeOfExpr(BASENODE treeNode, EXPRTYPEOF typeofExpr)
        {
            METHSYM meth;
            TYPESYM param;
            TypeArray paramList;

            // public static Type GetTypeFromHandle(
            //      RuntimeTypeHandle handle
            // )

            param = this.GetRequiredPredefinedType(PREDEFTYPE.TYPEHANDLE);   // System.RuntimeTypeHandle
            paramList = Compiler.MainSymbolManager.AllocParams(param);
            meth = FindPredefMeth(
                treeNode,
                PREDEFNAME.GETTYPEFROMHANDLE,   // "GetTypeFromHandle"
                this.GetRequiredPredefinedType(PREDEFTYPE.TYPE),
                paramList,
                true,
                MemLookFlagsEnum.None);

            if (meth != null)
            {
                typeofExpr.MethodSym = meth;
                return true;
            }
            return false;
        }

        //--------------------------------------------------
        // FUNCBREC.BindDefault
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindDefault(UNOPNODE treeNode)
        {
            BASENODE operandNode = treeNode.Operand;
            TYPESYM typeSym;

            typeSym = BindType(operandNode.AsANYTYPE);
            DebugUtil.Assert(typeSym != null);
            if (typeSym.IsERRORSYM)
            {
                return NewError(treeNode, typeSym);
            }
            return NewExprZero(treeNode, typeSym);
        }

        //--------------------------------------------------
        // FUNCBREC.bindIs
        //
        /// <summary>
        /// Bind the "is" operator.
        /// </summary>
        /// <param name="treeBinOpNode"></param>
        /// <param name="op1"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindIs(BINOPNODE treeBinOpNode, EXPR op1)
        {
            DebugUtil.Assert(treeBinOpNode.Operator == OPERATOR.IS);

            BASENODE node2 = treeBinOpNode.Operand2;
            TYPESYM typeSym2 = BindType(node2.AsANYTYPE);

            TYPESYM boolTypeSym = GetRequiredPredefinedType(PREDEFTYPE.BOOL);
            TYPESYM typeSym1 = op1.TypeSym;

            if (typeSym2.IsERRORSYM || !op1.IsOK)
            {
                return NewError(treeBinOpNode, boolTypeSym);
            }

            if (typeSym1.IsPTRSYM || typeSym2.IsPTRSYM)
            {
                Compiler.Error(treeBinOpNode, CSCERRID.ERR_PointerInAsOrIs);
                return NewError(treeBinOpNode, boolTypeSym);
            }

            // If the left operand is the constant value null, the answer is always false.
            if (!op1.IsNull())
            {
                // First check whether typeSym1 is always a typeSym2.
                if (FIsSameType(typeSym1, typeSym2) ||
                    FImpRefConv(typeSym1, typeSym2) ||
                    FBoxingConv(typeSym1, typeSym2) ||
                    FWrappingConv(typeSym1, typeSym2))
                {
                    // The result is op1 != null.
                    if (typeSym1.IsNUBSYM)
                    {
                        return BindNubHasValue(treeBinOpNode, op1, true);
                    }
                    if (!typeSym1.IsValueType())
                    {
                        if (!typeSym1.IsReferenceTypeInVerifier())
                        {
                            // We have to box for the verifier, even if we know it's a reference.
                            op1 = MustConvert(op1, GetRequiredPredefinedType(PREDEFTYPE.OBJECT), ConvertTypeEnum.NOUDC);
                        }
                        return NewExprBinop(
                            treeBinOpNode,
                            EXPRKIND.NE,
                            GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                            op1,
                            BindNull(null));
                    }
                    // typeSym1 can't be null. Hence the value is always true.
                    Compiler.Error(treeBinOpNode, CSCERRID.WRN_IsAlwaysTrue, new ErrArg(typeSym2));
                    return AddSideEffects(
                        treeBinOpNode,
                        NewExprConstant(treeBinOpNode, boolTypeSym, new ConstValInit(true)),
                        op1,
                        true,
                        true);
                }

                if (FUnwrappingConv(typeSym1, typeSym2))
                {
                    return BindNubHasValue(treeBinOpNode, op1, true);
                }
                // explicit reference type conversion, unboxing conversion or open types
                if (FExpRefConv(typeSym1, typeSym2) ||
                    FUnboxingConv(typeSym1, typeSym2) ||
                    (BSYMMGR.TypeContainsTyVars(typeSym1, null) || BSYMMGR.TypeContainsTyVars(typeSym2, null)))
                {
                    // here the language spec states a dynamic test is required
                    // however we check for a few more cases where we know that no conversion is possible
                    if (!(typeSym1.IsValueType() && typeSym2.IsClassType() && !typeSym2.IsPredefType(PREDEFTYPE.ENUM)))
                    {
                        if (!typeSym1.IsReferenceTypeInVerifier())
                        {
                            // We have to box for the verifier, even if we know its a reference.
                            op1 = MustConvert(
                                op1,
                                GetRequiredPredefinedType(PREDEFTYPE.OBJECT),
                                ConvertTypeEnum.NOUDC);
                        }
                        EXPR expr2 = NewExpr(
                            node2,
                            EXPRKIND.TYPEOF,
                            GetRequiredPredefinedType(PREDEFTYPE.TYPE));
                        (expr2 as EXPRTYPEOF).SourceTypeSym = typeSym2;
                        (expr2 as EXPRTYPEOF).MethodSym = null;
                        return NewExprBinop(treeBinOpNode, EXPRKIND.IS, boolTypeSym, op1, expr2);
                    }
                }
            }

            // We can't cast from op1 to typeSym2, so the answer is false.
            Compiler.Error(treeBinOpNode, CSCERRID.WRN_IsAlwaysFalse, new ErrArg(typeSym2));
            return AddSideEffects(
                treeBinOpNode,
                NewExprConstant(treeBinOpNode, boolTypeSym, new ConstValInit(false)),
                op1,
                true,
                true);
        }

        //--------------------------------------------------
        // FUNCBREC.bindAs
        //
        /// <summary>
        /// Bind "as" operator.
        /// </summary>
        /// <param name="treeBinOpNode"></param>
        /// <param name="op1"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindAs(BINOPNODE treeBinOpNode, EXPR op1)
        {
            DebugUtil.Assert(treeBinOpNode.Operator == OPERATOR.AS);

            BASENODE node2 = treeBinOpNode.Operand2;
            TYPESYM typeSym2 = BindType(node2.AsANYTYPE);

            TYPESYM typeSym1 = op1.TypeSym;

            if (typeSym2.IsERRORSYM || !op1.IsOK)
            {
                return NewError(treeBinOpNode, typeSym2);
            }

            if (typeSym1.IsPTRSYM || typeSym2.IsPTRSYM)
            {
                Compiler.Error(treeBinOpNode, CSCERRID.ERR_PointerInAsOrIs);
                return NewError(treeBinOpNode, typeSym2);
            }

            if (!typeSym2.IsReferenceType() && !typeSym2.IsNUBSYM)
            {
                if (typeSym2.IsTYVARSYM)
                {
                    Compiler.Error(treeBinOpNode, CSCERRID.ERR_AsWithTypeVar, new ErrArg(typeSym2));
                }
                else
                {
                    Compiler.Error(treeBinOpNode, CSCERRID.ERR_AsMustHaveReferenceType, new ErrArg(typeSym2));
                }
                return NewError(treeBinOpNode, typeSym2);
            }

            if (FIsSameType(typeSym1, typeSym2) ||
                FImpRefConv(typeSym1, typeSym2) ||
                FBoxingConv(typeSym1, typeSym2) ||
                FWrappingConv(typeSym1, typeSym2))
            {
                if (op1.IsNull())
                {
                    Compiler.Error(treeBinOpNode, CSCERRID.WRN_AlwaysNull, new ErrArg(typeSym2));
                    return NewExprZero(treeBinOpNode, typeSym2);
                }

                return MustConvertCore(op1, typeSym2, treeBinOpNode, ConvertTypeEnum.NOUDC);
            }

            if (FExpRefConv(typeSym1, typeSym2) ||
                FUnboxingConv(typeSym1, typeSym2) ||
                BSYMMGR.TypeContainsTyVars(typeSym1, null) ||
                BSYMMGR.TypeContainsTyVars(typeSym2, null))
            {
                if (op1.IsNull())
                {
                    return NewExprZero(treeBinOpNode, typeSym2);
                }

                // check for case we know is always false
                if (op1.IsNull() ||
                    !CanCast(op1, typeSym2, ConvertTypeEnum.NOUDC) &&
                    typeSym1.IsValueType() &&
                    typeSym2.IsClassType() &&
                    (!typeSym1.IsTYVARSYM || !typeSym2.IsPredefType(PREDEFTYPE.ENUM)))
                {
                    Compiler.Error(treeBinOpNode, CSCERRID.WRN_AlwaysNull, new ErrArg(typeSym2));
                    return AddSideEffects(
                        treeBinOpNode,
                        NewExprZero(treeBinOpNode, typeSym2),
                        op1,
                        true,
                        true);
                }

                if (!typeSym1.IsReferenceTypeInVerifier())
                {
                    // Need to box.
                    op1 = MustConvert(
                        op1,
                        GetRequiredPredefinedType(PREDEFTYPE.OBJECT),
                        ConvertTypeEnum.NOUDC);
                }

                EXPR expr2 = NewExpr(
                    node2,
                    EXPRKIND.TYPEOF,
                    GetRequiredPredefinedType(PREDEFTYPE.TYPE));
                (expr2 as EXPRTYPEOF).SourceTypeSym = typeSym2;
                (expr2 as EXPRTYPEOF).MethodSym = null;

                if (!typeSym2.IsTYVARSYM)
                {
                    return NewExprBinop(treeBinOpNode, EXPRKIND.AS, typeSym2, op1, expr2);
                }
                else
                {
                    EXPR resExpr = NewExprBinop(
                        treeBinOpNode,
                        EXPRKIND.AS,
                        GetRequiredPredefinedType(PREDEFTYPE.OBJECT),
                        op1,
                        expr2);
                    BindSimpleCast(treeBinOpNode, resExpr, typeSym2, ref resExpr, EXPRFLAG.FORCE_UNBOX);
                    return resExpr;
                }
            }

            // There is no explicit reference or unboxing conversion from op1 to typeSym2,
            // and neither is an open type, report an error.
            Compiler.Error(
                treeBinOpNode,
                CSCERRID.ERR_NoExplicitBuiltinConv,
                new ErrArg(typeSym1, ErrArgFlagsEnum.Unique),
                new ErrArg(typeSym2, ErrArgFlagsEnum.Unique));
            return AddSideEffects(treeBinOpNode, NewExprZero(treeBinOpNode, typeSym2), op1, true, true);
        }

        //--------------------------------------------------
        // FUNCBREC.BindVarDecls
        //
        /// <summary>
        /// <para>bind a list of variable declarations
        /// newLast is set if the result consists of multuiple EXPR statatments</para>
        /// <para>Bind the local variable declaration.
        /// <code>type id ["=" initializer] ["," id ["=" initializer]]";"</code>
        /// </para>
        /// </summary>
        /// <param name="declStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindVarDecls(
            DECLSTMTNODE declStmtNode,
            StatementListBuilder builder,
            bool determineImplicitTypeLater)    // CS3
        {
            // CS3
            TYPESYM typeSym = TypeBind.BindType(
                Compiler,
                declStmtNode.TypeNode,
                this.ContextForTypeBinding(),
                this.typeBindFlags | TypeBindFlagsEnum.AllowImplicitType);
            DebugUtil.Assert(typeSym != null);
            Compiler.EnsureState(typeSym, AggStateEnum.Prepared);

            Compiler.CheckForStaticClass(declStmtNode, null, typeSym, CSCERRID.ERR_VarDeclIsStaticClass);

            NODEFLAGS flags = declStmtNode.Flags;
            if ((flags & NODEFLAGS.FIXED_DECL) != 0 && !typeSym.IsPTRSYM)
            {
                Compiler.Error(declStmtNode, CSCERRID.ERR_BadFixedInitType);
            }
            else if ((flags & NODEFLAGS.CONST_DECL) != 0 && !typeSym.CanBeConst())
            {
                Compiler.Error(declStmtNode, CSCERRID.ERR_BadConstType, new ErrArg(typeSym));
                flags &= ~(NODEFLAGS.CONST_DECL);
            }

            EXPRDECL firstDeclExpr = null;

            BASENODE node = declStmtNode.VariablesNode;
            int varCount = 0;

            while (node != null)
            {
                VARDECLNODE decl;
                if (node.Kind == NODEKIND.LIST)
                {
                    decl = node.AsLIST.Operand1 as VARDECLNODE;
                    node = node.AsLIST.Operand2;
                }
                else
                {
                    decl = node as VARDECLNODE;
                    node = null;
                }

                EXPRDECL expr = BindVarDecl(
                    decl,
                    typeSym,
                    flags & (NODEFLAGS.CONST_DECL | NODEFLAGS.FIXED_DECL | NODEFLAGS.USING_DECL),
                    determineImplicitTypeLater);

                if (firstDeclExpr==null)
                {
                    firstDeclExpr = expr;
                }
                builder.Add(expr);
                ++varCount;
            }

            // (CS3) Implicit types
            if (typeSym.Kind == SYMKIND.IMPLICITTYPESYM && varCount > 1)
            {
                Compiler.Error(declStmtNode, CSCERRID.ERR_ImplicitTypeMultipleDeclarators);
            }

            if (firstDeclExpr != null)
            {
                // For debug info associate the NODEKIND.DECLSTMT with the first variable declaration
                firstDeclExpr.TreeNode = declStmtNode;
            }

            SetNodeExpr(declStmtNode, firstDeclExpr);
        }

        //--------------------------------------------------
        // FUNCBREC.BindFixedDecls
        //
        /// <summary></summary>
        /// <param name="forStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindFixedDecls(FORSTMTNODE forStmtNode, StatementListBuilder builder)
        {
            EXPRTRY tryExpr = NewExpr(forStmtNode, EXPRKIND.TRY, null) as EXPRTRY;
            EXPRGOTO oldGotoExprs = this.gotoExprs;
            tryExpr.Flags |= EXPRFLAG.ISFINALLY;
            this.finallyNestingCount++;

            CreateNewScope();
            this.currentScopeSym.ScopeFlags = SCOPEFLAGS.TRYSCOPE | SCOPEFLAGS.LAZYFINALLY;
            this.currentBlockExpr = NewExprBlock(forStmtNode);
            tryExpr.TryBlockExpr = this.currentBlockExpr;
            SCOPESYM oldScopeSym = this.innermostTryScopeSym;
            SCOPESYM currentTryScopeSym = this.innermostTryScopeSym = this.currentScopeSym;
            this.currentBlockExpr.ScopeSym = this.currentScopeSym;

            EXPRSTMT firstStmtExpr = null;
            StatementListBuilder tempBuilder = new StatementListBuilder();	// (&firstStmtExpr);

            DECLSTMTNODE declsStmtNode = forStmtNode.InitialNode as DECLSTMTNODE;
            DebugUtil.Assert((declsStmtNode.Flags & NODEFLAGS.FIXED_DECL) != 0);

            BindVarDecls(declsStmtNode, tempBuilder, false);
            firstStmtExpr = tempBuilder.GetList();

            // Walk the forStmtNode and replace any fixed strings with temporaries
            TYPESYM stringTypeSym = GetRequiredPredefinedType(PREDEFTYPE.STRING);
            int cstmtStr = 0;
            int cstmtTot = 0;

            for (EXPRSTMT stmtExpr = firstStmtExpr; stmtExpr != null; stmtExpr = stmtExpr.NextStatement)
            {
                cstmtTot++;
                if (stmtExpr.Kind != EXPRKIND.DECL || (stmtExpr as EXPRDECL).LocVarSym == null)
                {
                    continue;
                }
                EXPRDECL declExpr = stmtExpr as EXPRDECL;
                if (declExpr.InitialExpr == null ||
                    declExpr.InitialExpr.Kind != EXPRKIND.ASSG ||
                    declExpr.InitialExpr.AsBIN.Operand2 == null)
                {
                    continue;
                }
                bool hadCast = false;
                EXPR stringExpr = declExpr.InitialExpr.AsBIN.Operand2;
                if (stringExpr.Kind != EXPRKIND.ADDR &&
                    stringExpr.Kind == EXPRKIND.CAST &&
                    (stringExpr as EXPRCAST).Operand != null &&
                    (stringExpr as EXPRCAST).Operand.Kind == EXPRKIND.ADDR)
                {
                    stringExpr = (stringExpr as EXPRCAST).Operand;
                    hadCast = true;
                }
                if (stringExpr.Kind == EXPRKIND.ADDR)
                {
                    stringExpr = stringExpr.AsBIN.Operand1;
                }
                if (stringExpr.TypeSym == stringTypeSym)
                {
                    // what we have is:
                    // charptr = &stringexpr
                    // we replace this with
                    // wrapExpr = stringexpr, charptr = &wrapExpr
                    EXPRWRAP wrapExpr = NewExprWrap(
                        stringExpr, (TEMP_KIND)((int)TEMP_KIND.FIXED_STRING_0 + cstmtStr));
                    cstmtStr++;

                    wrapExpr.TypeSym = Compiler.MainSymbolManager.GetPinnedType(stringTypeSym);
                    wrapExpr.IsPinned = true;
                    wrapExpr.DoNotFree = true;
                    EXPRBINOP assignmentExpr = NewExprBinop(
                        null,
                        EXPRKIND.ASSG,
                        stringTypeSym,
                        wrapExpr,
                        stringExpr);
                    assignmentExpr.Flags |= EXPRFLAG.ASSGOP;
                    EXPRBINOP sequenceExpr = NewExprBinop(
                        null,
                        EXPRKIND.SEQUENCE,
                        null,
                        assignmentExpr,
                        declExpr.InitialExpr);
                    if (hadCast)
                    {
                        sequenceExpr.AsBIN.Operand2.AsBIN.Operand2 =
                            (declExpr.InitialExpr.AsBIN.Operand2 as EXPRCAST).Operand;
                    }
                    sequenceExpr.AsBIN.Operand2.AsBIN.Operand2.AsBIN.Operand1 = wrapExpr;
                    sequenceExpr.AsBIN.Operand2.AsBIN.Operand2.Flags |= EXPRFLAG.ASSGOP;
                    declExpr.InitialExpr = sequenceExpr;
                    declExpr.LocVarSym.LocSlotInfo.IsPinned = false;
                }
            }

            BindStatement(forStmtNode.StatementNode, tempBuilder);
            firstStmtExpr = tempBuilder.GetList();
            this.currentBlockExpr.StatementsExpr = firstStmtExpr;
            tempBuilder.Clear();

            this.currentBlockExpr = this.currentBlockExpr.OwingBlockExpr;

            CloseScope();
            this.innermostTryScopeSym = oldScopeSym;

            this.finallyNestingCount--;

            tryExpr.HandlersExpr = NewExprBlock(forStmtNode);

            // Add the code which nulls out the fixed locals...
            //tempBuilder.Init(&tryExpr.HandlersExpr.AsBLOCK.StatementExpr);
            for (EXPRSTMT stmtExpr = firstStmtExpr; stmtExpr != null; stmtExpr = stmtExpr.NextStatement)
            {
                // Only need to loop over the original declsStmtNode.
                if (--cstmtTot < 0) break;
                if (stmtExpr.Kind != EXPRKIND.DECL ||
                    (stmtExpr as EXPRDECL).LocVarSym == null ||
                    (stmtExpr as EXPRDECL).LocVarSym.TypeSym == null)
                {
                    continue;
                }
                EXPRDECL declExpr = stmtExpr as EXPRDECL;
                EXPR targetExpr = null;
                if (declExpr.LocVarSym.LocSlotInfo.IsPinned)
                {
                    targetExpr = MakeLocal(null, declExpr.LocVarSym, true);
                }
                else if (declExpr.InitialExpr != null && declExpr.InitialExpr.Kind == EXPRKIND.SEQUENCE)
                {
                    targetExpr = declExpr.InitialExpr.AsBIN.Operand1.AsBIN.Operand1 as EXPRWRAP;
                }

                if (targetExpr != null)
                {
                    EXPR valueExpr = TryConvert(
                        BindNull(null),
                        targetExpr.Kind == EXPRKIND.WRAP ? stringTypeSym : targetExpr.TypeSym,
                        0);
                    if (valueExpr != null)
                    {
                        tempBuilder.Add(MakeAssignment(targetExpr, valueExpr));
                        if (targetExpr.Kind == EXPRKIND.WRAP)
                        {
                            tempBuilder.Add(MakeStmt(
                                null,
                                NewExprWrap(targetExpr, (targetExpr as EXPRWRAP).TempKind),
                                0));
                        }
                    }
                }
            }
            (tryExpr.HandlersExpr as EXPRBLOCK).StatementsExpr = tempBuilder.GetList();
            tempBuilder.Clear();

            // see if we can eliminate the try-finally
            // this is ok if we meet all the following conditions:
            // we are not enclosed in a try-catch block
            // the body does not contain any this.gotoExprs to outside

            bool canEliminate = true;

            SCOPESYM scopeSym = this.innermostTryScopeSym;
            while (scopeSym != null)
            {
                if ((scopeSym.ScopeFlags & (SCOPEFLAGS.TRYSCOPE | SCOPEFLAGS.LAZYFINALLY)) == SCOPEFLAGS.TRYSCOPE)
                {
                    canEliminate = false;
                    break;
                }
                scopeSym = scopeSym.ParentSym as SCOPESYM;
            }

            if (canEliminate)
            {
                EXPRGOTO newGotos = this.gotoExprs;
                while (newGotos != oldGotoExprs)
                {
                    if ((newGotos.Flags & EXPRFLAG.GOTOCASE) != 0 || (newGotos.Flags & EXPRFLAG.UNREALIZEDGOTO) == 0)
                    {
                        if (newGotos.TargetScopeSym.NestingOrder < currentTryScopeSym.NestingOrder)
                        {
                            canEliminate = false;
                            break;
                        }
                    }
                    else
                    {
                        // this goto is not yet realized and we don't know where its going, so it could be going outside
                        canEliminate = false;
                        break;
                    }
                    newGotos = newGotos.PreviousExpr;
                }
            }

            if (canEliminate)
            {
                tryExpr.Flags |= EXPRFLAG.REMOVEFINALLY;
            }

            builder.Add(SetNodeStmt(forStmtNode, tryExpr));
        }

        //--------------------------------------------------
        // FUNCBREC.BindUsingDecls
        //
        /// <summary></summary>
        /// <param name="forStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindUsingDecls(FORSTMTNODE forStmtNode, StatementListBuilder builder)
        {
            CreateNewScope();
            this.currentBlockExpr = NewExprBlock(forStmtNode);
            this.currentBlockExpr.ScopeSym = this.currentScopeSym;

            if (forStmtNode.InitialNode != null)
            {
                DECLSTMTNODE declsNode = forStmtNode.InitialNode as DECLSTMTNODE;
                DebugUtil.Assert((declsNode.Flags & NODEFLAGS.USING_DECL) != 0);

                EXPRSTMT firstStmtExpr = null;
                StatementListBuilder tempBuilder = new StatementListBuilder();	// (&firstStmtExpr);
                BindVarDecls(declsNode, tempBuilder, false);
                firstStmtExpr = tempBuilder.GetList();
                //tempBuilder.Init(&this.currentExprBlock.StatementExpr);
                tempBuilder.Clear();
                BindUsingDeclsCore(forStmtNode, firstStmtExpr, tempBuilder);
                this.currentBlockExpr.StatementsExpr = tempBuilder.GetList();
            }
            else
            {
                EXPR expr = BindExpr(forStmtNode.ExpressionNode,BindFlagsEnum.RValueRequired);
                if (expr.IsOK)
                {
                    OnLockOrDisposeEnter(expr);
                    StatementListBuilder tempBuilder = new StatementListBuilder();
                    //(&this.currentExprBlock.StatementExpr);
                    BindUsingDeclsCore(forStmtNode, expr, tempBuilder);
                    this.currentBlockExpr.StatementsExpr = tempBuilder.GetList();
                    OnLockOrDisposeExit(expr);
                }
            }

            EXPRBLOCK rval = this.currentBlockExpr;
            this.currentBlockExpr = rval.OwingBlockExpr;

            CloseScope();

            builder.Add(SetNodeStmt(forStmtNode, rval));
        }

        //--------------------------------------------------
        // FUNCBREC.BindUsingDeclsCore
        //
        /// <summary></summary>
        /// <param name="forStmtNode"></param>
        /// <param name="firstExpr"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindUsingDeclsCore(
            FORSTMTNODE forStmtNode,
            EXPR firstExpr,
            StatementListBuilder builder)
        {
            EXPR wrapExpr = null;
            EXPR nextExpr = null;

            if (firstExpr.Kind == EXPRKIND.DECL)
            {
                nextExpr = firstExpr.AsSTMT.NextStatement;
                firstExpr.AsSTMT.NextStatement = null;
                builder.Add(firstExpr.AsSTMT);
            }
            else if (!CanConvert(
                firstExpr,
                GetRequiredPredefinedType(PREDEFTYPE.IDISPOSABLE),
                ConvertTypeEnum.NOUDC))
            {
                // We'll report the error later....
                wrapExpr = firstExpr;
            }
            else
            {
                wrapExpr = NewExprWrap(firstExpr, TEMP_KIND.USING);
                wrapExpr.Flags |= EXPRFLAG.WRAPASTEMP;
                (wrapExpr as EXPRWRAP).DoNotFree = true;
                (wrapExpr as EXPRWRAP).NeedEmptySlot = true;
                builder.Add(MakeStmt(
                    forStmtNode,
                    BindAssignment(forStmtNode, wrapExpr, firstExpr,false),
                    0));
            }

            EXPRTRY tryExpr = NewExpr(forStmtNode, EXPRKIND.TRY, null) as EXPRTRY;

            tryExpr.Flags |= EXPRFLAG.ISFINALLY;

            this.finallyNestingCount++;

            CreateNewScope();
            this.currentScopeSym.ScopeFlags = SCOPEFLAGS.TRYSCOPE;
            this.currentBlockExpr = NewExprBlock(forStmtNode);
            tryExpr.TryBlockExpr = this.currentBlockExpr;
            SCOPESYM oldScopeSym = this.innermostTryScopeSym;
            this.innermostTryScopeSym = this.currentScopeSym;
            this.currentBlockExpr.ScopeSym = this.currentScopeSym;

            StatementListBuilder tempBuilder = new StatementListBuilder();
            // (&this.currentBlockExpr.StatementExpr);

            if (nextExpr != null)
            {
                BindUsingDeclsCore(forStmtNode, nextExpr, tempBuilder);
            }
            else
            {
                BindStatement(forStmtNode.StatementNode, tempBuilder);
            }
            this.currentBlockExpr.StatementsExpr = tempBuilder.GetList();
            tempBuilder.Clear();

            this.currentBlockExpr = this.currentBlockExpr.OwingBlockExpr;
            CloseScope();
            this.innermostTryScopeSym = oldScopeSym;

            this.finallyNestingCount--;

            tryExpr.HandlersExpr = NewExprBlock(forStmtNode);
            CreateNewScope();
            this.currentScopeSym.ScopeFlags = SCOPEFLAGS.FINALLYSCOPE;
            (tryExpr.HandlersExpr as EXPRBLOCK).ScopeSym = this.currentScopeSym;
            this.currentScopeSym.BlockExpr = tryExpr.HandlersExpr as EXPRBLOCK;
            CloseScope();

            EXPR expr = wrapExpr != null ? wrapExpr : MakeLocal(null, (firstExpr as EXPRDECL).LocVarSym, false);

            // otherwise, cast to IDisposable to call the explicit interface
            EXPR iDisposableExpr = TryConvert(
                expr,
                GetRequiredPredefinedType(PREDEFTYPE.IDISPOSABLE),
                ConvertTypeEnum.NOUDC);
            if (iDisposableExpr == null)
            {
                // must be implicitly convertable to IDisposable.
                if (!expr.TypeSym.IsERRORSYM)
                {
                    Compiler.Error(forStmtNode, CSCERRID.ERR_NoConvToIDisp, new ErrArg(expr.TypeSym));
                }
                return;
            }

            //EXPRSTMT exitExprList = null;
            //tempBuilder.Init(&exitExprList);

            EXPRLABEL labelExpr = null;

            if (!expr.TypeSym.IsValueType() || expr.TypeSym.IsNUBSYM)
            {
                // we must check for null...
                labelExpr = NewExprLabel();

                EXPR condExpr;
                if (expr.TypeSym.IsNUBSYM)
                {
                    condExpr = BindNubHasValue(null, expr,true);
                    tempBuilder.Add(MakeGotoIf(null, condExpr, labelExpr, false,0));
                }
                else
                {
                    // Need to box type variables for the null test.
                    EXPR expr2 = expr.TypeSym.IsTYVARSYM ?
                        MustConvertCore(
                        expr,
                        GetRequiredPredefinedType(PREDEFTYPE.OBJECT),
                        forStmtNode,
                        ConvertTypeEnum.NOUDC) :
                        expr;
                    condExpr = NewExprBinop(
                        null,
                        EXPRKIND.EQ,
                        GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                        expr2,
                        BindNull(null));
                    tempBuilder.Add(MakeGotoIf(null, condExpr, labelExpr, true,0));
                }
            }

            AGGTYPESYM disposeMMethodInType = GetRequiredPredefinedType(PREDEFTYPE.IDISPOSABLE);
            METHSYM disposeM = FindPredefMeth(
                forStmtNode,
                PREDEFNAME.DISPOSE,
                disposeMMethodInType,
                BSYMMGR.EmptyTypeArray,
                true,
                MemLookFlagsEnum.None);
            if (disposeM == null)
            {
                // either getPDT or FindPredefMeth should have given the error
                DebugUtil.Assert(Compiler.ErrorCount() > 0);
                return;
            }
            DebugUtil.Assert(disposeM != null && disposeMMethodInType != null);

            EXPRCALL callDispose = BindToMethod(
                forStmtNode,
                iDisposableExpr,
                new MethWithInst(disposeM, disposeMMethodInType,null),
                null,
                MemLookFlagsEnum.None) as EXPRCALL;
            if (expr.TypeSym.IsTYVARSYM || expr.TypeSym.IsNonNullableValueType())
            {
                callDispose.Flags |= EXPRFLAG.CONSTRAINED;
            }

            tempBuilder.Add(MakeStmt(null, callDispose, EXPRFLAG.NODEBUGINFO));
            if (labelExpr != null)
            {
                tempBuilder.Add(labelExpr);
            }
            if (wrapExpr != null && wrapExpr.Kind == EXPRKIND.WRAP)
            {
                tempBuilder.Add(MakeStmt(null, NewExprWrap(wrapExpr, TEMP_KIND.USING),0));
            }

            (tryExpr.HandlersExpr as EXPRBLOCK).StatementsExpr = tempBuilder.GetList();	// exitExprList;

            builder.Add(tryExpr);
        }

        //--------------------------------------------------
        // FUNCBREC.BindVarDecl
        //
        /// <summary>
        /// Bind a single variable declaration
        /// </summary>
        /// <param name="varDeclNode"></param>
        /// <param name="typeSym"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRDECL BindVarDecl(
            VARDECLNODE varDeclNode,
            TYPESYM typeSym,
            NODEFLAGS flags,
            bool determineImplicitTypeLater)    // CS3
        {
#if DEBUG
            if (varDeclNode.NodeID == 7396)
            {
                ;
            }
#endif
            bool isConst = (flags & NODEFLAGS.CONST_DECL) != 0;
            bool isFixed = (flags & NODEFLAGS.FIXED_DECL) != 0;
            bool isUsing = (flags & NODEFLAGS.USING_DECL) != 0;

            DebugUtil.Assert(!(isConst && isFixed));
            DebugUtil.Assert(!(isConst && isUsing));
            DebugUtil.Assert(!(isUsing && isFixed));

            int cbit = 0;
            LOCVARSYM locVarSym = DeclareVar(
                varDeclNode,
                varDeclNode.NameNode.Name,
                typeSym,
                false);
            DebugUtil.Assert(locVarSym==null || locVarSym.TypeSym == typeSym);
            if (locVarSym != null)
            {
                if (isFixed)
                {
                    locVarSym.LocSlotInfo.MustBePinned = true;
                    locVarSym.IsNonWriteable = true;
                    locVarSym.IsFixed = true;
                }
                else if (isUsing)
                {
                    locVarSym.IsNonWriteable = true;
                    locVarSym.IsUsing = true;
                }

                locVarSym.DeclTreeNode = varDeclNode;
                DebugUtil.Assert(!locVarSym.LocSlotInfo.IsReferenced);
                this.unreferencedVarCount++;

                locVarSym.LocSlotInfo.SetJbitDefAssg(this.uninitedVarCount + 1);
                cbit = FlowChecker.GetCbit(Compiler, locVarSym.TypeSym);
                this.uninitedVarCount += cbit;
            }

            BindFlagsEnum bindFlags = isFixed ? BindFlagsEnum.FixedValue : (isUsing ? BindFlagsEnum.UsingValue : 0);

            // (CS3) If typeSym is IQueryable, set the flag.
            if (typeSym.Kind == SYMKIND.AGGTYPESYM &&
                ((typeSym as AGGTYPESYM).GetAggregate() == Compiler.GetOptPredefAgg(PREDEFTYPE.G_IQUERYABLE, true) ||
                (typeSym as AGGTYPESYM).GetAggregate() == Compiler.GetOptPredefAgg(PREDEFTYPE.IQUERYABLE, true)))
            {
                bindFlags |= BindFlagsEnum.AssignToIQueryable;
            }

            EXPR initExpr = BindPossibleArrayInitAssg(
                varDeclNode.ArgumentsNode as BINOPNODE,
                typeSym,
                bindFlags);
                //isFixed ? BindFlagsEnum.FixedValue: (isUsing ? BindFlagsEnum.UsingValue: 0));

            if (locVarSym == null)
            {
                return null;
            }

            // (CS3) Implicit type
            if (typeSym.IsIMPLICITTYPESYM)
            {
                typeSym = locVarSym.TypeSym;
            }

            // (CS3) implicit type,  error processing
            if (typeSym.IsIMPLICITTYPESYM && initExpr == null)
            {
                if (!determineImplicitTypeLater)
                {
                    locVarSym.TypeSym = Compiler.MainSymbolManager.GetErrorType(null, "var", null);
                    Compiler.Error(varDeclNode, CSCERRID.ERR_ImplicitTypeNotInitialized);
                    return null;
                }
            }

            if (isFixed || isUsing)
            {
                locVarSym.LocSlotInfo.HasInit = true;
                if (initExpr == null)
                {
                    Compiler.Error(varDeclNode, CSCERRID.ERR_FixedMustInit);
                }
            }
            else if (isConst && initExpr != null)
            {
                if (initExpr.Kind == EXPRKIND.ASSG)
                {
                    initExpr = initExpr.AsBIN.Operand2;
                }
                if (initExpr.Kind == EXPRKIND.CONSTANT)
                {
                    locVarSym.IsConst = true;
                    locVarSym.ConstVal.Set((initExpr as EXPRCONSTANT).ConstVal);
                    initExpr = null;
                }
                else
                {
                    if (initExpr.Kind != EXPRKIND.ERROR)
                    {
                        BASENODE err = varDeclNode.ArgumentsNode;
                        if (err != null && err.Kind == NODEKIND.BINOP)
                        {
                            DebugUtil.Assert(err.Operator == OPERATOR.ASSIGN);
                            err = (err as BINOPNODE).Operand2;
                        }
                        //EDMAURER Give a better error message in the following case:
                        //  const object x = "some_string"
                        //The error here is that an implicit cast cannot be performed. All ref types
                        //except strings must be initialized with null.
                        if (locVarSym.TypeSym.IsReferenceType())
                        {
                            Compiler.Error(err, CSCERRID.ERR_NotNullConstRefField,
                                new ErrArg(locVarSym), new ErrArg(locVarSym.TypeSym));
                        }
                        else
                        {
                            Compiler.Error(err, CSCERRID.ERR_NotConstantExpression, new ErrArg(locVarSym));
                        }
                    }
                    locVarSym.LocSlotInfo.HasInit = true;
                }
            }
            else if (
                initExpr != null &&
                this.innermostSwitchScopeSym == null &&
                !this.areForwardGotos)
            {
                locVarSym.LocSlotInfo.HasInit = true;
            }

            // If we don't need the bits after all, "deallocate" them.
            if (!locVarSym.LocSlotInfo.IsReferenced &&
                (locVarSym.LocSlotInfo.HasInit || locVarSym.IsConst))
            {
                if (locVarSym.LocSlotInfo.JbitDefAssg() == this.uninitedVarCount - cbit + 1)
                {
                    uninitedVarCount -= cbit;
                }
                locVarSym.LocSlotInfo.SetJbitDefAssg(0);
            }

            EXPRDECL rval = NewExpr(varDeclNode, EXPRKIND.DECL, this.GetVoidType()) as EXPRDECL;

            rval.LocVarSym = locVarSym;
            rval.InitialExpr = initExpr;

            SetNodeExpr(varDeclNode, rval);
            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.ReportTypeArgsNotAllowedError
        //
        /// <summary></summary>
        /// <param name="node"></param>
        /// <param name="arity"></param>
        /// <param name="argName"></param>
        /// <param name="argKind"></param>
        //--------------------------------------------------
        internal void ReportTypeArgsNotAllowedError(
            BASENODE node,
            int arity,
            ErrArgRef argName,
            ErrArgRef argKind)
        {
            // See if this might be because of the generic ambiguity issue: F(a, b, c<d, e>(f), g)
            if (arity <= 1 || node == null || node.ParentNode == null)
            {
                goto LNormal;
            }

            BASENODE prevNode = node;
            BASENODE tempNode = prevNode.ParentNode;

            if (tempNode.Kind == NODEKIND.DOT)
            {
                if (tempNode.AsDOT.Operand2 != prevNode)
                {
                    goto LNormal;
                }
                tempNode = (prevNode = tempNode).ParentNode; // Move up.
            }
            if (tempNode == null ||
                tempNode.Kind != NODEKIND.CALL ||
                (tempNode as CALLNODE).Operand1 != prevNode)
            {
                goto LNormal;
            }

            // This name is the name part of a CALL. Make sure the entire call is itself
            // an argument to a call, new or deref.
            do
            {
                tempNode = (prevNode = tempNode).ParentNode; // Move up.
            } while (tempNode != null && tempNode.Kind == NODEKIND.LIST);

            if (tempNode == null)
            {
                goto LNormal;
            }

            switch (tempNode.Kind)
            {
                default:
                    goto LNormal;

                case NODEKIND.CALL:
                    if ((tempNode as CALLNODE).Operand2 != prevNode)
                    {
                        goto LNormal;
                    }
                    break;

                case NODEKIND.NEW:
                    if ((tempNode as NEWNODE).ArgumentsNode != prevNode)
                    {
                        goto LNormal;
                    }
                    break;

                case NODEKIND.DEREF:
                    if (tempNode.AsDEREF.Operand2 != prevNode)
                    {
                        goto LNormal;
                    }
                    break;
            }

            // Yup. Give more specific and verbose error.
            Compiler.ErrorRef(node, CSCERRID.ERR_TypeArgsNotAllowedAmbig, argName, argKind);
            return;

        LNormal:
            Compiler.ErrorRef(node, CSCERRID.ERR_TypeArgsNotAllowed, argName, argKind);
            return;
        }

        //--------------------------------------------------
        // FUNCBREC.LookupCachedName
        //
        /// <summary>
        /// <para>Lookup syms of CACHESYM
        /// and specified type in this.outerScopeSym</para>
        /// </summary>
        /// <param name="nameNode"></param>
        /// <param name="symMask"></param>
        /// <param name="typeArray"></param>
        /// <param name="cacheFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private SYM LookupCachedName(
            NAMENODE nameNode,
            SYMBMASK symMask,
            out TypeArray typeArray,
            out EXPR objectExpr,
            out NameCacheFlagsEnum cacheFlags)
        {
            TypeArray types = null;
            int nestingOrder;
            SCOPESYM current = null;
            SYM objSym = null;
            EXPR objExpr = null;
            NameCacheFlagsEnum flags = NameCacheFlagsEnum.None;

            typeArray = null;
            objectExpr = null;
            cacheFlags = NameCacheFlagsEnum.None;

            if (this.OuterScopeSym == null)
            {
                return null;
            }

            SYM sym = Compiler.LocalSymbolManager.LookupLocalSym(
                nameNode.Name,
                this.OuterScopeSym,
                (symMask & SYMBMASK.LOCVARSYM) | SYMBMASK.CACHESYM);

            if (sym == null)
            {
                return null;
            }

            sym = sym.LastSameNameSym;
            while (sym != null) // 2016/02/15 hira567@hotmail.co.jp
            {
                if (sym.IsLOCVARSYM)
                {
                    // this is a param...
                    goto FOUNDVISIBLE;
                }

                SCOPESYM cacheScopeSym;
                CACHESYM cacheSym = sym as CACHESYM;
                if (cacheSym == null)
                {
                    sym = sym.PrevSameNameSym;
                    continue;
                }

                cacheScopeSym = cacheSym.ScopeSym;
                types = cacheSym.TypeArray;
                objExpr = cacheSym.ObjectExpr;
                
                flags = cacheSym.Flags;
                sym = cacheSym.EntrySym;

                // Check that the definition is visible in our scope:
                // (ie, it occurs in our parent, or in our scope)

                nestingOrder = cacheScopeSym.NestingOrder;
                DebugUtil.Assert(
                    nestingOrder > 0 ||
                    nestingOrder == 0 &&
                    sym.IsTYVARSYM &&
                    (sym as TYVARSYM).IsMethodTypeVariable);

                // Note that the ordinal of rval is at least 1
                // except for method type variables,
                // since a 0 implies the outer scope
                // and only params and type variables are found there.

                if (nestingOrder == 0)
                {
                    goto FOUNDVISIBLE;
                }

                // Note that the ordinal of rval is at least 1 now
                // so the loop will break before current is null.

                current = this.currentScopeSym;
                while (current.NestingOrder >= nestingOrder)
                {
                    if (current == cacheScopeSym)
                    {
                        goto FOUNDVISIBLE;
                    }
                    current = current.ParentSym as SCOPESYM;
                }

                //sym = cacheSym.NextSameNameSym;
                sym = cacheSym.PrevSameNameSym;
            } // while (sym != null) // 2016/02/15 hira567@hotmail.co.jp

            // no parent relation, or no visible definition:
            return null;

        FOUNDVISIBLE:
            // ok, this definition is visible and defines the meaning for the name
            // is it of the right type?

            if ((sym.Mask & symMask) != 0)
            {
                typeArray = types;
                objectExpr = objExpr;
                cacheFlags = flags;
                return sym;
            }

            ErrorBadSK(
                nameNode,
                new SymWithType(
                    sym,
                    types != null && types.Count == 1 ? (types[0] as AGGTYPESYM) : null),
                symMask,
                0);

            return Compiler.MainSymbolManager.GetErrorType(null, nameNode.Name, null);
        }

        //--------------------------------------------------
        // FUNCBREC.StoreInCache (1)
        //
        /// <summary>
        /// Store the given symbol in the local cache of symbols.
        /// Check for parent indicates whether to check that no cache entry exists
        /// which denotes a symbol bound in a parent scope,
        /// which we would be rebinding now (which is illegal)
        /// It is possible to optimize away this check
        /// if we know that no symbol was found which was visible in our scope,
        /// since visiblity would imply that it had to be bound in a parent scope.
        /// We know the absence of this visibility if a cache lookup for the symbol failed,
        /// which is what happens when this function is called from bindName(...)
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="name"></param>
        /// <param name="sym"></param>
        /// <param name="typeArray"></param>
        /// <param name="checkForParent"></param>
        //--------------------------------------------------
        private void StoreInCache(
            BASENODE treeNode,
            string name,
            SYM sym,
            TypeArray typeArray,
            bool checkForParent) // = false
        {
            DebugUtil.Assert((sym.IsLOCVARSYM || sym.IsAGGTYPESYM || sym.IsNSAIDSYM) == (typeArray == null));
            if (this.OuterScopeSym == null)
            {
                return;
            }

            CACHESYM newCacheSym = null;
            SYM firstSym = Compiler.LocalSymbolManager.LookupLocalSym(
                name,
                OuterScopeSym,
                SYMBMASK.CACHESYM | SYMBMASK.LOCVARSYM);

            if (firstSym != null)
            {
                //CSCSTRID id;
                ResNo resNo = ResNo.Invalid;

                // If we have a previous cache entry, then the current one might clash and
                // not be valid, so we need to check:
                if (firstSym.IsLOCVARSYM)
                {
                    // trying to rebind the name of a param, this is ALWAYS a nono:
                    resNo = ResNo.CSCSTR_PARENT; // id = CSCSTRID.PARENT;
                    goto DISPERROR;
                }
                CACHESYM firstCacheSym = firstSym as CACHESYM;

                firstSym = firstCacheSym.EntrySym;

                // if the cached name already denotes the same symbol, there can be no conflict...
                if (firstSym == sym)
                {
                    // Note that it is impossible at this point for sym's scope to be a
                    // child of prev's scope.  This is because if it were so then prev would
                    // be visible in this scope and would have been found on a cache lookup,
                    // since this is only called on a lookup failure, except in the case of
                    // Local decls.  However, in the case of local decls it is impossible for
                    // the decl to be already in the cache since it is being declared.

                    DebugUtil.Assert(firstCacheSym.TypeArray == typeArray);
                    DebugUtil.Assert(!checkForParent);

                    firstCacheSym.Flags = NameCacheFlagsEnum.None;
                    firstCacheSym.ScopeSym = this.currentScopeSym;
                    return;
                }

                // first check whether previous gives a meaning to the name in our
                // current scope...  this means that there exists a parent/child
                // relationship between previous' scope and the current scope...

                SCOPESYM currentScopeSym;
                if (checkForParent
#if DEBUG
 || true
#endif
)
                {
                    // Does the previous definition occur in a parent scope the thereby
                    // contribute a meaning to our scope?
                    currentScopeSym = this.currentScopeSym;
                    int prevOrdinal = firstCacheSym.ScopeSym.NestingOrder;
                    bool gotoInScope = false;

                    if (prevOrdinal == 0)
                    {
                        DebugUtil.Assert(firstSym.IsTYVARSYM && firstSym.ParentSym == this.methodSym);
                        gotoInScope = true;
                        goto LInScope;
                    }
                    DebugUtil.Assert(prevOrdinal > 0);

                    // we only need to check up to the same tre^e height, obviously a
                    // parent of our scope has to have a lower ordinal
                    while (currentScopeSym.NestingOrder >= prevOrdinal)
                    {
                        if (currentScopeSym == firstCacheSym.ScopeSym)
                        {
                            //LInScope:
                            gotoInScope = true;
                            goto LInScope;
                        }
                        currentScopeSym = currentScopeSym.ParentSym as SCOPESYM;
                    }

                LInScope:
                    if (gotoInScope)
                    {
                        // ok, the previous definition is visible in this scope, and so cannot
                        // be overriden:
                        DebugUtil.Assert(checkForParent);
                        // The failure of the above assert means sombody called this
                        // w/ checkForParent turned off w/o doing a cache lookup
                        // on this name first...
                        resNo = ResNo.CSCSTR_PARENT;    // id = CSCSTRID.PARENT;
                        goto DISPERROR;
                    }
                } // if (checkForParent

                // Does the previous definition occur in a child scope of the current one?
                currentScopeSym = firstCacheSym.ScopeSym;
                // Obviously, pCurrentScope.nestingOrder is always at least 1 since a 0
                // would imply arguments scope. So, the loop will break before current
                // becomes null...
                while (currentScopeSym.NestingOrder >= this.currentScopeSym.NestingOrder)
                {
                    if (currentScopeSym == this.currentScopeSym)
                    {
                        // ok, the current definition would override a previous one and be
                        // visible in the scope of the previous one, so in that scope
                        // the name could have two possible meanings... this is also
                        // illegal...
                        resNo = ResNo.CSCSTR_CHILD; // id = CSCSTRID.CHILD;
                        goto DISPERROR;
                    }
                    currentScopeSym = currentScopeSym.ParentSym as SCOPESYM;
                }

                // ok, the definitions would not clash, so we just need to rebind the
                // cache entry:

                // [The reason this works is that we assume that we bind the parsetree
                //  in lexical order, so that all child scopes are bound before doing
                //  any code in parent scopes that follows the child scope in question...]

                // we cannot override firstCacheSym to bind lambda expressions.
                // 2016/02/15 hirano567@hotmail.co.jp

                newCacheSym = Compiler.LocalSymbolManager.CreateLocalSym(
                    SYMKIND.CACHESYM,
                    name,
                    this.OuterScopeSym) as CACHESYM;
#if false
                newCacheSym.EntrySym = firstCacheSym.EntrySym;
                newCacheSym.TypeArray = firstCacheSym.TypeArray;
                newCacheSym.Flags = firstCacheSym.Flags;
                newCacheSym.ScopeSym = firstCacheSym.ScopeSym;
#endif
                //prevCacheSym.NextSameNameSym = firstCacheSym.NextSameNameSym;
                //firstCacheSym.NextSameNameSym = prevCacheSym;

                goto MAKENEWBINDING;

            DISPERROR:
                if (sym.IsLOCVARSYM)
                {
                    if (firstSym.IsTYVARSYM && firstSym.ParentSym == this.methodSym)
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_LocalSameNameAsTypeParam, new ErrArg(name));
                    }
                    else
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_LocalIllegallyOverrides,
                            new ErrArg(name), new ErrArgResNo(resNo));
                    }
                }
                else
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_NameIllegallyOverrides,
                        new ErrArg(sym), new ErrArg(name), new ErrArgResNo(resNo));
                }

                // For IDS_CHILD, make the binding anyway.
                if (resNo != ResNo.CSCSTR_CHILD)
                {
                    return;
                }

            }
            else // if (firstSym != null)
            {
                // A cache miss
                newCacheSym = Compiler.LocalSymbolManager.CreateLocalSym(
                    SYMKIND.CACHESYM,
                    name,
                    this.OuterScopeSym) as CACHESYM;
            } // if (firstSym != null)

        MAKENEWBINDING:
            newCacheSym.EntrySym = sym;
            newCacheSym.TypeArray = typeArray;
            newCacheSym.Flags = NameCacheFlagsEnum.None;
            newCacheSym.ScopeSym = this.currentScopeSym;
        }

        //--------------------------------------------------
        // FUNCBREC.StoreInCache (2)
        //
        /// <summary>
        /// Cache memebers of objects.
        /// </summary>
        /// <remarks>
        /// (CS3) 2016/02/22 hirano567@hotmail.co.jp
        /// </remarks>
        /// <param name="treeNode"></param>
        /// <param name="name"></param>
        /// <param name="sym"></param>
        /// <param name="typeArray"></param>
        /// <param name="objectSym"></param>
        /// <param name="checkForParent"></param>
        //--------------------------------------------------
        private void StoreInCache(
            BASENODE treeNode,
            string name,
            SYM sym,
            TypeArray typeArray,
            EXPR objectExpr,
            bool checkForParent) // = false
        {
            if (objectExpr == null)
            {
                StoreInCache(treeNode, name, sym, typeArray, checkForParent);
                return;
            }

            if (this.OuterScopeSym == null)
            {
                return;
            }

            SYM firstSym = Compiler.LocalSymbolManager.LookupLocalSym(
                name,
                OuterScopeSym,
                SYMBMASK.CACHESYM | SYMBMASK.LOCVARSYM);
#if false
            if (firstSym != null)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_LocalIllegallyOverrides,
                    new ErrArg(name), new ErrArgResNo(ResNo.CSCSTR_PARENT));
                return;
            }
#endif
            CACHESYM entryCacheSym = Compiler.LocalSymbolManager.CreateLocalSym(
                SYMKIND.CACHESYM,
                name,
                this.OuterScopeSym) as CACHESYM;

            entryCacheSym.EntrySym = sym;
            entryCacheSym.TypeArray = typeArray;
            entryCacheSym.Flags = NameCacheFlagsEnum.None;
            entryCacheSym.ScopeSym = this.currentScopeSym;
            entryCacheSym.ObjectExpr = objectExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.StoreFlagsInCache
        //
        /// <summary></summary>
        /// <param name="name"></param>
        /// <param name="flags"></param>
        //--------------------------------------------------
        private void StoreFlagsInCache(string name, NameCacheFlagsEnum flags)
        {
            if (this.OuterScopeSym == null) return;

            SYM prev = Compiler.LocalSymbolManager.LookupLocalSym(
                name, this.OuterScopeSym, SYMBMASK.CACHESYM | SYMBMASK.LOCVARSYM);

            // No can do for parameters.
            if (prev != null && prev.IsCACHESYM)
            {
                DebugUtil.Assert(
                    (prev as CACHESYM).EntrySym.IsPROPSYM ||
                    (prev as CACHESYM).EntrySym.IsLOCVARSYM ||
                    (prev as CACHESYM).EntrySym.IsMEMBVARSYM);

                (prev as CACHESYM).Flags = flags;
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindReturn
        //
        /// <summary>
        /// Bind a return statement...  Check that the value is of the correct type...
        /// </summary>
        /// <param name="exprStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindReturn(
            EXPRSTMTNODE exprStmtNode,
            StatementListBuilder builder)
        {
#if DEBUG
            if (exprStmtNode.NodeID == 5056)
            {
                ;
            }
#endif
            // First, see if inside an iterator or a finally block:
            if (this.currentAnonymousMethodInfo == null)
            {
                if (this.methodInfo.IsIterator)
                {
                    Compiler.Error(exprStmtNode, CSCERRID.ERR_ReturnInIterator);
                }
                if (this.methodInfo.FirstReturnNode == null)
                {
                    this.methodInfo.FirstReturnNode = exprStmtNode;
                }
            }
            if (this.innermostFinallyScopeSym != this.OuterScopeSym)
            {
                Compiler.Error(exprStmtNode, CSCERRID.ERR_BadFinallyLeave);
            }

            EXPR argExpr = BindExpr(exprStmtNode.ArgumentsNode, BindFlagsEnum.RValueRequired);
            TYPESYM retTypeSym = null;

            if (argExpr != null && !argExpr.IsOK)
            {
                return;
            }

            retTypeSym = (this.currentAnonymousMethodInfo != null || this.methodSym == null) ?
                null : this.methodSym.ReturnTypeSym;

            if (retTypeSym != null)
            {
                // Can't do this check if we're in an anonymous method with an unknown return type

                if (retTypeSym == this.GetVoidType())
                {
                    if (argExpr != null)
                    {
                        Compiler.Error(exprStmtNode, CSCERRID.ERR_RetNoObjectRequired, new ErrArg(this.methodSym));
                        return;
                    }
                }
                else
                {
                    if (argExpr == null)
                    {
                        Compiler.Error(exprStmtNode, CSCERRID.ERR_RetObjectRequired, new ErrArg(retTypeSym));
                        return;
                    }

                    CheckUnsafe(exprStmtNode.ArgumentsNode, retTypeSym, CSCERRID.ERR_UnsafeNeeded, null);
                    argExpr = MustConvert(argExpr, retTypeSym, 0);
                }
            }

            EXPRRETURN rval;
            rval = NewExpr(exprStmtNode, EXPRKIND.RETURN, null) as EXPRRETURN;
            rval.ObjectExpr = argExpr;

            if (this.innermostTryScopeSym != this.OuterScopeSym ||
                this.innermostCatchScopeSym != this.OuterScopeSym)
            {
                rval.CurrentScopeSym = this.currentScopeSym;
                rval.Flags |= EXPRFLAG.ASLEAVE;
                if (this.finallyNestingCount > 0)
                {
                    rval.Flags |= EXPRFLAG.ASFINALLYLEAVE;
                }
                this.methodInfo.HasReturnAsLeave = true;
            }

            if (this.currentAnonymousMethodInfo != null)
            {
                DebugUtil.Assert(retTypeSym == null);

                // We're in an anonymous method block and we don't know the return type yet, so save this for later
                //if (!this.currentAnonymousMethodInfo.pexprListRet)
                //    this.currentAnonymousMethodInfo.pexprListRet = &this.currentAnonymousMethodInfo.listReturns;
                NewList(
                    rval,
                    ref this.currentAnonymousMethodInfo.ReturnExprList,
                    ref this.currentAnonymousMethodInfo.ReturnExprListLast);
            }

            builder.Add(SetNodeStmt(exprStmtNode, rval));
        }

        //--------------------------------------------------
        // FUNCBREC.BindYield
        //
        /// <summary>
        /// <para>Bind a yield statement...  Check that the value is of the correct type...</para>
        /// <para>Return a EXPRRETURN instance with EXPRFLAG.RETURNISYIELD set.</para>
        /// </summary>
        /// <param name="exprStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindYield(EXPRSTMTNODE exprStmtNode, StatementListBuilder builder)
        {
            bool isYield = true;

            if (this.currentAnonymousMethodInfo != null)
            {
                // Can't have a yield inside an anonymous method
                Compiler.Error(exprStmtNode, CSCERRID.ERR_YieldInAnonMeth);
                isYield = false;
            }
            else if (!this.methodInfo.IsIterator)
            {
                DebugUtil.Assert(this.methodInfo.YieldTypeSym == null);

                // First, check the location and set the yieldType
                if (this.methodSym.ReturnTypeSym != null &&
                    this.methodSym.ReturnTypeSym.IsAGGTYPESYM &&
                    this.methodSym.ReturnTypeSym.GetAggregate().IsPredefinedType)
                {
                    switch (this.methodSym.ReturnTypeSym.GetAggregate().PredefinedTypeID)
                    {
                        case PREDEFTYPE.IENUMERATOR:
                        case PREDEFTYPE.IENUMERABLE:
                            // Non-generic
                            this.methodInfo.YieldTypeSym = GetPDOT();
                            break;

                        case PREDEFTYPE.G_IENUMERABLE:
                        case PREDEFTYPE.G_IENUMERATOR:
                            // The yield type is the first type-parameter of the generic return type
                            DebugUtil.Assert((this.methodSym.ReturnTypeSym as AGGTYPESYM).AllTypeArguments.Count == 1);
                            this.methodInfo.YieldTypeSym = (this.methodSym.ReturnTypeSym as AGGTYPESYM).AllTypeArguments[0];
                            break;
                    }
                }

                if (this.methodInfo.YieldTypeSym == null)
                {
                    Compiler.Error(this.methodSym.ParseTreeNode, CSCERRID.ERR_BadIteratorReturn,
                         new ErrArg(this.methodSym), new ErrArg(this.methodSym.ReturnTypeSym));
                    this.methodInfo.YieldTypeSym = GetPDOT();
                }
                DebugUtil.Assert(this.methodInfo.IsIterator);
                if (this.methodInfo.FirstReturnNode != null)
                {
                    Compiler.Error(this.methodInfo.FirstReturnNode, CSCERRID.ERR_ReturnInIterator);
                }
            }

            // Can't have a yield in a finally clause
            // Can't have a yield <expr> in any part of try statement that has a catch clause
            if (this.innermostFinallyScopeSym != this.OuterScopeSym)
            {
                Compiler.Error(exprStmtNode, CSCERRID.ERR_BadYieldInFinally);
            }
            else if (this.insideTryOfCatch && exprStmtNode.ArgumentsNode != null)
            {
                Compiler.Error(exprStmtNode, CSCERRID.ERR_BadYieldInTryOfCatch);
            }
            else if (
                this.innermostCatchScopeSym != this.OuterScopeSym &&
                exprStmtNode.ArgumentsNode != null)
            {
                Compiler.Error(exprStmtNode, CSCERRID.ERR_BadYieldInCatch);
            }
            else if (
                this.finallyNestingCount > 0 &&
                exprStmtNode.ArgumentsNode != null &&
                isYield)
            {
                this.methodInfo.HasYieldAsLeave = true;
            }

            EXPR argExpr = null;
            if (exprStmtNode.ArgumentsNode != null)
            {
                argExpr = BindExpr(exprStmtNode.ArgumentsNode,BindFlagsEnum.RValueRequired);
                if (!argExpr.IsOK)
                {
                    return;
                }
                if (isYield)
                {
                    CheckUnsafe(
                        exprStmtNode.ArgumentsNode,
                        this.methodInfo.YieldTypeSym,
                        CSCERRID.ERR_UnsafeNeeded,
                        null);
                    argExpr = MustConvert(argExpr, this.methodInfo.YieldTypeSym, 0);
                }
            }

            if (!isYield)
            {
                return;
            }

            EXPRRETURN rval;
            rval = NewExpr(exprStmtNode, EXPRKIND.RETURN, null) as EXPRRETURN;
            rval.CurrentScopeSym = this.currentScopeSym;
            rval.ObjectExpr = argExpr;
            rval.Flags |= EXPRFLAG.RETURNISYIELD;

            builder.Add(SetNodeStmt(exprStmtNode, rval));
        }

        //--------------------------------------------------
        // FUNCBREC.BindIf
        //
        /// <summary>
        //// Bind an if statement.  (morphs it into gotoifs and gotos...)
        /// </summary>
        /// <param name="ifStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindIf(IFSTMTNODE ifStmtNode, StatementListBuilder builder)
        {
            // gotoif !cond, label1
            // [ifArm]
            // goto label2  [optional]
            // label1
            // [elseArm]    [optional]
            // label2       [optional]

            EXPRLABEL label1 = NewExprLabel();

            builder.Add(MakeGotoIf(
                ifStmtNode,
                BindBooleanValue(
                    ifStmtNode.ConditionNode,
                    BindExpr(ifStmtNode.ConditionNode,BindFlagsEnum.RValueRequired)),
                label1,
                false,
                0));

            BindStatement(ifStmtNode.StatementNode, builder);

            if (ifStmtNode.ElseNode == null)
            {
                builder.Add(label1);
            }
            else
            {
                EXPRLABEL label2 = NewExprLabel();
                builder.Add(MakeGoto(null, label2,0));
                builder.Add(label1);
                BindStatement(ifStmtNode.ElseNode, builder);
                builder.Add(label2);
            }
        }

        //--------------------------------------------------
        // FUNCBREC.
        //
        /// <summary>
        //// bind a while or do loop...
        /// </summary>
        /// <param name="loopStmtNode"></param>
        /// <param name="asWhile"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindWhileOrDo(
            LOOPSTMTNODE loopStmtNode,
            bool asWhile,
            StatementListBuilder builder)
        {
            LOOPLABELS prev = this.LoopLabels;
            LOOPLABELS ll = new LOOPLABELS(this);
            // The constructor sets up the links and creates the labels...

            EXPR cond = null;

            // the result looks like:

            // goto labelCont   [optional] if a while loop
            // label2
            // [body]
            // labelCont
            // gotoif cond, label2
            // labelBreak

            if (asWhile)
            {
                cond = BindBooleanValue(
                    loopStmtNode.ExpressionNode,
                    BindExpr(loopStmtNode.ExpressionNode, BindFlagsEnum.RValueRequired));
                builder.Add(MakeGoto(loopStmtNode, ll.ContinueLabel, EXPRFLAG.NODEBUGINFO));
            }

            EXPRLABEL label2 = NewExprLabel();
            builder.Add(label2);
            BindStatement(loopStmtNode.StatementNode, builder);
            builder.Add(ll.ContinueLabel);
            if (!asWhile)
            {
                cond = BindBooleanValue(
                    loopStmtNode.ExpressionNode,
                    BindExpr(loopStmtNode.ExpressionNode, BindFlagsEnum.RValueRequired));
            }
            builder.Add(MakeGotoIf(loopStmtNode, cond, label2, true, 0));
            builder.Add(ll.BreakLabel);

            this.LoopLabels = prev;
        }

        //--------------------------------------------------
        // FUNCBREC.BindFor
        //
        /// <summary>
        /// bind a for statement... the result is usually several expr statements
        /// </summary>
        /// <param name="forStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindFor(FORSTMTNODE forStmtNode, StatementListBuilder builder)
        {
            if ((forStmtNode.Flags & NODEFLAGS.FOR_FOREACH) != 0)
            {
                BindForEach(forStmtNode, builder);
                return;
            }

            if ((forStmtNode.Flags & NODEFLAGS.FIXED_DECL) != 0)
            {
                BindFixedDecls(forStmtNode, builder);
                return;
            }

            if ((forStmtNode.Flags & NODEFLAGS.USING_DECL) != 0)
            {
                BindUsingDecls(forStmtNode, builder);
                return;
            }

            // a for statament introduces a new scope, and to get the debug info right,
            // we need to introduce a new block new in the expression list also.

            this.CreateNewScope();
            this.currentBlockExpr = NewExprBlock(forStmtNode);
            this.currentBlockExpr.ScopeSym = this.currentScopeSym;

            StatementListBuilder innerBuilder = new StatementListBuilder();	//&this.currentExprBlock.statements);

            LOOPLABELS prev = this.LoopLabels;
            LOOPLABELS loopLabel = new LOOPLABELS(this);

            // this looks like:

            // [init]
            // goto labelTest
            // label1
            // [body]
            // labelContinue
            // [inc]
            // labelTest
            // gotoif test, label1
            // labelBreak

            if (forStmtNode.InitialNode != null)
            {
                if (forStmtNode.InitialNode.Kind == NODEKIND.DECLSTMT)
                {
                    BindVarDecls(
                        forStmtNode.InitialNode as DECLSTMTNODE,
                        innerBuilder,
                        false);
                }
                else
                {
                    innerBuilder.Add(MakeStmt(
                        forStmtNode.InitialNode,
                        BindExpr(
                            forStmtNode.InitialNode,
                            BindFlagsEnum.RValueRequired | BindFlagsEnum.StatementExpressionOnly),
                        0));
                }
            }

            EXPR test = forStmtNode.ExpressionNode != null ?
                BindBooleanValue(
                    forStmtNode.ExpressionNode,
                    BindExpr(forStmtNode.ExpressionNode, BindFlagsEnum.RValueRequired)) :
                NewExprConstant(
                    forStmtNode,
                    this.GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                    new ConstValInit(true));

            EXPR incr = BindExpr(
                forStmtNode.IncrementNode,
                BindFlagsEnum.RValueRequired | BindFlagsEnum.StatementExpressionOnly);

            EXPRLABEL labelTest = NewExprLabel();

            innerBuilder.Add(MakeGoto(forStmtNode, labelTest, EXPRFLAG.NODEBUGINFO));

            EXPRLABEL label1 = NewExprLabel();
            innerBuilder.Add(label1);

            BindStatement(forStmtNode.StatementNode, innerBuilder);

            this.LoopLabels = prev;

            innerBuilder.Add(loopLabel.ContinueLabel);
            if (incr != null)
            {
                innerBuilder.Add(MakeStmt(forStmtNode.IncrementNode, incr, 0));
            }
            innerBuilder.Add(labelTest);

            if (test != null)
            {
                innerBuilder.Add(MakeGotoIf(forStmtNode.ExpressionNode, test, label1, true, 0));
            }
            else
            {
                innerBuilder.Add(MakeGoto(forStmtNode.ExpressionNode, label1, 0));
            }

            innerBuilder.Add(loopLabel.BreakLabel);

            EXPRBLOCK rval = this.currentBlockExpr;
            this.currentBlockExpr = rval.OwingBlockExpr;

            this.CloseScope();

            builder.Add(SetNodeStmt(forStmtNode, rval));

            rval.StatementsExpr = innerBuilder.GetList();
        }

        //--------------------------------------------------
        // FUNCBREC.BindBreakOrContinue
        //
        /// <summary>
        /// bind a break or continue label...
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="asBreak"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindBreakOrContinue(BASENODE treeNode, bool asBreak, StatementListBuilder builder)
        {
            EXPRGOTO gotoExpr;
            EXPRLABEL targetExpr;

            targetExpr = asBreak ? this.LoopLabels.BreakLabel : this.LoopLabels.ContinueLabel;
            if (targetExpr == null)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_NoBreakOrCont);
                return;
            }
            // both break and continue are always forward jumps...
            gotoExpr = MakeGoto(treeNode, targetExpr,0);
            gotoExpr.TargetScopeSym = targetExpr.ScopeSym;
            gotoExpr.CurrentScopeSym = this.currentScopeSym;

            gotoExpr.PreviousExpr = this.gotoExprs;
            this.gotoExprs = gotoExpr;
            builder.Add(SetNodeStmt(treeNode, gotoExpr));
        }

        //--------------------------------------------------
        // FUNCBREC.
        //
        /// <summary>
        /// bind a goto statement...
        /// </summary>
        /// <param name="exprStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindGoto(EXPRSTMTNODE exprStmtNode, StatementListBuilder builder)
        {
            EXPRGOTO gotoExpr = NewExpr(exprStmtNode, EXPRKIND.GOTO, null) as EXPRGOTO;

            if ((exprStmtNode.Flags & NODEFLAGS.GOTO_CASE) != 0)
            {
                EXPRCONSTANT keyConstExpr = null;
                if (exprStmtNode.ArgumentsNode != null)
                {
                    keyConstExpr = VerifySwitchLabel(
                        exprStmtNode.ArgumentsNode,
                        this.CurrentSwitchExpr != null ? this.CurrentSwitchExpr.ArgumentExpr.TypeSym : null,
                        true);
                }
                if (this.innermostSwitchScopeSym == null)
                {
                    Compiler.Error(gotoExpr.TreeNode, CSCERRID.ERR_InvalidGotoCase);
                    return;
                }
                if (keyConstExpr == null && exprStmtNode.ArgumentsNode != null)
                {
                    // Treat it like a break.
                    EXPRLABEL target = this.LoopLabels.BreakLabel;
                    gotoExpr.LabelExpr = target;
                    gotoExpr.TargetScopeSym = target.ScopeSym;
                }
                else
                {
                    // We don't check validity now, but during the def-use pass
                    gotoExpr.Flags |= EXPRFLAG.GOTOCASE | EXPRFLAG.UNREALIZEDGOTO;
                    gotoExpr.LabelName = GetSwitchLabelName(keyConstExpr);
                    gotoExpr.TargetScopeSym = this.innermostSwitchScopeSym;
                }
            }
            else
            {
                // We don't check validity now, but during the def-use pass
                gotoExpr.LabelName = (exprStmtNode.ArgumentsNode as NAMENODE).Name;
                gotoExpr.Flags |= EXPRFLAG.UNREALIZEDGOTO;
                this.areForwardGotos = true;
            }

            gotoExpr.CurrentScopeSym = this.currentScopeSym;
            gotoExpr.PreviousExpr = this.gotoExprs;
            this.gotoExprs = gotoExpr;

            builder.Add(SetNodeStmt(exprStmtNode, gotoExpr));
        }

        //--------------------------------------------------
        // FUNCBREC.BindLabel
        //
        /// <summary>
        /// bind a label statement...
        /// </summary>
        /// <param name="labelStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindLabel(LABELSTMTNODE labelStmtNode, StatementListBuilder builder)
        {
            string ident = (labelStmtNode.LabelNode as NAMENODE).Name;

            SYM sym = Compiler.LocalSymbolManager.LookupLocalSym(
                ident, this.currentScopeSym, SYMBMASK.LABELSYM);
            LABELSYM labelSym = (sym != null ? (sym as LABELSYM) : null);

            if (labelSym != null)
            {
                Compiler.Error(labelStmtNode, CSCERRID.ERR_DuplicateLabel,
                    new ErrArg(ident), new ErrArgRefOnly(labelSym.LabelExpr.TreeNode));
            }

            labelSym = Compiler.LocalSymbolManager.CreateLocalSym(
                SYMKIND.LABELSYM, ident, this.currentScopeSym) as LABELSYM;

            EXPRLABEL labelExpr = NewExprLabel();
            labelExpr.LabelSym = labelSym;
            labelExpr.TreeNode = labelStmtNode;
            labelSym.LabelExpr = labelExpr;

            builder.Add(SetNodeStmt(labelStmtNode, labelExpr));

            // store it in our list so that we know where to find unreferenced or
            // unreachable labels...
            //newList(labelExpr, &pUserLabelList);
            NewList(labelExpr, ref this.userLabelList, ref this.userLabelListLast);

            BindStatement(labelStmtNode.StatementNode, builder);
        }

        //--------------------------------------------------
        // FUNCBREC.BindChecked
        //
        /// <summary></summary>
        /// <param name="labelStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindChecked(LABELSTMTNODE labelStmtNode, StatementListBuilder builder)
        {
            CHECKEDCONTEXT context = new CHECKEDCONTEXT(this, (labelStmtNode.Flags & NODEFLAGS.UNCHECKED) == 0);

            BindStatement(labelStmtNode.StatementNode, builder);

            context.Restore(this);
        }

        //--------------------------------------------------
        // FUNCBREC.BindUnsafe
        //
        /// <summary></summary>
        /// <param name="labelStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindUnsafe(LABELSTMTNODE labelStmtNode, StatementListBuilder builder)
        {
            if (!Compiler.OptionManager.Unsafe)
            {
                Compiler.Error(labelStmtNode, CSCERRID.ERR_IllegalUnsafe);
            }

            if (labelStmtNode != null && this.methodInfo.UnsafeTreeNode == null)
            {
                this.methodInfo.UnsafeTreeNode = labelStmtNode;
            }

            UnsafeStatesEnum oldUnsafe = this.unsafeState;

            this.SetUnsafe(true);

            BindStatement(labelStmtNode.StatementNode, builder);

            SetUnsafeState(oldUnsafe);
        }

        //--------------------------------------------------
        // FUNCBREC.BindCheckedExpr
        //
        /// <summary>
        /// Set the checked context and bind expression.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindCheckedExpr(UNOPNODE treeNode, BindFlagsEnum bindFlags)
        {
            CHECKEDCONTEXT checkedContext = new CHECKEDCONTEXT(this, treeNode.Operator == OPERATOR.CHECKED);
            EXPR rval = BindExpr(treeNode.Operand, bindFlags);
            checkedContext.Restore(this);
            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.BindInitializers
        //
        /// <summary>
        /// bind the initializers for fields (either static or instance based...)
        /// </summary>
        /// <param name="isStatic"></param>
        /// <param name="listBuilder"></param>
        //--------------------------------------------------
        private void BindInitializers(bool isStatic, StatementListBuilder listBuilder)
        {
            DebugUtil.Assert(this.parentAggSym == this.methodSym.ClassSym);
            AGGSYM aggSym = this.parentAggSym;

            // we will need this later...
            LOCVARSYM thisPointer = this.thisPointerSym;
            DECLSYM parentDeclOld = this.parentDeclSym;

            StatementListBuilder tempBuilder = new StatementListBuilder();	//(&firstStmtExpr);
            bool allAreZero = true;

            // for all class members

            for (SYM childSym = aggSym.FirstChildSym; childSym != null; childSym = childSym.NextSym)
            {
                if (!childSym.IsMEMBVARSYM)
                {
                    continue;
                }

                MEMBVARSYM fieldSym = childSym as MEMBVARSYM;

                // Only compile initializers that match the constructor's staticness
                // but not fixed buffers or const fields (unless they're const decimal
                // which must be inited at runtime)

                if (fieldSym.IsStatic != isStatic)
                {
                    continue;
                }
                if (fieldSym.IsConst && !fieldSym.TypeSym.IsPredefType(PREDEFTYPE.DECIMAL))
                {
                    continue;
                }
                if (fieldSym.FixedAggSym != null ||
                    fieldSym.ParseTreeNode == null ||  // (CS3) for back field of auto-implemenetd props.
                    (fieldSym.ParseTreeNode.Flags & NODEFLAGS.VARDECL_ARRAY) != 0)
                {
                    continue;
                }

                EXPR expr = null;
                bool hasCOInitializer = false;

                UnsafeStatesEnum oldUnsafe = UnsafeStatesEnum.Unsafe;
                SetUnsafe(fieldSym.IsUnsafe);
                this.unsafeErrorGiven = false;
                this.parentDeclSym = fieldSym.ContainingDeclaration();

                CheckUnsafe(
                    fieldSym.GetParseTree(),
                    fieldSym.TypeSym,
                    CSCERRID.ERR_UnsafeNeeded,
                    null);

                // check for explicit initializer

                if (fieldSym.GetBaseExprTree() != null)
                {
                    DebugUtil.Assert(!aggSym.IsStruct || isStatic);
                    // we have an explicit field initializer
                    DebugUtil.Assert(!fieldSym.IsUnevaled);
                    BINOPNODE nodeAsg = fieldSym.GetBaseExprTree() as BINOPNODE;

                    // This gives us the lefthand side, ie the field...
                    // Need to do this inline because we may be binding to a
                    // constant decimal, which won't come out right in bindExpr

                    EXPR op1;
                    op1 = NewExpr(nodeAsg.Operand1, EXPRKIND.FIELD, fieldSym.TypeSym);
#if DEBUG
                    (op1 as EXPRFIELD).CheckedMarshalByRef = true;
#endif
                    SetNodeExpr(nodeAsg.Operand1, op1);

                    (op1 as EXPRFIELD).Offset = 0;
                    if (isStatic)
                    {
                        (op1 as EXPRFIELD).ObjectExpr = null;
                    }
                    else
                    {
                        (op1 as EXPRFIELD).ObjectExpr = BindThisImplicit(nodeAsg.Operand1);
                    }
                    (op1 as EXPRFIELD).FieldWithType.Set(fieldSym, this.parentAggSym.GetThisType());
                    op1.Flags |= EXPRFLAG.LVALUE;

                    this.thisPointerSym = null;
                    this.evaluatingFieldInitializer = true;
                    // Hide the this pointer for the duration of the right side...

                    // (CS3) Object Initializer, Collection Initializer
                    NEWNODE newNode = nodeAsg.Operand2 as NEWNODE;
                    if (newNode!=null&&
                        (newNode.HasCollectionInitializer||newNode.HasObjectInitializer))
                    {
                        this.initializerBuilder1=new StatementListBuilder();
                        hasCOInitializer = true;
                    }

                    EXPR op2 = BindPossibleArrayInit(nodeAsg.Operand2, fieldSym.TypeSym, 0);

                    this.evaluatingFieldInitializer = false;
                    this.thisPointerSym = thisPointer;

                    expr = SetNodeExpr(nodeAsg, BindAssignment(nodeAsg, op1, op2, false));

                    // optimize away default initializers
                    // be sure to check p2 from expr, and not op2 as there may be a cast

                    if (Compiler.OptionManager.Optimize &&
                        (expr.Kind == EXPRKIND.ASSG) &&
                        expr.AsBIN.Operand2.IsZero(true))
                    {
                        // go ahead and append if static...
                        // statics are only optimized away if all initializers are zero
                        if (!isStatic)
                        {
                            DebugUtil.Assert(expr.AsBIN.Operand2.Kind == EXPRKIND.CONSTANT);
                            expr = null;
                        }
                    }
                    else
                    {
                        allAreZero = false;
                    }
                }

                SetUnsafeState(oldUnsafe);
                this.parentDeclSym = parentDeclOld;

                if (expr != null)
                {
                    // if we generated an initializer,
                    // wrap it up in a statement and add it to the list
                    // Use the field node for the parse tree, for the first field in each list

                    BASENODE node = fieldSym.GetParseTree();
                    if (node != null && node.ParentNode != null)
                    {
                        if (node.ParentNode.Kind == NODEKIND.FIELD)
                        {
                            node = node.ParentNode;
                        }
                        else if (
                            node.ParentNode.Kind == NODEKIND.LIST &&
                            node == node.ParentNode.AsLIST.Operand1 &&
                            node.ParentNode.ParentNode != null &&
                            node.ParentNode.ParentNode.Kind == NODEKIND.FIELD)
                        {
                            node = node.ParentNode.ParentNode;
                        }
                    }

                    if (hasCOInitializer)
                    {
                        tempBuilder.Add(this.initializerBuilder1.GetList());
                    }
                    tempBuilder.Add(MakeStmt(node, expr, 0));
                }
            }

            // the valid names available when we are binding instance constructors
            // is different for the initializers and the constructor body.
            //
            // this can lead to problems when we have a non-static field with
            // an initializer referencing static member and an instance constructor
            // with a parameter with the same name as the static member.
            //
            // The field initializer binds the name to the static field, then when we
            // want to declare the parameter the name cache already contains
            // a conflicting entry referencing the static member.

            Compiler.LocalSymbolManager.RemoveChildSyms(this.OuterScopeSym, SYMBMASK.CACHESYM);

            // append items if they aren't all initialized to zero
            if (!allAreZero)
            {
                listBuilder.Add(tempBuilder.GetList());
            }
        }

        //--------------------------------------------------
        // FUNCBREC.CreateBaseConstructorCall
        //
        /// <summary></summary>
        /// <param name="isThisCall"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRSTMT CreateBaseConstructorCall(bool isThisCall)
        {
            // check that the FNCBREC is setup the way we expect
            DebugUtil.Assert(this.methodSym.ClassSym == this.parentAggSym);

            // the class to call the base constructor on is
            // either our base class, or our own class

            AGGTYPESYM callConstructorOnAts;
            if (isThisCall)
            {
                callConstructorOnAts = this.parentAggSym.GetThisType();
            }
            else
            {
                callConstructorOnAts = this.parentAggSym.BaseClassSym;
            }

            // Evaluate the argsExpr for our base constructor call.
            // this will do the right thing when we have no explicit
            // base constructor call: it will generate the same expr
            // as an argument list with no argsExpr
            //
            // NOTE: we remove the availability of the this pointer
            //       when evaluating the argsExpr since our base class
            //       hasn't been initialized yet

            BASENODE methodNode;
            EXPR argsExpr = null;
            if (this.treeNode.Kind == NODEKIND.CTOR)
            {
                // Create a new scope so that the names in the args don't interfere w/ the body
                CreateNewScope();
                this.currentScopeSym.ScopeFlags |= SCOPEFLAGS.ARGSCOPE;

                // check the parse tree is as expected
                DebugUtil.Assert(!(
                    (this.treeNode as CTORMETHODNODE).ThisOrBaseCallNode != null &&
                    (this.treeNode.NodeFlagsEx & (NODEFLAGS.EX_CTOR_THIS | NODEFLAGS.EX_CTOR_BASE)) == 0));
                DebugUtil.Assert(
                    (this.treeNode.NodeFlagsEx & (NODEFLAGS.EX_CTOR_THIS | NODEFLAGS.EX_CTOR_BASE))
                    != (NODEFLAGS.EX_CTOR_THIS | NODEFLAGS.EX_CTOR_BASE));
                DebugUtil.Assert(
                    (this.treeNode as CTORMETHODNODE).ThisOrBaseCallNode == null ||
                    (this.treeNode as CTORMETHODNODE).ThisOrBaseCallNode.Operand1 != null);

                LOCVARSYM thisPointer = this.thisPointerSym;
                this.thisPointerSym = null;
                if ((this.treeNode as CTORMETHODNODE).ThisOrBaseCallNode != null)
                {
                    argsExpr = BindExpr(
                        (this.treeNode as CTORMETHODNODE).ThisOrBaseCallNode.Operand2,
                        BindFlagsEnum.RValueRequired | BindFlagsEnum.Arguments);
                }
                this.thisPointerSym = thisPointer;

                CloseScope();

                methodNode = (this.treeNode as CTORMETHODNODE).ThisOrBaseCallNode;
            }
            else
            {
                // This case can happen with anonymous methods,
                // iterators, or compiler-generated default constructors!
                argsExpr = null;
                methodNode = null;
            }

            // generate the this pointer from our first param
            DebugUtil.Assert(this.thisPointerSym != null);
            EXPR thisExpr = BindThisImplicit(this.treeNode);

            // create the constructor call. Doing overload resolution and access checks.

            EXPR callExpr = CreateConstructorCall(
                this.treeNode,
                methodNode,
                callConstructorOnAts,
                thisExpr,
                argsExpr,
                isThisCall ? MemLookFlagsEnum.None : MemLookFlagsEnum.BaseCall);
            if (!callExpr.IsOK)
            {
                return null;
            }

            if (isThisCall && this.parentAggSym.IsStruct)
            {
                callExpr.Flags |= EXPRFLAG.NEWSTRUCTASSG;
            }
            else
            {
                DebugUtil.Assert(!isThisCall == ((callExpr.Flags & EXPRFLAG.BASECALL) != 0));
            }

            // check for single step recursive constructor calls

            if ((callExpr.Kind == EXPRKIND.CALL) && ((callExpr as EXPRCALL).MethodWithInst.MethSym == this.methodSym))
            {
                Compiler.ErrorRef(null, CSCERRID.ERR_RecursiveConstructorCall, new ErrArgRef(this.methodSym));
            }

            // wrap this all in a statement...

            return MakeStmt(this.treeNode, callExpr, 0);
        }

        //--------------------------------------------------
        // FUNCBREC.BindConstructor
        //
        /// <summary>
        /// compile the code for a constructor,
        /// this also deals with field inits and synthetized bodies
        /// </summary>
        /// <param name="methodInfo"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindConstructor(METHINFO methodInfo)
        {
            EXPRSTMT listExpr = null;   // EXPRSTMT * list = NULL;
            StatementListBuilder listBuilder = new StatementListBuilder();  // StmtListBldr bldr(&list);

            // determine if we are calling this class or a base class
            // Note that the parse tree may be a CTORNODE for explicit constructors
            // or its a CLASSNODE for implicit constructors

            DebugUtil.Assert(
                this.treeNode.Kind == NODEKIND.CTOR ||
                this.treeNode.Kind == NODEKIND.CLASS ||
                this.treeNode.Kind == NODEKIND.STRUCT);

            bool isThisCall;
            bool hasFieldInits = false;

            if (this.treeNode.Kind == NODEKIND.CTOR)
            {
                // parser should never generate both flags
                DebugUtil.Assert(
                    (this.treeNode.NodeFlagsEx & (NODEFLAGS.EX_CTOR_THIS | NODEFLAGS.EX_CTOR_BASE)) !=
                    (NODEFLAGS.EX_CTOR_THIS | NODEFLAGS.EX_CTOR_BASE));

                isThisCall = ((this.treeNode.NodeFlagsEx& NODEFLAGS.EX_CTOR_THIS) != 0);
            }
            else
            {
                // implicit constructors never call a this constructor
                isThisCall = false;
            }

            // static constructors always generate field initializers
            //
            // non-static constructors generate field initializers
            // if we don't explicitly call another contructor on this class

            CreateNewScope();
            if ((this.methodSym.IsStatic || !isThisCall) && !this.methodSym.IsExternal)
            {
                // bind field inits
                BindInitializers(this.methodSym.IsStatic, listBuilder);
                hasFieldInits = (listBuilder.GetList() != null);
                if (this.methodSym.IsStatic && this.methodSym.IsCompilerGeneratedCtor && !hasFieldInits)
                {
                    CloseScope();
                    return null;
                }
            }

            // declare the constructor arguments
            //
            // Note that this must come after initializers are done,
            // otherwise constructor arguments will be available to field initializers. Oops.

            DeclareMethodParameters(methodInfo);

            // for compiler generated constructors of comimport classes

            if (this.methodSym.IsExternal)
            {
                return null;
            }

            // Error tolerance.
            if (this.treeNode.Kind == NODEKIND.CTOR && (this.treeNode as CTORMETHODNODE).BodyNode == null)
            {
                return null;
            }

            // generate the call to the base class constructor

            if (!this.methodSym.IsStatic)
            {
                if (this.parentAggSym.IsStruct)
                {
                    if (this.treeNode.Kind == NODEKIND.CTOR)
                    {
                        CALLNODE callNode = (this.treeNode as CTORMETHODNODE).ThisOrBaseCallNode;
                        if ((this.treeNode.NodeFlagsEx & NODEFLAGS.EX_CTOR_BASE) != 0)
                        {
                            // Structs can never call a base constructor.
                            Compiler.Error(callNode, CSCERRID.ERR_StructWithBaseConstructorCall,
                                new ErrArg(this.methodSym));
                            // bind the args and toss them.
                            BindExpr(callNode.Operand2, BindFlagsEnum.RValueRequired| BindFlagsEnum.Arguments);
                        }
                        else if ((this.treeNode.NodeFlagsEx & NODEFLAGS.EX_CTOR_THIS) != 0)
                        {
                            if (callNode.Operand2 == null)
                            {
                                // No args means default value.
                                EXPRZEROINIT expr = NewExpr(
                                    callNode,
                                    EXPRKIND.ZEROINIT,
                                    this.parentAggSym.GetThisType()) as EXPRZEROINIT;
                                expr.Operand = BindThisImplicit(callNode);
                                listBuilder.Add(MakeStmt(callNode, expr,0));
                            }
                            else
                            {
                                listBuilder.Add(CreateBaseConstructorCall(true));
                            }
                        }
                    }
                }
                else if (this.parentAggSym.BaseClassSym == null && !isThisCall)
                {
                    // We're compiling constructor for object
                    DebugUtil.Assert(this.parentAggSym.IsPredefAgg(PREDEFTYPE.OBJECT));

                    // constructor call for object is attempting
                    // to call a base class constrcutor ...

                    if ((this.treeNode.Kind == NODEKIND.CTOR) &&
                        (this.treeNode.NodeFlagsEx& NODEFLAGS.EX_CTOR_BASE) != 0)
                    {
                        Compiler.ErrorRef(null, CSCERRID.ERR_ObjectCallingBaseConstructor,
                            new ErrArgRef(this.parentAggSym));
                    }
                }
                else
                {
                    // Generate constructor call for all classes
                    EXPRSTMT baseCallExpr = CreateBaseConstructorCall(isThisCall);
                    if (this.treeNode.Kind != NODEKIND.CTOR && baseCallExpr != null)
                    {
                        baseCallExpr.Flags |= EXPRFLAG.NODEBUGINFO;
                    }
                    listBuilder.Add(baseCallExpr);
                }
            }

            for (AnonMethInfo ami = this.firstAnonymousMethodInfo; ami != null; ami = ami.NextInfo)
            {
                ami.IsInCtorPreamble = true;
            }

            EXPRBLOCK preambleBlockExpr;

            if (listBuilder.GetList() != null)
            {
                preambleBlockExpr = NewExprBlock(null);
                preambleBlockExpr.StatementsExpr = listBuilder.GetList();
                listBuilder.Clear();
                //listBuilder.Init(&statementsExpr);
                preambleBlockExpr.Flags |= EXPRFLAG.CTORPREAMBLE;
                listBuilder.Add(preambleBlockExpr);
            }
            else
            {
                preambleBlockExpr = null;
            }

            EXPRBLOCK bodyBlockExpr;

            // if we got a body, bind it...
            if (this.treeNode.Kind == NODEKIND.CTOR)
            {
                SCOPESYM scope = null;
                bodyBlockExpr = BindBlock(
                    (this.treeNode as CTORMETHODNODE).BodyNode,
                    SCOPEFLAGS.NONE,
                    ref scope,
                    null);
                listBuilder.Add(bodyBlockExpr);
                DebugUtil.Assert(bodyBlockExpr.ScopeSym != null);
            }
            else
            {
                // No user-supplied body, so no debug in^fo please.
                // Unless we had some field initializers
                methodInfo.NoDebugInfo = !hasFieldInits;
                bodyBlockExpr = null;
            }

            // Correct the scopes on any anonymous methods in the base call, field initializers
            // and body.
            CorrectAnonMethScope(this.currentScopeSym);

            // if we have a default constructor for a struct with no
            // members, then we must force an empty function to be generated
            // because folks will want to call it ...
            // Same for Object's default constructor

            listExpr = listBuilder.GetList();

            if (listExpr == null &&
                this.methodSym.IsCtor &&
                !this.methodSym.IsStatic &&
                (this.parentAggSym.IsStruct ||
                (!isThisCall &&
                this.parentAggSym.BaseClassSym == null &&
                this.treeNode.Kind != NODEKIND.CTOR)))
            {
                listBuilder.Add(NewExpr(this.treeNode, EXPRKIND.RETURN, null) as EXPRRETURN);
            }

            listExpr = listBuilder.GetList();

            if (listExpr != null &&
                (listExpr.Kind != EXPRKIND.BLOCK ||
                listExpr.NextStatement != null ||
                this.firstAnonymousMethodInfo != null))
            {
                EXPRBLOCK block = NewExprBlock(null);
                block.StatementsExpr = listExpr;
                block.ScopeSym = this.currentScopeSym;
                if (preambleBlockExpr != null)
                {
                    preambleBlockExpr.OwingBlockExpr = block;
                }
                if (bodyBlockExpr != null)
                {
                    bodyBlockExpr.OwingBlockExpr = block;
                }
                listExpr = block;
            }

            CloseScope();

            return listExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindDestructor
        //
        /// <summary>
        /// compile the code for a destructor
        /// </summary>
        /// <param name="methodInfo"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindDestructor(METHINFO methodInfo)
        {
            DebugUtil.Assert(this.treeNode.Kind == NODEKIND.DTOR);
            EXPRSTMT list = null;
            StatementListBuilder listBuilder =new StatementListBuilder();
            SCOPESYM tempScopeSym = null;

            // for compiler generated constructors of comimport classes

            if (this.methodSym.IsExternal)
            {
                return null;
            }

            // Error tolerance.
            if (this.treeNode.AsDTOR.BodyNode == null)
            {
                return null;
            }

            // call base class destructor if we have one

            SYM baseDtorSym = null;
            AGGTYPESYM baseDtorAts = this.parentAggSym.BaseClassSym;

            if (baseDtorAts != null)
            {
                // find a destructor in a base class,
                // ignoring everything which doesn't look like a destructor

                while (true)
                {
                    baseDtorSym = Compiler.ClsDeclRec.FindNextName(this.methodSym.Name, ref baseDtorAts, baseDtorSym);
                    if (baseDtorSym == null)
                    {
                        break;
                    }
                    METHSYM meth = baseDtorSym as METHSYM;
                    if (meth == null)
                    {
                        continue;
                    }

                    if (meth.Access != ACCESS.PROTECTED && meth.Access != ACCESS.INTERNALPROTECTED)
                    {
                        continue;
                    }
                    if (meth.ParameterTypes.Count != 0)
                    {
                        continue;
                    }
                    if (meth.ReturnTypeSym != GetVoidType())
                    {
                        continue;
                    }
                    break;
                }
            }

            if (baseDtorSym != null)
            {
                EXPRTRY tryExpr = NewExpr(null, EXPRKIND.TRY, null) as EXPRTRY;

                tryExpr.Flags |= EXPRFLAG.ISFINALLY;

                this.finallyNestingCount++;

                EXPR bodyExpr = BindBlock(
                    this.treeNode.AsDTOR.BodyNode,
                    SCOPEFLAGS.TRYSCOPE,
                    ref tempScopeSym,
                    null);

                if (bodyExpr != null)
                {
                    DebugUtil.Assert((bodyExpr as EXPRBLOCK).ScopeSym != null);
                    CorrectAnonMethScope((bodyExpr as EXPRBLOCK).ScopeSym);
                }

                tryExpr.TryBlockExpr = bodyExpr as EXPRBLOCK;

                this.finallyNestingCount--;

                // generate the this pointer from our first param

                if (this.thisPointerSym != null)
                {
                    EXPR thisExpr = BindThisImplicit(this.treeNode);

                    // create the call expression

                    EXPRCALL baseCallExpr;
                    baseCallExpr = NewExpr(this.treeNode, EXPRKIND.CALL, GetVoidType()) as EXPRCALL;
                    baseCallExpr.ObjectExpr = thisExpr;
                    baseCallExpr.MethodWithInst.Set(baseDtorSym as METHSYM, baseDtorAts, null);
                    baseCallExpr.ArgumentsExpr = null;
                    baseCallExpr.Flags |= EXPRFLAG.BASECALL;

                    tryExpr.HandlersExpr = NewExprBlock(null);
                    (tryExpr.HandlersExpr as EXPRBLOCK).StatementsExpr
                        = MakeStmt(this.treeNode, baseCallExpr, EXPRFLAG.LASTBRACEDEBUGINFO);
                    listBuilder.Add(tryExpr);
                }
            }
            else	// if (baseDtorSym!=null)
            {
                EXPRBLOCK bodyExpr = BindBlock(
                    this.treeNode.AsDTOR.BodyNode,
                    SCOPEFLAGS.NONE,
                    ref tempScopeSym,
                    null);
                if (bodyExpr != null)
                {
                    DebugUtil.Assert((bodyExpr as EXPRBLOCK).ScopeSym != null);
                    CorrectAnonMethScope((bodyExpr as EXPRBLOCK).ScopeSym);
                }
                listBuilder.Add(bodyExpr);
            }

            // wrap it all in a block...
            list = listBuilder.GetList();
            if (list != null && (list.Kind != EXPRKIND.BLOCK || list.NextStatement != null))
            {
                EXPRBLOCK block = NewExprBlock(null);
                block.StatementsExpr = list;
                list = block;
            }

            return list;
        }

        //--------------------------------------------------
        // FUNCBREC.BindMethOrPropBody
        //
        /// binds the body of a method or property accessor
        /// the FUNCBREC must already be set up with the this ptr and arguments
        /// declared.
        //--------------------------------------------------
        private EXPRBLOCK BindMethOrPropBody(BLOCKNODE body)
        {
            if (body == null)
            {
                // Abstract method or extreme parse error.
                return null;
            }

            SCOPESYM scopeSym = null;
            EXPRBLOCK block = BindBlock(body, SCOPEFLAGS.NONE, ref scopeSym, null);

            CorrectAnonMethScope(block.ScopeSym);

            return block;
        }

        //--------------------------------------------------
        // FUNCBREC.BindMethod
        //
        /// <summary>
        /// compile the code for a method
        /// </summary>
        /// <param name="info"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindMethod(METHINFO info)
        {
            // Add the type variables to the top scope.
            AddTyVarsToScope(this.OuterScopeSym);

            DeclareMethodParameters(info);

            return BindMethOrPropBody(this.treeNode.AsANYMETHOD.BodyNode);
        }

        //--------------------------------------------------
        // FUNCBREC.BindPropertyAccessor
        //
        /// <summary>
        /// binds a property accessor
        /// </summary>
        /// <param name="methodInfo"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPropertyAccessor(METHINFO methodInfo)
        {
            METHSYM methodSym = methodInfo.MethodSym;

            if (this.treeNode.Kind != NODEKIND.PROPERTY && this.treeNode.Kind != NODEKIND.INDEXER)
            {
                // checkUnsafe() is called on the property in defineProperty(),
                // so don't check the accessors.
                this.unsafeErrorGiven = true;
                DeclareMethodParameters(methodInfo);
                this.unsafeErrorGiven = false;

                ACCESSORNODE accNode = this.treeNode as ACCESSORNODE;
                DebugUtil.Assert(accNode != null);

                // CS3
                if (methodSym.IsAutoImplementedAccessor)
                {
                    switch (methodSym.AccessorKind)
                    {
                        case AccessorKindEnum.Get:
                            return CreateAutoImplementedGetAccessor(methodSym);

                        case AccessorKindEnum.Set:
                            return CreateAutoImplementedSetAccessor(methodSym);

                        default:
                            return NewError(methodSym.ParseTreeNode, null);
                    }
                }

                return BindMethOrPropBody(accNode.BodyNode);
            }

            // This is the case where a sealed property only implemented one accessor,
            // so the compiler generated another which should call the override.
            DebugUtil.Assert(
                methodSym.SlotSymWithType != null &&
                methodSym.IsFabricated &&
                !methodSym.IsStatic &&
                methodSym.IsOverride);

            methodInfo.NoDebugInfo = true;
            // Don't generate debug info for this method, since there is no source code.

            EXPR argsExpr = null, lastExpr = null;
            DeclareMethodParameters(methodInfo, ref argsExpr, ref lastExpr);
            EXPR expr = BindBase(null);

            MethWithInst mwi = new MethWithInst(
                methodSym.SlotSymWithType.MethSym,
                methodSym.SlotSymWithType.AggTypeSym,
                BSYMMGR.EmptyTypeArray);
            RemapToOverride(mwi, expr.TypeSym);

            if (mwi.MethSym.IsAbstract)
            {
                Compiler.ErrorRef(
                    null,
                    CSCERRID.ERR_UnimplementedAbstractMethod,
                    new ErrArgRef(methodSym.ClassSym),
                    new ErrArgRef(mwi));
                return null;
            }

            TYPESYM retTypeSym = Compiler.MainSymbolManager.SubstType(
                mwi.MethSym.ReturnTypeSym,
                mwi.AggTypeSym,
                mwi.TypeArguments);
            EXPRCALL callExpr = NewExpr(
                methodSym.ParseTreeNode,
                EXPRKIND.CALL,
                retTypeSym) as EXPRCALL;
            callExpr.MethodWithInst = mwi;
            callExpr.ArgumentsExpr = argsExpr;
            callExpr.ObjectExpr = expr;
            callExpr.Flags |= EXPRFLAG.BASECALL;

            EXPRBLOCK blockExpr = NewExprBlock(null);
            if (methodSym.ReturnTypeSym == GetVoidType())
            {
                // implicit return
                blockExpr.StatementsExpr = MakeStmt(null, callExpr,0);
                blockExpr.Flags |= EXPRFLAG.NEEDSRET;
            }
            else
            {
                // explicit return
                EXPRRETURN returnExpr;
                returnExpr = NewExpr(null, EXPRKIND.RETURN, null) as EXPRRETURN;
                returnExpr.ObjectExpr = callExpr;
                blockExpr.StatementsExpr = returnExpr;
            }

            return blockExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.bindEventAccessor
        //
        /// <summary>
        /// binds an event accessor
        /// </summary>
        /// <param name="methodInfo"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindEventAccessor(METHINFO methodInfo)
        {
            LOCVARSYM paramLocalSym;
            EVENTSYM eventSym;
            BASENODE treeNode = methodInfo.MethodSym.ParseTreeNode;
            bool wasUnreferenced = false;

            // declare single parameter called "handler".
            DebugUtil.Assert(
                methodInfo.ParameterInfoCount == 1 &&
                methodInfo.ParameterInfos[0].Name == compiler.NameManager.GetPredefinedName(PREDEFNAME.VALUE));

            paramLocalSym = DeclareParam(
                methodInfo.ParameterInfos[0].Name,
                methodInfo.MethodSym.ParameterTypes[0],
                0,	// no REF or OUT flags
                this.treeNode,
                null);

            if (methodInfo.MethodSym.IsAbstract || methodInfo.MethodSym.IsExternal)
            {
                // in interface.
                return null;
            }

            // Get the associated event.
            eventSym = methodInfo.MethodSym.EventSym;

            if (eventSym.EventImplementSym == null)
            {
                if (this.treeNode.Kind != NODEKIND.ACCESSOR)
                {
                    // This can happen in error cases.
                    DebugUtil.Assert(
                        this.treeNode.Kind == NODEKIND.PROPERTY &&
                        (this.treeNode.NodeFlagsEx & NODEFLAGS.EX_EVENT) != 0);
                    return null;
                }
                return BindMethOrPropBody((this.treeNode as ACCESSORNODE).BodyNode);
            }

            SymWithType implSwt = new SymWithType(eventSym.EventImplementSym, this.parentAggSym.GetThisType());

            // The code for this is either:
            //    eventSym = Delegate.Combine(eventSym, handler)
            //    eventSym = Delegate.Remove(eventSym, handler)
            // wheren event is the member field or property, and handler is the argument.

            EXPR opExpr1, opExpr2;   // the two arguments to Combine/Remove

            // Should not be any user-provided code for this event.
            DebugUtil.Assert(this.treeNode.Kind != NODEKIND.ACCESSOR);

            // Get current value of event.
            if (implSwt.Sym.IsMEMBVARSYM)
            {
                if (implSwt.FieldSym.IsReferenced == false)
                {
                    wasUnreferenced = true;
                }
                opExpr1 = BindToField(
                    treeNode,
                    BindThisImplicit(treeNode),
                    FieldWithType.Convert(implSwt),
                    BindFlagsEnum.RValueRequired);
            }
            else
            {
                opExpr1 = BindToProperty(
                    treeNode,
                    BindThisImplicit(treeNode),
                    PropWithType.Convert(implSwt),
                    BindFlagsEnum.RValueRequired,
                    null,
                    null);
            }

            // get "handler" parameter
            opExpr2 = MakeLocal(treeNode, paramLocalSym, false);
            paramLocalSym.LocSlotInfo.IsUsed = true;

            // Construct argument list from the two
            EXPR argsExpr = NewExprBinop(treeNode, EXPRKIND.LIST, GetVoidType(), opExpr1, opExpr2);

            // Find and bind the Delegate.Combine or Delegate.Remove call.
            EXPR callExpr = BindPredefMethToArgs(
                treeNode,
                (methodInfo.MethodSym == eventSym.AddMethodSym) ? PREDEFNAME.COMBINE : PREDEFNAME.REMOVE,
                GetRequiredPredefinedType(PREDEFTYPE.DELEGATE),
                null,
                argsExpr,
                null);

            if (!callExpr.IsOK)
            {
                return NewError(treeNode, null);
            }
            DebugUtil.Assert(callExpr.Kind == EXPRKIND.CALL);

            // Cast the result to the delegate type.
            EXPR castExpr = MustCast(callExpr, eventSym.TypeSym, 0);

            // assign results of the callExpr back to the property/field
            EXPR lvalueExpr;
            if (implSwt.Sym.IsMEMBVARSYM)
            {
                lvalueExpr = BindToField(
                    treeNode,
                    BindThisImplicit(treeNode),
                    FieldWithType.Convert(implSwt),
                    BindFlagsEnum.RValueRequired);
            }
            else
            {
                lvalueExpr = BindToProperty(
                    treeNode,
                    BindThisImplicit(treeNode),
                    PropWithType.Convert(implSwt),
                    BindFlagsEnum.RValueRequired,
                    null,
                    null);
            }

            // Wrap it all in a statement and then a block, and add implicit return.
            EXPRBLOCK blockExpr = NewExprBlock(null);
            blockExpr.StatementsExpr = MakeAssignment(treeNode, lvalueExpr, castExpr);
            blockExpr.Flags |= EXPRFLAG.NEEDSRET;

            if (wasUnreferenced)
            {
                // Any references made while binding this event accessor
                // is not considered a reference to the eventSym field.
                implSwt.FieldSym.IsReferenced = false;
            }

            return blockExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindIfaceImpl
        //
        /// <summary></summary>
        /// <param name="methodInfo"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindIfaceImpl(METHINFO methodInfo)
        {
            DebugUtil.Assert(methodInfo.ParameterInfoCount == 0);

            //static const WCHAR sz^FakeParamNameTemplate[] = L"p$%d";
            const string fakeParamNameTemplate = "p$%d";

            // Don't generate debug info for this method, since there is no source code.
            methodInfo.NoDebugInfo = true;
            // Don't generate unsafe warnings
            SetUnsafe(true);

            // declare parameters
            for (int i = 0; i < methodInfo.MethodSym.ParameterTypes.Count; ++i)
            {
                string name = CreateName(fakeParamNameTemplate, i);
                DeclareParam(
                    name,
                    methodInfo.MethodSym.ParameterTypes[i],
                    0,
                    null,
                    null);
            }

            // The code for this is call of the real implementation

            EXPR firstArgExpr = null;
            //EXPR ** pargs = &firstArgExpr;
            EXPR lastArgExpr = null;
            bool hasRefParam = false;

            for (int i = 0; i < methodInfo.MethodSym.ParameterTypes.Count; ++i)
            {
                string name = CreateName(fakeParamNameTemplate, i);

                EXPRLOCAL localExpr = NewExpr(
                    null,
                    EXPRKIND.LOCAL,
                    methodInfo.MethodSym.ParameterTypes[i]) as EXPRLOCAL;

                LOCVARSYM localSym = Compiler.LocalSymbolManager.LookupLocalSym(
                    name, this.OuterScopeSym, SYMBMASK.LOCVARSYM) as LOCVARSYM;

                if (localExpr.TypeSym.IsPARAMMODSYM)
                {
                    hasRefParam = true;
                }
                localExpr.LocVarSym = localSym;
                localExpr.Flags = EXPRFLAG.LVALUE;
                if (!localSym.LocSlotInfo.IsReferenced)
                {
                    localSym.LocSlotInfo.IsReferenced = true;
                    this.unreferencedVarCount--;
                }
                localSym.LocSlotInfo.IsUsed = true;
                NewList(localExpr, ref firstArgExpr, ref lastArgExpr);
            }

            EXPR expr = BindThisImplicit(null);
            AGGTYPESYM methodInAts = this.parentAggSym.GetThisType();
            METHSYM methodSym = methodInfo.MethodSym.AsIFACEIMPLMETHSYM().ImplMethSym;

            methodInAts = methodInAts.FindBaseType(methodSym.ClassSym);
            DebugUtil.Assert(methodInAts != null && methodInAts.GetAggregate() == methodSym.ClassSym);
            DebugUtil.Assert(methodInfo.MethodSym.ClassSym == this.parentAggSym);

            // No need to substitute.

            TYPESYM typeSym = methodInfo.MethodSym.ReturnTypeSym;

            EXPRCALL callExpr = NewExpr(null, EXPRKIND.CALL, typeSym) as EXPRCALL;
            callExpr.MethodWithInst.Set(methodSym, methodInAts, methodInfo.MethodSym.TypeVariables);
            callExpr.ObjectExpr = expr;
            callExpr.ArgumentsExpr = firstArgExpr;
            if (hasRefParam)
            {
                callExpr.Flags |= EXPRFLAG.HASREFPARAM;
            }

            // Wrap it all in a block, figure out the return statement
            EXPRBLOCK blockExpr = NewExprBlock(null);
            if (typeSym == GetVoidType())
            {
                blockExpr.StatementsExpr = MakeStmt(null, callExpr, 0);
                blockExpr.Flags |= EXPRFLAG.NEEDSRET;       // implicit return statement
            }
            else
            {
                // explicit return statement
                EXPRRETURN returnExpr;
                returnExpr = NewExpr(null, EXPRKIND.RETURN, null) as EXPRRETURN;
                returnExpr.ObjectExpr = callExpr;
                blockExpr.StatementsExpr = returnExpr;
            }

            ResetUnsafe();
            return blockExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindNew
        //
        /// <summary>
        /// bind the new keyword...
        /// </summary>
        /// <param name="treeNewNode"></param>
        /// <param name="stmtExprOnly"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindNew(NEWNODE treeNewNode, bool stmtExprOnly)
        {
            EXPR rval = null;
            EXPR argsExpr;
            AGGTYPESYM coclassTypeSym;

            TYPESYM typeSym = null;

            if (treeNewNode.IsAnonymousObjectCreation)
            {
                // (CS3) Anonymous Type
                AGGSYM anonAggSym = CreateAnonymousType(treeNewNode);
                typeSym = ConstructAnonymousType(anonAggSym, treeNewNode);
            }
            else
            {
                typeSym = BindType(treeNewNode.TypeNode);
                DebugUtil.Assert(typeSym != null);
            }

            bool checkStatementOnly = false;

            if ((treeNewNode.Flags & NODEFLAGS.NEW_STACKALLOC) != 0)
            {
                DebugUtil.Assert(treeNewNode.TypeNode.Kind == NODEKIND.POINTERTYPE);
                DebugUtil.Assert(typeSym.IsPTRSYM);

                rval = BindLocAlloc(treeNewNode, typeSym as PTRSYM);
                checkStatementOnly = true;
                goto CHECKSTMTONLY;
            }

            // (CS3) Implicity Typed Array
            if (treeNewNode.IsImplicitlyTypedArray)
            {
                DebugUtil.Assert(treeNewNode != null && treeNewNode.InitialNode != null);

                rval = BindImplicitlyTypedArrayInit(
                    treeNewNode.InitialNode.AsARRAYINIT,
                    ref typeSym);

                checkStatementOnly = true;
                goto CHECKSTMTONLY;
            }

            // arrays are done separately...
            if (typeSym.IsARRAYSYM)
            {
                rval = BindArrayNew(typeSym as ARRAYSYM, treeNewNode);
                checkStatementOnly = true;
                goto CHECKSTMTONLY;
            }

            if (typeSym.IsDelegateType() && treeNewNode.ArgumentsNode != null)
            {
                // this could be a special new which takes a func pointer:
                rval = BindDelegateNew(typeSym as AGGTYPESYM, treeNewNode);
                checkStatementOnly = true;
                goto CHECKSTMTONLY;
            }

        CHECKSTMTONLY:
            if (checkStatementOnly)
            {
                if (stmtExprOnly)
                {
                    Compiler.Error(treeNewNode, CSCERRID.ERR_IllegalStatement);
                }
                return rval;
            }

            // first the args...
            argsExpr = BindExpr(
                treeNewNode.ArgumentsNode,
                BindFlagsEnum.RValueRequired | BindFlagsEnum.Arguments);

            if (typeSym.IsERRORSYM)
            {
                goto LERROR;
            }

            if (typeSym.IsTYVARSYM)
            {
                if (!(typeSym as TYVARSYM).CanNew())
                {
                    Compiler.Error(treeNewNode, CSCERRID.ERR_NoNewTyvar, new ErrArg(typeSym));
                    goto LERROR;
                }
                if (argsExpr != null)
                {
                    Compiler.Error(treeNewNode, CSCERRID.ERR_NewTyvarWithArgs, new ErrArg(typeSym));
                }

                // The type variable has the new() constraint.
                return BindNewTyVar(treeNewNode, typeSym as TYVARSYM);
            }

            if (typeSym.IsNUBSYM)
            {
                if (argsExpr == null)
                {
                    return NewExprZero(treeNewNode, typeSym);
                }

                // Should modify for linked lists.
                if (argsExpr.Kind == EXPRKIND.LIST)
                {
                    DebugUtil.Assert(false, "BindNew");
                    int argCount = 1;
                    for (EXPR exprT = argsExpr;
                        exprT != null && exprT.Kind == EXPRKIND.LIST;
                        exprT = exprT.AsBIN.Operand2)
                    {
                        argCount++;
                    }
                    Compiler.Error(
                        treeNewNode,
                        CSCERRID.ERR_BadArgCount,
                        new ErrArg(typeSym),
                        new ErrArg(argCount));
                    return NewError(treeNewNode, typeSym);
                }

                argsExpr = MustConvert(argsExpr, (typeSym as NUBSYM).BaseTypeSym, 0);
                if (!argsExpr.IsOK)
                {
                    return NewError(treeNewNode, typeSym);
                }
                return BindNubNew(treeNewNode, argsExpr);
            }

            if (!typeSym.IsAGGTYPESYM)
            {
                goto LERROR;
            }

            // Parameterless struct constructor calls == zero init
            if (argsExpr == null &&
                typeSym.IsStructOrEnum() &&
                (!typeSym.GetAggregate().HasNoArgCtor || typeSym.IsSimpleType()))
            {
                return NewExprZero(treeNewNode, typeSym);
            }

            coclassTypeSym = typeSym as AGGTYPESYM;

            if (typeSym.GetAggregate().IsAbstract)
            {
                if (typeSym.IsInterfaceType() && typeSym.GetAggregate().ComImportCoClass != null)
                {
                    AGGSYM aggSym = typeSym.GetAggregate();
                    if (aggSym.UnderlyingTypeSym != null)
                    {
                        // The coclass has already been resolved
                        if (aggSym.UnderlyingTypeSym == aggSym.GetThisType())
                        {
                            // This means the coclass was not imported, an error was already given
                            // when we first discovered this, so don't give another one
                            goto LERROR;
                        }

                        // Check accessibility.
                        if (!Compiler.ClsDeclRec.CheckTypeAccess(aggSym.UnderlyingTypeSym, this.parentDeclSym))
                        {
                            Compiler.Error(treeNewNode.TypeNode, CSCERRID.ERR_BadAccess,
                                new ErrArg(aggSym.UnderlyingTypeSym));
                            goto LERROR;
                        }

                        // just new the coclass instead of the interface
                        coclassTypeSym = aggSym.UnderlyingTypeSym;
                    }
                    else
                    {
                        bool isInvalidSig;
                        TYPESYM tySym = Compiler.Importer.ResolveFullMetadataTypeName(
                            aggSym.GetModule(),
                            aggSym.ComImportCoClass,
                            out isInvalidSig);

                        if (tySym != null && tySym.IsAGGTYPESYM)
                        {
                            aggSym.UnderlyingTypeSym = tySym as AGGTYPESYM;

                            // Check accessibility.
                            if (!Compiler.ClsDeclRec.CheckTypeAccess(tySym, this.parentDeclSym))
                            {
                                Compiler.Error(treeNewNode.TypeNode, CSCERRID.ERR_BadAccess, new ErrArg(tySym));
                                goto LERROR;
                            }

                            // Check decprecated, constraints, etc.
                            TypeBind.CheckType(
                                Compiler,
                                treeNewNode.TypeNode,
                                tySym,
                                this.parentDeclSym,
                                this.typeBindFlags);

                            // CheckType doesn't do bogus.
                            if (Compiler.CheckBogus(tySym))
                            {
                                Compiler.ErrorRef(
                                    treeNewNode.TypeNode,
                                    CSCERRID.ERR_BogusType,
                                    new ErrArgRef(tySym));
                            }
                            coclassTypeSym = tySym as AGGTYPESYM;
                        }
                        else
                        {
                            if (isInvalidSig)
                            {
                                Compiler.Error(
                                    treeNewNode.TypeNode,
                                    CSCERRID.ERR_BadCoClassSig,
                                    new ErrArg(aggSym.ComImportCoClass),
                                    new ErrArg(aggSym));
                            }
                            else
                            {
                                Compiler.Error(
                                    treeNewNode.TypeNode,
                                    CSCERRID.ERR_MissingCoClass,
                                    new ErrArg(aggSym.ComImportCoClass),
                                    new ErrArg(aggSym));
                            }
                            // Set the coclass to this, so we don't give more errors on this same interface
                            aggSym.UnderlyingTypeSym = aggSym.GetThisType();
                            goto LERROR;
                        }
                    }
                }

                if (coclassTypeSym.GetAggregate().IsStatic)
                {
                    Compiler.Error(treeNewNode, CSCERRID.ERR_InstantiatingStaticClass, new ErrArg(typeSym));
                    goto LERROR;
                }
                if (coclassTypeSym.GetAggregate().IsAbstract)
                {
                    Compiler.Error(treeNewNode, CSCERRID.ERR_NoNewAbstract, new ErrArg(typeSym));
                    goto LERROR;
                }
            }

            // now find any of that classes constructors
            rval = CreateConstructorCall(
                treeNewNode,
                treeNewNode,
                coclassTypeSym,
                null,
                argsExpr,
                MemLookFlagsEnum.NewObj);
            if (coclassTypeSym != typeSym)
            {
                rval = MustCast(rval, typeSym, 0);
            }

            // (CS3) Object Initializer
            if (treeNewNode.HasObjectInitializer)
            {
                return BindObjectInitializer(
                    treeNewNode,
                    typeSym,
                    null,
                    rval,
                    this.initializerBuilder1);
            }
            // (CS3) Collection Initializer
            else if (treeNewNode.HasCollectionInitializer)
            {
                return BindCollectionInitializer(
                    treeNewNode,
                    (treeNewNode.InitialNode as UNOPNODE).Operand,
                    typeSym,
                    null,
                    null,
                    rval,
                    this.initializerBuilder1);
            }

            return rval;

        LERROR:
            return NewError(treeNewNode, typeSym);
        }

        //--------------------------------------------------
        // FUNCBREC.bindNewTyVar
        //
        /// <summary></summary>
        /// <param name="treeNewNode"></param>
        /// <param name="tyVarSym"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindNewTyVar(NEWNODE treeNewNode, TYVARSYM tyVarSym)
        {
            DebugUtil.Assert(tyVarSym.CanNew());

            if (tyVarSym.IsValueType())
            {
                return NewExprZero(treeNewNode, tyVarSym);
            }

            TypeArray typeArgs = Compiler.MainSymbolManager.AllocParams(tyVarSym as TYPESYM);

            EXPR expr = BindPredefMethToArgs(
                null,
                PREDEFNAME.CREATEINSTANCE,
                this.GetOptionalPredefinedType(PREDEFTYPE.ACTIVATOR),
                null,
                null,
                typeArgs);
            if (!expr.IsOK)
            {
                return NewError(treeNewNode, tyVarSym);
            }
            if (expr.TypeSym != tyVarSym)
            {
                DebugUtil.Assert(false, "Why didn't Activator.CreateInstance return the correct type?");

                expr = MustConvert(expr, tyVarSym, ConvertTypeEnum.NOUDC);
                if (!expr.IsOK)
                {
                    return NewError(treeNewNode, tyVarSym);
                }
            }

            if (tyVarSym.IsReferenceType())
            {
                return expr;
            }

            // Produce T.default == null ? expr : T.default
            EXPR testExpr = NewExprBinop(
                treeNewNode,
                EXPRKIND.EQ,
                this.GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                BindNull(null),
                MustConvert(NewExprZero(treeNewNode, tyVarSym),
                this.GetRequiredPredefinedType(PREDEFTYPE.OBJECT),
                ConvertTypeEnum.NOUDC));

            EXPR colonExpr = NewExprBinop(
                treeNewNode,
                EXPRKIND.BINOP,
                null,
                expr,
                NewExprZero(treeNewNode, tyVarSym));

            return NewExprBinop(treeNewNode, EXPRKIND.QMARK, tyVarSym, testExpr, colonExpr);
        }

        //--------------------------------------------------
        // FUNCBREC.CheckNegativeConstant
        //
        /// <summary>
        /// Check an expression for a negative constant value,
        /// and issue error/warning if so.
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="expr"></param>
        /// <param name="id"></param>
        //--------------------------------------------------
        private void CheckNegativeConstant(BASENODE tree, EXPR expr, CSCERRID id)
        {
            if (expr.Kind != EXPRKIND.CONSTANT) return;
            if (expr.TypeSym.FundamentalType() == FUNDTYPE.U8) return;
            if ((expr as EXPRCONSTANT).ConstVal.GetLong() < 0)
            {
                Compiler.Error(tree, id);
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindArrayNew
        //
        /// <summary>
        /// bind an array creation expression...
        /// </summary>
        /// <param name="arraySym"></param>
        /// <param name="treeNewNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindArrayNew(ARRAYSYM arraySym, NEWNODE treeNewNode)
        {
            EXPR argsExpr = null;
            //EXPR ** pArgs = &argsExpr;
            EXPR currentArgsExpr = argsExpr;
            EXPR tempExpr, expr;
            TYPESYM destTypeSym;
            int count = 0;

            AGGTYPESYM intTypeSym = this.GetRequiredPredefinedType(PREDEFTYPE.INT);

            BASENODE node = treeNewNode.ArgumentsNode;
            while (node != null)
            {
                BASENODE argNode;
                if (node.Kind == NODEKIND.LIST)
                {
                    argNode = node.AsLIST.Operand1.AsBASE;
                    node = node.AsLIST.Operand2;
                }
                else
                {
                    argNode = node.AsBASE;
                    node = null;
                }

                count++;
                expr = BindExpr(argNode, BindFlagsEnum.RValueRequired);
                if (expr != null && expr.IsOK)
                {
                    destTypeSym = ChooseArrayIndexType(treeNewNode, expr);
                    // use int, long, uint, or ulong?
                    if (destTypeSym == null)
                    {
                        // using int as the ty^pe will allow us to give a better error...
                        destTypeSym = intTypeSym;
                    }
                    tempExpr = MustConvert(expr, destTypeSym, 0);
                    CheckNegativeConstant(argNode, tempExpr, CSCERRID.ERR_NegativeArraySize);

                    if (destTypeSym != intTypeSym)
                    {
                        expr = NewExpr(expr.TreeNode, EXPRKIND.CAST, destTypeSym);
                        (expr as EXPRCAST).Flags |= EXPRFLAG.INDEXEXPR;
                        (expr as EXPRCAST).Operand = tempExpr;
                    }
                    else
                    {
                        expr = tempExpr;
                    }
                }
                NewList(expr, ref argsExpr, ref currentArgsExpr);
            }

            if (treeNewNode.InitialNode != null)
            {
                return BindArrayInit(
                    treeNewNode.InitialNode.AsARRAYINIT,
                    arraySym,
                    argsExpr);
            }

            if (count != arraySym.Rank)
            {
                Compiler.Error(treeNewNode, CSCERRID.ERR_BadIndexCount, new ErrArg(arraySym.Rank));
            }

            if (argsExpr != null &&
                argsExpr.IsZero(false) &&
                count == 1 &&
                argsExpr.TypeSym == intTypeSym)
            {
                // For "new foo[0]" use EXPRKIND.ARRINIT as if they did "new foo[0] { }".
                EXPRARRINIT rval1 = NewExpr(treeNewNode, EXPRKIND.ARRINIT, arraySym) as EXPRARRINIT;
                //rval1.dimSizes = &(rval1.dimSize);
                //rval1.dimSize = 0;
                rval1.DimSizes.Add(0);
                rval1.ArgumentsExpr = null;
                rval1.Flags |= EXPRFLAG.CANTBENULL;
                return rval1;
            }

            EXPR rval2 = NewExprBinop(
                treeNewNode,
                EXPRKIND.NEWARRAY,
                arraySym,
                argsExpr,
                null);
            rval2.Flags |= EXPRFLAG.CANTBENULL;

            return rval2;
        }

        //--------------------------------------------------
        // FUNCBREC.FindDelegateCtor
        //
        /// <summary></summary>
        /// <param name="aggTypeSym"></param>
        /// <param name="treeNode"></param>
        /// <param name="reportErrors"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private METHSYM FindDelegateCtor(
            AGGTYPESYM aggTypeSym,
            BASENODE treeNode,
            bool reportErrors)  // = true
        {
            METHSYM ctorMethSym = null;
            TYPESYM[] types = { null, null };
            TypeArray typeArray = null;
            DebugUtil.Assert(aggTypeSym.IsDelegateType());

            types[0] = Compiler.GetReqPredefType(PREDEFTYPE.OBJECT, true);
            types[1] = Compiler.GetReqPredefType(PREDEFTYPE.INTPTR, true);
            typeArray = Compiler.MainSymbolManager.AllocParams(types);

            ctorMethSym = FindPredefMeth(
                treeNode,
                PREDEFNAME.CTOR,
                aggTypeSym,
                typeArray,
                false,
                MemLookFlagsEnum.None);

            if (ctorMethSym == null)
            {
                types[1] = Compiler.GetReqPredefType(PREDEFTYPE.UINTPTR, true);
                typeArray = Compiler.MainSymbolManager.AllocParams(types);

                ctorMethSym = FindPredefMeth(
                    treeNode,
                    PREDEFNAME.CTOR,
                    aggTypeSym,
                    typeArray,
                    false,
                    MemLookFlagsEnum.None);

                if (ctorMethSym == null && reportErrors)
                {
                    Compiler.Error(
                        treeNode,
                        CSCERRID.ERR_BadDelegateConstructor,
                        new ErrArg(aggTypeSym.GetAggregate()));
                }
            }
            return ctorMethSym;
        }

        //--------------------------------------------------
        // FUNCBREC.BindDelegateNew
        //
        /// <summary></summary>
        /// <param name="aggTypeSym"></param>
        /// <param name="treeNewNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindDelegateNew(AGGTYPESYM aggTypeSym, NEWNODE treeNewNode)
        {
            DebugUtil.Assert(aggTypeSym.IsDelegateType());
            EXPR expr = null;

            // First check to see if it's an anonymous method
            DebugUtil.Assert(treeNewNode.ArgumentsNode!=null);

            if (treeNewNode.ArgumentsNode.Kind == NODEKIND.ANONBLOCK)
            {
                expr = BindAnonymousMethod(treeNewNode.ArgumentsNode as ANONBLOCKNODE);
                if (!expr.IsOK)
                {
                    goto LError;
                }
                return MustConvert(expr, aggTypeSym, 0);
            }
            else if (treeNewNode.ArgumentsNode.Kind == NODEKIND.LAMBDAEXPR)
            {
                expr = BindLambdaExpression(treeNewNode.ArgumentsNode as LAMBDAEXPRNODE, null);
                if (!expr.IsOK)
                {
                    goto LError;
                }
                return MustConvert(expr, aggTypeSym, 0);
            }

            // Next, find the function we're taking the address of:
            expr = BindMethodName(treeNewNode.ArgumentsNode);
            if (expr.IsOK &&
                BindGrpConversion(treeNewNode, (expr as EXPRMEMGRP), aggTypeSym, ref expr, true))
            {
                return expr;
            }

        LError:
            return NewError(treeNewNode, aggTypeSym);
        }

        //--------------------------------------------------
        // FUNCBREC.BindAnonymousMethod
        //
        // Moved to RewriteTree.cs
        //------------------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.BindAnonymousMethodInner
        //
        // Moved to RewriteTree.cs
        //------------------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.BindSwitch
        //
        /// <summary></summary>
        /// <param name="switchStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindSwitch(SWITCHSTMTNODE switchStmtNode, StatementListBuilder builder)
        {
            EXPRSWITCH switchExpr = NewExpr(switchStmtNode, EXPRKIND.SWITCH, null) as EXPRSWITCH;
            switchExpr.HashTableInfo = null;
            switchExpr.NullLabelExpr= null;

            switchExpr.ArgumentExpr = BindExpr(
                switchStmtNode.ExpressionNode,
                BindFlagsEnum.RValueRequired);

            bool isConstant = switchExpr.ArgumentExpr.Kind == EXPRKIND.CONSTANT;
            CONSTVAL constVal = new CONSTVAL();
            EXPRGOTO constantGotoExpr = null;
            BASENODE node1 = null, node2 = null;
            StatementListBuilder tmpBuilder = new StatementListBuilder();

            if (isConstant)
            {
                constVal.Set((switchExpr.ArgumentExpr as EXPRCONSTANT).ConstVal);
                constantGotoExpr = NewExpr(switchStmtNode, EXPRKIND.GOTO, null) as EXPRGOTO;

                // This is the one place that a goto may jump to a switchLabelExpr that is nested
                // deeper than the goto. When ResolveGoto attempts to determine whether
                // the goto is blocked by a finally, it will DebugUtil.Assert in this case. To avoid
                // this issue (and for efficiency) we set GOTONOTBLOCKED here.

                constantGotoExpr.Flags |= EXPRFLAG.GOTONOTBLOCKED;
            }

            TYPESYM stringTypeSym = GetRequiredPredefinedType(PREDEFTYPE.STRING);
            TYPESYM charTypeSym = GetRequiredPredefinedType(PREDEFTYPE.CHAR);

            TYPESYM typeSym = switchExpr.ArgumentExpr.TypeSym;
            Compiler.EnsureState(typeSym,AggStateEnum.Prepared);
            TYPESYM nonNubTypeSym = typeSym.StripNubs();
            Compiler.EnsureState(nonNubTypeSym,AggStateEnum.Prepared);

            //--------------------------------------------------------
            // the type of the expression is not of integers, but not string.
            //--------------------------------------------------------
            if (typeSym != stringTypeSym &&
                nonNubTypeSym.FundamentalType() > FUNDTYPE.LASTINTEGRAL)
            {
                int cconvMatch = 0;
                int cconvMatchLift = 0;
                TYPESYM dstTypeSym = null;
                TYPESYM liftDstTypeSym = null;

                if (nonNubTypeSym.IsAGGTYPESYM && nonNubTypeSym.GetAggregate().HasConversion)
                {
                    for (AGGTYPESYM currentAts = nonNubTypeSym as AGGTYPESYM;
                        currentAts != null && currentAts.GetAggregate().HasConversion;
                        currentAts = currentAts.GetBaseClass())
                    {
                        AGGSYM currentAggSym = currentAts.GetAggregate();

                        for (METHSYM currentConvMethSym = currentAggSym.FirstConversionMethSym;
                            currentConvMethSym != null;
                            currentConvMethSym = currentConvMethSym.NextConvertMethSym)
                        {
                            DebugUtil.Assert(currentConvMethSym.ParameterTypes.Count == 1);
                            DebugUtil.Assert(currentConvMethSym.ClassSym == currentAggSym);

                            if (!currentConvMethSym.IsImplicit)
                            {
                                continue;
                            }

                            // Get the substituted src and dst types.
                            TYPESYM fromTypeSym = Compiler.MainSymbolManager.SubstType(
                                currentConvMethSym.ParameterTypes[0],
                                currentAts,
                                null);
                            bool fLift = typeSym.IsNUBSYM && !fromTypeSym.IsNUBSYM;

                            TYPESYM toTypeSym = Compiler.MainSymbolManager.SubstType(
                                currentConvMethSym.ReturnTypeSym,
                                currentAts,
                                null);
                            TYPESYM nonNubToTypeSym = toTypeSym.StripNubs();

                            if ((nonNubToTypeSym.IsNumericType() &&
                                nonNubToTypeSym.FundamentalType() <= FUNDTYPE.LASTINTEGRAL) ||
                                nonNubToTypeSym == stringTypeSym ||
                                nonNubToTypeSym == charTypeSym)
                            {
                                if (fLift)
                                {
                                    cconvMatchLift++;
                                    liftDstTypeSym = toTypeSym;
                                }
                                else
                                {
                                    cconvMatch++;
                                    dstTypeSym = toTypeSym;
                                }
                            }
                        }
                    }
                }

                if (cconvMatch == 0)
                {
                    cconvMatch = cconvMatchLift;
                    dstTypeSym = liftDstTypeSym;
                }

                if (cconvMatch != 1)
                {
                    Compiler.Error(
                        switchStmtNode.ExpressionNode,
                        CSCERRID.ERR_IntegralTypeValueExpected);
                    nonNubTypeSym = typeSym = Compiler.MainSymbolManager.ErrorSym;
                }
                else
                {
                    switchExpr.ArgumentExpr = MustConvert(switchExpr.ArgumentExpr, dstTypeSym, 0);
                    typeSym = switchExpr.ArgumentExpr.TypeSym;
                    nonNubTypeSym = typeSym.StripNubs();
                    Compiler.EnsureState(nonNubTypeSym,AggStateEnum.Prepared);
                }
            }

            //--------------------------------------------------------
            // bool
            //--------------------------------------------------------
            if (nonNubTypeSym == GetRequiredPredefinedType(PREDEFTYPE.BOOL) &&
                Compiler.OptionManager.IsLangVersionECMA1)
            {
                Compiler.Error(switchStmtNode.ExpressionNode, CSCERRID.ERR_NonECMAFeature,
                    new ErrArgResNo(ResNo.CSCSTR_FeatureSwitchOnBool));
                // CSCSTRID.FeatureSwitchOnBool));
            }

            //--------------------------------------------------------
            // nullable
            //--------------------------------------------------------
            if (nonNubTypeSym != typeSym)
            {
                // Make sure we can get the HasValue and GetValueOrDefault members (for ilgen).
                EnsureNubHasValue(switchStmtNode);
                EnsureNubGetValOrDef(switchStmtNode);
            }

            //--------------------------------------------------------
            // ok, create labels for all case statements:
            //--------------------------------------------------------
            SCOPESYM prevSwitchScopeSym = this.innermostSwitchScopeSym;
            CreateNewScope();
            this.innermostSwitchScopeSym = this.currentScopeSym;
            this.currentScopeSym.ScopeFlags |= SCOPEFLAGS.SWITCHSCOPE;
            EXPRBLOCK blockExpr = NewExprBlock(null);
            blockExpr.ScopeSym = this.currentScopeSym;
            this.currentBlockExpr = blockExpr;

            LOOPLABELS prevLoopLabels = this.LoopLabels;
            LOOPLABELS loopLabels = new LOOPLABELS(this);
            this.LoopLabels.ContinueLabel = prevLoopLabels.ContinueLabel;
            switchExpr.BreakLabelExpr = this.LoopLabels.BreakLabel;

            //--------------------------------------------------------
            // count labels.
            //--------------------------------------------------------
            int count = 0;
            node1 = switchStmtNode.CasesNode;
            while (node1 != null)
            {
                CASENODE codeLab;
                if (node1.Kind == NODEKIND.LIST)
                {
                    codeLab = node1.AsLIST.Operand1 as CASENODE;
                    node1 = node1.AsLIST.Operand2;
                }
                else
                {
                    codeLab = node1 as CASENODE;
                    node1 = null;
                }

                node2 = codeLab.LabelsNode;
                while (node2 != null)
                {
                    BASENODE caseLab;
                    if (node2.Kind == NODEKIND.LIST)
                    {
                        caseLab = node2.AsLIST.Operand1.AsBASE;
                        node2 = node2.AsLIST.Operand2;
                    }
                    else
                    {
                        caseLab = node2.AsBASE;
                        node2 = null;
                    }
                    count++;
                }
            }

            //--------------------------------------------------------
            // initialize for string switch
            //--------------------------------------------------------
            if (typeSym == stringTypeSym)
            {
                if (count >= 7 &&
                    Compiler.GetOptPredefType(PREDEFTYPE.G_DICTIONARY, true) != null &&
                    !Compiler.FEncBuild())
                {
                    InitForHashtableSwitch(switchStmtNode, switchExpr);
                }
                else
                {
                    InitForNonHashtableSwitch(switchStmtNode);
                }
            }

            //--------------------------------------------------------
            // process all case sections.
            //--------------------------------------------------------
            List<EXPRSWITCHLABEL> labelArray= new List<EXPRSWITCHLABEL>();
            switchExpr.LabelArray = labelArray;
            StatementListBuilder labelsBuilder = new StatementListBuilder();	//((EXPRSTMT **)&labelList);

            SwitchPusher sp = new SwitchPusher(this, switchExpr);

            try
            {
                node1 = switchStmtNode.CasesNode;
                while (node1 != null)
                {
                    CASENODE codeLab;
                    if (node1.Kind == NODEKIND.LIST)
                    {
                        codeLab = node1.AsLIST.Operand1 as CASENODE;
                        node1 = node1.AsLIST.Operand2;
                    }
                    else
                    {
                        codeLab = node1 as CASENODE;
                        node1 = null;
                    }

                    string labelName = null;
                    EXPRSWITCHLABEL switchLabelExpr = null;

                    //------------------------------------------------
                    // process all case labels in a case section.
                    //------------------------------------------------
                    node2 = codeLab.LabelsNode;
                    while (node2 != null)
                    {
                        BASENODE caseLab;
                        if (node2.Kind == NODEKIND.LIST)
                        {
                            caseLab = node2.AsLIST.Operand1.AsBASE;
                            node2 = node2.AsLIST.Operand2;
                        }
                        else
                        {
                            caseLab = node2.AsBASE;
                            node2 = null;
                        }

                        EXPRCONSTANT keyConstExpr;
                        if (caseLab.AsCASELABEL.Operand != null)
                        {
                            keyConstExpr = VerifySwitchLabel(caseLab.AsCASELABEL.Operand, typeSym, false);
                            if (keyConstExpr == null)
                            {
                                count--;
                                continue;
                            }
                        }
                        else
                        {
                            switchExpr.Flags |= EXPRFLAG.HASDEFAULT;
                            keyConstExpr = null;
                        }

                        labelName = GetSwitchLabelName(keyConstExpr);
                        LABELSYM labelSym = Compiler.LocalSymbolManager.LookupLocalSym(
                            labelName,
                            this.currentScopeSym,
                            SYMBMASK.LABELSYM) as LABELSYM;
                        if (labelSym != null)
                        {
                            Compiler.Error(
                                caseLab.AsCASELABEL.Operand,
                                CSCERRID.ERR_DuplicateCaseLabel,
                                new ErrArg(labelName),
                                new ErrArgRefOnly(labelSym.LabelExpr.TreeNode.AsCASELABEL.Operand));
                        }
                        else
                        {
                            labelSym = Compiler.LocalSymbolManager.CreateLocalSym(
                                SYMKIND.LABELSYM,
                                labelName,
                                this.currentScopeSym) as LABELSYM;
                        }

                        switchLabelExpr = NewExpr(caseLab, EXPRKIND.SWITCHLABEL, null) as EXPRSWITCHLABEL;
                        if (keyConstExpr != null && keyConstExpr.IsNull())
                        {
                            switchExpr.NullLabelExpr = switchLabelExpr;
                        }

                        switchLabelExpr.KeyExpr = keyConstExpr;
                        if (isConstant)
                        {
                            if (keyConstExpr == null)
                            {
                                if (constantGotoExpr.LabelExpr == null)
                                {
                                    constantGotoExpr.LabelExpr = switchLabelExpr;
                                }
                            }
                            else if ((keyConstExpr as EXPRCONSTANT).IsEqual((switchExpr.ArgumentExpr as EXPRCONSTANT)))
                            {
                                constantGotoExpr.LabelExpr = switchLabelExpr;
                            }
                            NewList(switchLabelExpr, ref this.userLabelList, ref this.userLabelListLast);
                        }

                        switchLabelExpr.LabelSym = labelSym;
                        labelSym.LabelExpr = switchLabelExpr;

                        switchExpr.LabelArray.Add(switchLabelExpr);
                        labelsBuilder.Add(SetNodeStmt(caseLab, switchLabelExpr));
                    } // while (node2 != null)

                    // Bind the statements even if there isn't a valid label.
                    EXPRSTMT tmpStmtExpr = null;
                    tmpBuilder.Clear();

                    STATEMENTNODE stmtNode = codeLab.StatementsNode;

                    while (stmtNode != null)
                    {
                        BindStatement(stmtNode, tmpBuilder);
                        stmtNode = stmtNode.NextStatementNode;
                    }

                    if (switchLabelExpr != null)
                    {
                        switchLabelExpr.StatementsExpr = tmpBuilder.GetList();
                    }
                    else
                    {
                        tmpStmtExpr = tmpBuilder.GetList();
                    }

                    if (switchLabelExpr == null)
                    {
                        continue;
                    }

                    if (switchLabelExpr.StatementsExpr == null)
                    {
                        switchLabelExpr.StatementsExpr = NewExpr(
                            codeLab.StatementsNode, EXPRKIND.NOOP, null) as EXPRNOOP;
                    }
                } // while (node1 != null)

                if (typeSym != stringTypeSym)
                {
                    switchExpr.LabelArray.Sort(new CCompareSwitchLabels());
                }
                else if ((switchExpr.Flags & EXPRFLAG.HASDEFAULT) != 0)
                {
                    // have to move the default to the last position...
                    for (int cc = 0; cc < count; cc++)
                    {
                        if (switchExpr.LabelArray[cc].KeyExpr == null)
                        {
                            EXPRSWITCHLABEL def = switchExpr.LabelArray[cc];
                            int jj;
                            for (jj = cc + 1; jj < count; jj++)
                            {
                                switchExpr.LabelArray[jj - 1] = switchExpr.LabelArray[jj];
                            }
                            switchExpr.LabelArray[jj - 1] = def;
                            break;
                        }
                    }
                }

                switchExpr.BodiesExpr = labelsBuilder.GetList() as EXPRSWITCHLABEL;
                switchExpr.LabelCount = count;

                this.LoopLabels = prevLoopLabels;
                CloseScope();
                this.innermostSwitchScopeSym = prevSwitchScopeSym;
                DebugUtil.Assert(blockExpr.StatementsExpr == null);
                tmpBuilder.Clear();

                if (isConstant)
                {
                    if (constantGotoExpr.LabelExpr == null)
                    {
                        constantGotoExpr.LabelExpr = loopLabels.BreakLabel;
                    }
                    tmpBuilder.Add(constantGotoExpr);
                }
                tmpBuilder.Add(SetNodeStmt(switchStmtNode, switchExpr));
                tmpBuilder.Add(loopLabels.BreakLabel);
                blockExpr.StatementsExpr = tmpBuilder.GetList();
                this.currentBlockExpr = this.currentBlockExpr.OwingBlockExpr;

                builder.Add(blockExpr);
            }
            finally
            {
                sp.Pop();
            }
        }

        //--------------------------------------------------
        // FUNCBREC.InitForHashtableSwitch
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="switchExpr"></param>
        //--------------------------------------------------
        private void InitForHashtableSwitch(BASENODE treeNode, EXPRSWITCH switchExpr)
        {
            if (Compiler.MainSymbolManager.DictionaryAggTypeSym == null)
            {
                TYPESYM[] typeSymArray = new TYPESYM[2];

                typeSymArray[0] = GetRequiredPredefinedType(PREDEFTYPE.STRING);
                typeSymArray[1] = GetRequiredPredefinedType(PREDEFTYPE.INT);

                TypeArray taDictInst = Compiler.MainSymbolManager.AllocParams(typeSymArray);

                AGGSYM dictAggSym = Compiler.GetOptPredefAgg(PREDEFTYPE.G_DICTIONARY, true);
                DebugUtil.Assert(dictAggSym != null, "This should have been checked before...");
                if (dictAggSym == null)
                {
                    return;
                }

                AGGTYPESYM dictAts = Compiler.MainSymbolManager.GetInstAgg(dictAggSym, taDictInst);
                if (dictAts == null)
                {
                    return;
                }

                typeSymArray[0] = GetRequiredPredefinedType(PREDEFTYPE.INT);

                Compiler.MainSymbolManager.DictionaryCtorMethSym =
                    FindPredefMeth(
                        treeNode,
                        PREDEFNAME.CTOR,
                        GetOptionalPredefinedType(PREDEFTYPE.G_DICTIONARY),
                        Compiler.MainSymbolManager.AllocParams(typeSymArray[0]),
                        false,
                        MemLookFlagsEnum.None);
                if (Compiler.MainSymbolManager.DictionaryCtorMethSym == null)
                {
                    return;
                }

                TypeArray taDict = dictAggSym.TypeVariables;

                Compiler.MainSymbolManager.DictionaryAddMethSym =
                    FindPredefMeth(
                        treeNode,
                        PREDEFNAME.ADD,
                        GetOptionalPredefinedType(PREDEFTYPE.G_DICTIONARY),
                        taDict,
                        false,
                        MemLookFlagsEnum.None);
                if (Compiler.MainSymbolManager.DictionaryAddMethSym == null)
                {
                    return;
                }

                typeSymArray[0] = taDict[0];
                typeSymArray[1] = Compiler.MainSymbolManager.GetParamModifier(taDict[1], true);

                Compiler.MainSymbolManager.DictionaryTryGetValueMethSym =
                    FindPredefMeth(
                        treeNode,
                        PREDEFNAME.TRYGETVALUE,
                        GetOptionalPredefinedType(PREDEFTYPE.G_DICTIONARY),
                        Compiler.MainSymbolManager.AllocParams(typeSymArray),
                        false,
                        MemLookFlagsEnum.None);
                if (Compiler.MainSymbolManager.DictionaryTryGetValueMethSym == null)
                {
                    return;
                }
                Compiler.MainSymbolManager.DictionaryAggTypeSym = dictAts;
            }
            switchExpr.Flags |= EXPRFLAG.HASHTABLESWITCH;
        }

        //--------------------------------------------------
        // FUNCBREC.initForNonHashtableSwitch
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        //--------------------------------------------------
        private void InitForNonHashtableSwitch(BASENODE tree)
        {
            if (Compiler.MainSymbolManager.StringEqualsMethSym == null)
            {
                TYPESYM[] rgtype = new TYPESYM[2];
                rgtype[0] = GetRequiredPredefinedType(PREDEFTYPE.STRING);
                rgtype[1] = rgtype[0];

                Compiler.MainSymbolManager.StringEqualsMethSym =
                    FindPredefMeth(
                        tree,
                        PREDEFNAME.OPEQUALITY,
                        GetRequiredPredefinedType(PREDEFTYPE.STRING),
                        Compiler.MainSymbolManager.AllocParams(rgtype),
                        true,
                        MemLookFlagsEnum.Operator);
            }
        }

        //--------------------------------------------------
        // FUNCBREC.VerifySwitchLabel
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="typeSym"></param>
        /// <param name="fGoto"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRCONSTANT VerifySwitchLabel(BASENODE treeNode, TYPESYM typeSym, bool fGoto)
        {
            DebugUtil.Assert(treeNode != null);

            bool isNullable = typeSym != null && typeSym.IsNUBSYM;
            if (isNullable)
            {
                typeSym = typeSym.StripNubs();
            }

            EXPR rval = BindExpr(treeNode, BindFlagsEnum.RValueRequired);

            if (isNullable && rval.IsNull())
            {
                rval = MustConvert(
                    rval,
                    Compiler.MainSymbolManager.GetNubType(typeSym),
                    0);
                DebugUtil.Assert(rval.Kind == EXPRKIND.ZEROINIT || !rval.IsOK);

                // Use generic null.
                rval = BindNull(null);
            }
            else
            {
                if (!fGoto)
                {
                    DebugUtil.Assert(typeSym != null);
                    rval = MustConvert(rval, typeSym, 0);
                }
                else if (typeSym != null)
                {
                    FUNDTYPE ft = rval.TypeSym.FundamentalType();
                    if (ft > FUNDTYPE.I8 && ft != FUNDTYPE.REF)
                    {
                        // A float constant or something equally bad...
                        Compiler.Error(treeNode, CSCERRID.ERR_IntegralTypeValueExpected);
                        return null;
                    }

                    EXPR tempExpr = TryConvert(rval, typeSym, ConvertTypeEnum.NOUDC);
                    if (tempExpr == null)
                    {
                        tempExpr = MustCast(rval, typeSym, ConvertTypeEnum.NOUDC);
                        if (!tempExpr.IsOK)
                        {
                            return null;
                        }
                        if (tempExpr.Kind == EXPRKIND.CONSTANT)
                        {
                            Compiler.Error(treeNode, CSCERRID.WRN_GotoCaseShouldConvert, new ErrArg(typeSym));
                        }
                    }
                    rval = tempExpr;
                }

                if (rval.Kind != EXPRKIND.CONSTANT)
                {
                    if (rval.IsOK)
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_ConstantExpected);
                    }
                    return null;
                }

                // Switch on U8 is treated like switch on I8
                if (rval.TypeSym.FundamentalType() == FUNDTYPE.U8)
                {
                    rval.TypeSym = GetRequiredPredefinedType(PREDEFTYPE.LONG);
                }
            }

            return rval as EXPRCONSTANT;
        }

        //--------------------------------------------------
        // FUNCBREC.getSwitchLabelName
        //
        /// <summary></summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private string GetSwitchLabelName(EXPRCONSTANT expr)
        {
            string labelText = null;

            // This returns "default:" which relies on the : to guarantee uniqueness...
            if (expr == null)
            {
                return Compiler.NameManager.GetPredefinedName(PREDEFNAME.DEFAULT_CASE);
            }

            if (expr.IsNull())
            {
                labelText = "case null:";
                Compiler.NameManager.AddString(labelText);
                return labelText;
            }

            if (expr.TypeSym.IsPredefType(PREDEFTYPE.STRING) ||
                expr.TypeSym.IsPredefType(PREDEFTYPE.CHAR))
            {
                return GenerateSwitchLabelName(expr);
            }

            //WCHAR bufferW[256];
            //HRESULT hr;

            if (expr.TypeSym.IsPredefType(PREDEFTYPE.BOOL))
            {
                // The space and the : below guarantee uniqueness...
                //hr = StringCchPrintfW(bufferW, lengthof(bufferW), L"case %s:", expr.getVal().iVal ? L"true" : L"false");
                labelText = String.Format("case {0}:", expr.ConstVal.GetBool() ? "true" : "false");
            }
            else
            {
                // The space and the : below guarantee uniqueness...
                //hr = StringCchPrintfW(bufferW, lengthof(bufferW), L"case %I64d:", expr.getI64Value());
                labelText = String.Format("case {0}:", expr.GetI64Value());
            }

            //DebugUtil.Assert(SUCCEEDED(hr));
            Compiler.NameManager.AddString(labelText);
            return labelText;
        }

        //--------------------------------------------------
        // FUNCBREC.GenerateSwitchLabelName
        //
        /// <summary>
        /// Generates a string equivalent of StringCchPrintfW("case '%s' (0x%X):", pchSrc, iVal)
        /// If this is a string, then we use double quotes to surround the string
        /// and leave off the hex value.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private string GenerateSwitchLabelName(EXPRCONSTANT expr)
        {
            bool isChar = expr.TypeSym.IsPredefType(PREDEFTYPE.CHAR);
            string srcStr = null;
            string hexStr = null;

            if (isChar)
            {
                // 2 escaped characters and a null
                char ch = expr.ConstVal.GetChar();

                StringBuilder sb = new StringBuilder();
                FncBindUtil.EscapeChar(sb, ch);
                srcStr = sb.ToString();

                // calculate the hex value as well
                hexStr = String.Format(" (0x%X)", (uint)ch);
            }
            else
            {
                srcStr = expr.ConstVal.GetString();
            }

            StringBuilder dstSb = new StringBuilder();
            char quoteChar = (isChar ? '\'' : '\"');

            dstSb.Append("case ");
            dstSb.Append(quoteChar);
            dstSb.Append(srcStr);
            dstSb.Append(quoteChar);
            if (isChar)
            {
                dstSb.Append(hexStr);
            }
            dstSb.Append(':');

            string labelName = dstSb.ToString();
            compiler.NameManager.AddString(labelName);
            return labelName;
        }

        //--------------------------------------------------
        // FUNCBREC.BindTry
        //
        /// <summary></summary>
        /// <param name="tryStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindTry(TRYSTMTNODE tryStmtNode, StatementListBuilder builder)
        {
            EXPRTRY rval = NewExpr(tryStmtNode, EXPRKIND.TRY, null) as EXPRTRY;
            rval.HandlersExpr = null;
            StatementListBuilder handlersBuilder = new StatementListBuilder();	// (&rval.HandlersExpr);
            bool oldInsideTryOfCatch = this.insideTryOfCatch;

            if ((tryStmtNode.Flags & NODEFLAGS.TRY_CATCH) == 0)
            {
                this.finallyNestingCount++;
            }
            else
            {
                this.insideTryOfCatch = true;
            }

            SCOPESYM tryScopeSym = null;
            if (tryStmtNode.BlockNode != null)
            {
                rval.TryBlockExpr = BindBlock(
                    tryStmtNode.BlockNode,
                    SCOPEFLAGS.TRYSCOPE,
                    ref tryScopeSym,
                    null);
            }
            else
            {
                // Ensure that the EXPRTRY is well-formed so that downstream code can assume so.
                rval.TryBlockExpr = NewExprBlock(null);
                tryScopeSym = null;
            }

            // Restore this now that we're 'outside' the try block
            this.insideTryOfCatch = oldInsideTryOfCatch;

            if ((tryStmtNode.Flags & NODEFLAGS.TRY_CATCH) != 0)
            {
                BASENODE node1 = tryStmtNode.CatchNode;
                while (node1 != null)
                {
                    CATCHNODE catchNode;
                    if (node1.Kind == NODEKIND.LIST)
                    {
                        catchNode = node1.AsLIST.Operand1 as CATCHNODE;
                        node1 = node1.AsLIST.Operand2;
                    }
                    else
                    {
                        catchNode = node1 as CATCHNODE;
                        node1 = null;
                    }

                    EXPRHANDLER handlerExpr = NewExpr(catchNode, EXPRKIND.HANDLER, null) as EXPRHANDLER;
                    this.lastNode = catchNode;
                    handlerExpr.ParameterSym = null;

                    SCOPESYM catchScopeSym = null;
                    if (catchNode.TypeNode != null)
                    {
                        this.lastNode = catchNode.TypeNode;
                        TYPESYM typeSym = BindType(catchNode.TypeNode.AsANYTYPE);
                        DebugUtil.Assert(typeSym != null);
                        if (!typeSym.IsERRORSYM)
                        {
                            if (!CanConvert(
                                typeSym,
                                Compiler.GetReqPredefType(PREDEFTYPE.EXCEPTION, true),
                                ConvertTypeEnum.NOUDC))
                            {
                                Compiler.Error(catchNode.TypeNode, CSCERRID.ERR_BadExceptionType);
                            }
                            else
                            {
                                handlerExpr.TypeSym = typeSym;
                                // need to check whether this would even be reachable...

                                EXPRSTMT stmt1 = rval.HandlersExpr;
                                while (stmt1 != null)
                                {
                                    EXPRSTMT hand1 = stmt1;
                                    stmt1 = stmt1.NextStatement;
                                    EXPRHANDLER prevHand1 = hand1 as EXPRHANDLER;
                                    if (prevHand1.TypeSym != null &&
                                        CanConvert(typeSym, prevHand1.TypeSym, ConvertTypeEnum.NOUDC))
                                    {
                                        Compiler.Error(
                                            catchNode.TypeNode,
                                            CSCERRID.ERR_UnreachableCatch,
                                            new ErrArg(prevHand1.TypeSym));
                                        break;
                                    }
                                }

                            }
                            if (catchNode.NameNode != null)
                            {
                                this.unreferencedVarCount++;
                                this.lastNode = catchNode.NameNode;
                                CreateNewScope();
                                catchScopeSym = this.currentScopeSym;
                                LOCVARSYM locVarSym = DeclareVarNoScopeCheck(
                                    catchNode.NameNode, // catchNode, // (2015/09/25 hirano567@hotmail.co.jp)
                                    catchNode.NameNode.Name,
                                    typeSym);
                                if (locVarSym != null)
                                {
                                    handlerExpr.ParameterSym = locVarSym;
                                    locVarSym.LocSlotInfo.HasInit = true;
                                    locVarSym.IsCatch = true;
                                }
                            }
                        }
                    }
                    else
                    {
                        if (Compiler.WrapNonExceptionThrows())
                        {
                            // need to check whether this would even be reachable...
                            EXPRSTMT stmt2 = rval.HandlersExpr;
                            while (stmt2 != null)
                            {
                                EXPRSTMT hand2 = stmt2;
                                stmt2 = stmt2.NextStatement;
                                EXPRHANDLER prevHand2 = hand2 as EXPRHANDLER;
                                if (prevHand2.TypeSym != null &&
                                    prevHand2.TypeSym.IsPredefType(PREDEFTYPE.EXCEPTION))
                                {
                                    Compiler.Error(catchNode, CSCERRID.WRN_UnreachableGeneralCatch);
                                    break;
                                }
                            }

                        }
                        handlerExpr.TypeSym = Compiler.GetReqPredefType(PREDEFTYPE.OBJECT, true);
                    }

                    SCOPESYM dummyScope = null;
                    handlerExpr.HandlerBlock = BindBlock(
                        catchNode.BlockNode,
                        SCOPEFLAGS.CATCHSCOPE,
                        ref dummyScope,
                        catchScopeSym);
                    handlersBuilder.Add(SetNodeStmt(catchNode, handlerExpr));
                }

                rval.HandlersExpr = handlersBuilder.GetList();
            }
            else
            {
                // finally...
                this.finallyNestingCount--;

                if (tryStmtNode.CatchNode != null)
                {
                    SCOPESYM newScopeSym = null;
                    rval.HandlersExpr = BindBlock(
                        tryStmtNode.CatchNode as BLOCKNODE,
                        SCOPEFLAGS.FINALLYSCOPE,
                        ref newScopeSym,
                        null);
                    if (tryScopeSym != null)
                    {
                        tryScopeSym.FinallyScopeSym = newScopeSym;
                    }
                }
                else
                {
                    rval.HandlersExpr = NewExprBlock(null);
                }

                rval.Flags |= EXPRFLAG.ISFINALLY;
            }

            builder.Add(SetNodeStmt(tryStmtNode, rval));
        }

        //--------------------------------------------------
        // FUNCBREC.BindThrow
        //
        /// <summary></summary>
        /// <param name="exprStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindThrow(EXPRSTMTNODE exprStmtNode, StatementListBuilder builder)
        {
            EXPRTHROW rval = NewExpr(exprStmtNode, EXPRKIND.THROW, null) as EXPRTHROW;

            if (exprStmtNode.ArgumentsNode != null)
            {
                EXPR expr = BindExpr(exprStmtNode.ArgumentsNode, BindFlagsEnum.RValueRequired);
                if (!expr.IsOK)
                {
                    return;
                }

                EXPR tempExpr = TryConvert(
                    expr,
                    GetRequiredPredefinedType(PREDEFTYPE.EXCEPTION),
                    ConvertTypeEnum.NOUDC);
                if (tempExpr == null)
                {
                    Compiler.Error(exprStmtNode.ArgumentsNode, CSCERRID.ERR_BadExceptionType);
                }
                else
                {
                    expr = tempExpr;
                }
                rval.ObjectExpr = expr;
            }
            else
            {
                rval.ObjectExpr = null;
                // find out if we are enclosed in a catch scopeSym...

                bool foundFinally = false;
                SCOPESYM scopeSym = this.currentScopeSym;
                do
                {
                    if ((scopeSym.ScopeFlags & SCOPEFLAGS.DELEGATESCOPE) != 0)
                    {
                        scopeSym = null;
                        break;
                    }
                    if ((scopeSym.ScopeFlags & SCOPEFLAGS.CATCHSCOPE) != 0) break;
                    if ((scopeSym.ScopeFlags & SCOPEFLAGS.FINALLYSCOPE) != 0)
                    {
                        foundFinally = true;
                    }
                    scopeSym = scopeSym.ParentSym as SCOPESYM;
                } while (scopeSym != null);

                if (scopeSym == null)
                {
                    Compiler.Error(exprStmtNode, CSCERRID.ERR_BadEmptyThrow);
                }
                else if (foundFinally)
                {
                    Compiler.Error(exprStmtNode, CSCERRID.ERR_BadEmptyThrowInFinally);
                }
            }

            builder.Add(SetNodeStmt(exprStmtNode, rval));
        }


        //--------------------------------------------------
        // FUNCBREC.BindMultiOp
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="exprKind"></param>
        /// <param name="op1"></param>
        /// <param name="op2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindMultiOp(BASENODE treeNode, EXPRKIND exprKind, EXPR op1, EXPR op2)
        {
            if (!CheckLvalue(op1, true))
            {
                return NewError(treeNode, op1.TypeSym);
            }

            EXPRMULTIGET getExpr = NewExpr(op1.TreeNode, EXPRKIND.MULTIGET, op1.TypeSym) as EXPRMULTIGET;
            getExpr.Flags |= EXPRFLAG.ASSGOP;

            bool isUserDef = false;
            NubInfo nubInfo = new NubInfo();
            EXPR valueExpr = BindStdBinOp(treeNode, exprKind, getExpr, op2, ref isUserDef, ref nubInfo);
            DebugUtil.Assert(!isUserDef || !nubInfo.IsActive);
            if (!nubInfo.IsActive)
            {
                valueExpr.Flags |= EXPRFLAG.PUSH_OP_FIRST;
            }

            EXPRMULTI multiExpr = NewExpr(treeNode, EXPRKIND.MULTI, op1.TypeSym) as EXPRMULTI;
            getExpr.MultiExpr = multiExpr;
            multiExpr.LeftExpr = op1;
            multiExpr.Flags |= EXPRFLAG.ASSGOP;

            // Convert to the destination type.
            EXPR resExpr;

            //------------------------------------------------------------
            // These conversion rules are bogus - they allow stuff that really shouldn't be allowed
            // and prohibit other things that should be allowed. Eg,
            // * char += char, char *= char, etc are allowed but shouldn't be.
            // * char += 1 is not allowed but should be.
            // * ptr += ptr, ptr -= ptr are allowed but shouldn't be.
            // * byte <<= 1 can throw in a checked context.
            //
            // The proper fix would be for +(byte, byte) to be defined and available when doing compound
            // assignment (but not available otherwise). This leads to a much cleaner implementation that
            // is naturally extensible to nullable as well.
            //------------------------------------------------------------

            if (isUserDef)
            {
                DebugUtil.Assert(!nubInfo.IsActive);
                resExpr = MustConvert(valueExpr, op1.TypeSym, 0);
            }
            else if (!nubInfo.IsActive)
            {
                resExpr = TryConvert(valueExpr, op1.TypeSym, 0);
                if (resExpr == null)
                {
                    resExpr = MustCast(valueExpr, op1.TypeSym, 0);
                    if (exprKind != EXPRKIND.LSHIFT && exprKind != EXPRKIND.RSHIFT)
                    {
                        MustConvert(op2, op1.TypeSym, 0);
                    }
                }
            }
            else
            {
                // The operator is lifted.
                DebugUtil.Assert(!valueExpr.TypeSym.IsNUBSYM);

                NUBSYM dstNubSym = Compiler.MainSymbolManager.GetNubType(valueExpr.TypeSym);
                EXPR nullExpr = NewExprZero(treeNode, dstNubSym);

                // First convert to the nullable type.
                valueExpr = MustConvert(valueExpr, dstNubSym, 0);

                // Now go through the goofy conversion tests.
                resExpr = TryConvert(valueExpr, op1.TypeSym, 0);
                if (resExpr == null)
                {
                    resExpr = MustCast(valueExpr, op1.TypeSym, 0);
                    if (exprKind != EXPRKIND.LSHIFT && exprKind != EXPRKIND.RSHIFT)
                    {
                        MustConvert(op2, op1.TypeSym, 0);
                    }
                }

                // If resExpr is an error expr, just use it - don't try to cast the nullExpr and
                // risk a duplicate error message.
                nullExpr = resExpr.IsOK ? MustCast(nullExpr, op1.TypeSym, 0) : resExpr;

                if (nubInfo.FAlwaysNull() && nullExpr.IsOK)
                {
                    Compiler.Error(treeNode, CSCERRID.WRN_AlwaysNull, new ErrArg(dstNubSym));
                }
                resExpr = BindNubOpRes(treeNode, op1.TypeSym, resExpr, nullExpr, ref nubInfo);
            }

            multiExpr.OperandExpr = resExpr;

            return multiExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.isCastOptThis
        //
        /// <summary></summary>
        /// <param name="search"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool IsCastOptThis(EXPR search)
        {
            while (search != null && search.Kind == EXPRKIND.CAST)
            {
                search = (search as EXPRCAST).Operand;
            }
            return (search != null && IsThisPointer(search));
        }

        //--------------------------------------------------
        // FUNCBREC.IsFixedExpression
        //
        /// <summary></summary>
        /// <param name="expr"></param>
        /// <param name="localSym"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool IsFixedExpression(EXPR expr, out LOCVARSYM localSym)
        {
            localSym = null;

            for (; ; )
            {
                switch (expr.Kind)
                {
                    case EXPRKIND.FIELD:
                        {
                            if ((expr as EXPRFIELD).FieldWithType.FieldSym.IsStatic)
                            {
                                return false;
                            }
                            EXPR tempExpr = (expr as EXPRFIELD).ObjectExpr;
                            if (tempExpr == null)
                            {
                                return false;
                            }
                            if ((tempExpr.Flags & EXPRFLAG.LVALUE) == 0)
                            {
                                return false;
                            }
                            Compiler.EnsureState(tempExpr.TypeSym, AggStateEnum.Prepared);
                            if (tempExpr.TypeSym.FundamentalType() == FUNDTYPE.REF)
                            {
                                return false;
                            }
                            expr = tempExpr;
                            continue;
                        }
                    case EXPRKIND.LOCAL:
                        {
                            LOCVARSYM local = (expr as EXPRLOCAL).LocVarSym;
                            localSym = local;
                            if (local.LocSlotInfo.IsParameter)
                            {
                                return !local.LocSlotInfo.IsReferenceParameter;
                            }
                            return local != this.thisPointerSym;
                        }
                    case EXPRKIND.LOCALLOC:
                    case EXPRKIND.INDIR:
                        return true;

                    default:
                        return false;
                }
            }
        }

        //--------------------------------------------------
        // FUNCBREC.isAddressable
        //
        /// <summary>
        /// prop returns, array indexes and refanys are not addressable
        /// This means that you can't say &X in either a fixed statement or outside of it.
        /// If foo is an array you can never say &(foo[4]), not even in a fixed statement...
        /// [Note, however, that you can say &(foo[3].la) in a fixed statement...
        /// If foo is a fixed buffer this code should not get called because it is not
        /// a valid LVALUE, and thus not even eligible for taking the address of.
        /// It will ASSERT and return false.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool IsAddressable(EXPR expr)
        {

            switch (expr.Kind)
            {
                case EXPRKIND.PROP:
                case EXPRKIND.VALUERA:
                    return false;

                case EXPRKIND.ARRINDEX:
                case EXPRKIND.FIELD:
                case EXPRKIND.LOCAL:
                case EXPRKIND.INDIR:
                    return true;

                default:
                    DebugUtil.Assert(false, "bad lvalue expr");
                    return false;
            }
        }

        //--------------------------------------------------
        // FUNCBREC.CheckLvalue
        //
        /// <summary>
        /// <para>A false return means not to process the expr any further -
        /// it's totally out of place.</para>
        /// <para>For example - a method group or an anonymous method.</para>
        /// <para>(In sscli, argument isAssignment has the default value true.</para>
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="isAssignment"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool CheckLvalue(
            EXPR expr,
            bool isAssignment) // = true
        {
            if (!expr.IsOK)
            {
                return false;
            }

            if ((expr.Flags & EXPRFLAG.LVALUE) != 0)
            {
                // otherwise, even if it is an lvalue, it may be an abstract prop call, which is also illegal...
                if (expr.Kind == EXPRKIND.PROP)
                {
                    if ((expr.Flags & EXPRFLAG.BASECALL) != 0 &&
                        (expr as EXPRPROP).SetMethodWithType.MethSym.IsAbstract)
                    {
                        Compiler.Error(
                            expr.TreeNode,
                            CSCERRID.ERR_AbstractBaseCall,
                            new ErrArg((expr as EXPRPROP).SetMethodWithType));
                    }
                    else if (!Compiler.ClsDeclRec.CheckAccess(
                        (expr as EXPRPROP).SetMethodWithType.MethSym,
                        (expr as EXPRPROP).SetMethodWithType.AggTypeSym,
                        this.parentDeclSym, null))
                    {
                        // Not accessible so give an error
                        Compiler.Error(
                            expr.TreeNode,
                            CSCERRID.ERR_InaccessibleSetter,
                            new ErrArg((expr as EXPRPROP).SlotPropWithType));
                    }
                }
                MarkFieldAssigned(expr);
                OnPossibleAssignmentToArg(expr.TreeNode, expr);
                return true;
            }

            switch (expr.Kind)
            {
                case EXPRKIND.PROP:
                    if (!isAssignment)
                    {
                        // passing a property as ref or out
                        Compiler.Error(expr.TreeNode, CSCERRID.ERR_RefProperty);
                        return true;
                    }
                    if ((expr as EXPRPROP).SetMethodWithType == null)
                    {
                        // Assigning to a property without a setter.
                        Compiler.Error(
                            expr.TreeNode,
                            CSCERRID.ERR_AssgReadonlyProp,
                            new ErrArg((expr as EXPRPROP).SlotPropWithType));
                        return true;
                    }
                    break;

                case EXPRKIND.ARRLEN:
                    if (!isAssignment)
                    {
                        // passing a property as ref or out
                        Compiler.Error(expr.TreeNode, CSCERRID.ERR_RefProperty);
                    }
                    else
                    {
                        // Special case, the length property of an array
                        SYM sym = Compiler.MainSymbolManager.LookupAggMember(
                            Compiler.NameManager.GetPredefinedName(PREDEFNAME.LENGTH),
                            Compiler.GetReqPredefAgg(PREDEFTYPE.ARRAY, true),
                            SYMBMASK.ALL);
                        Compiler.Error(expr.TreeNode, CSCERRID.ERR_AssgReadonlyProp, new ErrArg(sym));
                    }
                    return true;

                case EXPRKIND.ANONMETH:
                case EXPRKIND.CONSTANT:
                case EXPRKIND.LAMBDAEXPR:   // CS3
                    Compiler.Error(
                        expr.TreeNode,
                        isAssignment ? CSCERRID.ERR_AssgLvalueExpected : CSCERRID.ERR_RefLvalueExpected);
                    return false;

                case EXPRKIND.MEMGRP:
                    Compiler.Error(
                        expr.TreeNode,
                        isAssignment ?
                            CSCERRID.ERR_AssgReadonlyLocalCause :
                            CSCERRID.ERR_RefReadonlyLocalCause,
                        new ErrArg((expr as EXPRMEMGRP).Name),
                        new ErrArgResNo(ResNo.CSCSTR_MethodGroup)); // CSCSTRID.MethodGroup));
                    return false;

                case EXPRKIND.RUNTIMEBINDEDMEMBER:  // CS4
                case EXPRKIND.RUNTIMEBINDEDUNAOP:
                case EXPRKIND.RUNTIMEBINDEDBINOP:
                case EXPRKIND.RUNTIMEBINDEDINVOCATION:
                    return true;

                default:
                    break;
            }

            bool isNested = false; // Did we recurse on a field or property to give a better error

            // We have a lvalue failure. Was the reason because this field
            // was marked readonly? Give special messages for this case..
            for (EXPR walk = expr; ; isNested = true)
            {
                if (walk.Kind == EXPRKIND.LOCAL)
                {
                    ResNo cause = ResNo.Invalid;
                    EXPRLOCAL localExpr = walk as EXPRLOCAL;
                    if (localExpr.LocVarSym.IsForeach)
                    {
                        cause = ResNo.CSCSTR_FOREACHLOCAL; // CSCSTRID.FOREACHLOCAL;
                    }
                    else if (localExpr.LocVarSym.IsUsing)
                    {
                        cause = ResNo.CSCSTR_USINGLOCAL; // CSCSTRID.USINGLOCAL;
                    }
                    else if (localExpr.LocVarSym.IsFixed)
                    {
                        cause = ResNo.CSCSTR_FIXEDLOCAL; // CSCSTRID.FIXEDLOCAL;
                    }

                    // isNested << 1 | (isAssignment & 1)
                    int idx = (int)(isNested ? 0x10 : 0x00) + (int)(isAssignment ? 0x01 : 0x00);
                    CSCERRID err;
                    if (cause != null)
                    {
                        err = readOnlyLocalWCauseErrors[idx];
                        // readOnlyLocalWCauseErrors is defined after this method.
                        Compiler.Error(expr.TreeNode, err,
                            new ErrArg(localExpr.LocVarSym.Name),
                            new ErrArgResNo(cause));
                    }
                    else
                    {
                        err = readOnlyLocalErrors[idx];
                        // readOnlyLocalErrors is defined after this method.
                        Compiler.Error(expr.TreeNode, err, new ErrArg(localExpr.LocVarSym.Name));
                    }
                    return true;
                }

                EXPR tempExpr = null;
                bool isReadOnly = false;
                bool isStatic = false;

                if (walk.Kind == EXPRKIND.PROP)
                {
                    DebugUtil.Assert((walk as EXPRPROP).SetMethodWithType != null);
                    tempExpr = (walk as EXPRPROP).ObjectExpr;
                }
                else if (walk.Kind == EXPRKIND.FIELD)
                {
                    isReadOnly = (walk as EXPRFIELD).FieldWithType.FieldSym.IsReadOnly;
                    isStatic = (walk as EXPRFIELD).FieldWithType.FieldSym.IsStatic;
                    if (!isStatic)
                    {
                        tempExpr = (walk as EXPRFIELD).ObjectExpr;
                    }
                }

                if (isReadOnly)
                {
                    // isStatic << 1 | (isAssignment & 1)
                    int idx = (int)(isStatic ? 0x10 : 0x00) + (int)(isAssignment ? 0x01 : 0x00);
                    CSCERRID err;
                    if (isNested)
                    {
                        err = readOnlyNestedErrors[idx];
                        // readOnlyNestedErrors is defined after this method.
                        Compiler.Error(expr.TreeNode, err, new ErrArg((walk as EXPRFIELD).FieldWithType));
                    }
                    else
                    {
                        err = readOnlyErrors[idx];
                        // readOnlyErrors is defined after this method.
                        Compiler.Error(expr.TreeNode, err);
                    }
                    return true;
                }

                if (tempExpr != null && tempExpr.TypeSym.IsStructOrEnum())
                {
                    if (tempExpr.Kind == EXPRKIND.CALL || tempExpr.Kind == EXPRKIND.PROP)
                    {
                        // assigning to RHS of method or property getter returning a value-type on the stack or
                        // passing RHS of method or property getter returning a value-type on the stack, as ref or out
                        Compiler.Error(tempExpr.TreeNode, CSCERRID.ERR_ReturnNotLValue,
                            new ErrArg(tempExpr.GetSymWithType()));
                        return true;
                    }
                    if (tempExpr.Kind == EXPRKIND.CAST)
                    {
                        // An unboxing conversion.
                        Compiler.Error(tempExpr.TreeNode, CSCERRID.ERR_UnboxNotLValue);
                        return true;
                    }
                }

                // everything else
                if (tempExpr != null &&
                    (tempExpr.Flags & EXPRFLAG.LVALUE) == 0 &&
                    (walk.Kind == EXPRKIND.FIELD || (!isNested && walk.Kind == EXPRKIND.PROP)))
                {
                    DebugUtil.Assert(tempExpr.TypeSym.IsStructOrEnum());
                    walk = tempExpr;
                }
                else
                {
                    Compiler.Error(
                        expr.TreeNode,
                        isAssignment ? CSCERRID.ERR_AssgLvalueExpected : CSCERRID.ERR_RefLvalueExpected);
                    return true;
                }
            }
        }

        private static CSCERRID[] readOnlyLocalWCauseErrors =
        {
            CSCERRID.ERR_RefReadonlyLocalCause,
            CSCERRID.ERR_AssgReadonlyLocalCause,
            CSCERRID.ERR_RefReadonlyLocal2Cause,
            CSCERRID.ERR_AssgReadonlyLocal2Cause,
        };

        private static CSCERRID[] readOnlyLocalErrors =
        {
            CSCERRID.ERR_RefReadonlyLocal,
            CSCERRID.ERR_AssgReadonlyLocal,
            CSCERRID.ERR_RefReadonlyLocal2,
            CSCERRID.ERR_AssgReadonlyLocal2
        };

        private static CSCERRID[] readOnlyNestedErrors =
        {
            CSCERRID.ERR_RefReadonly2,
            CSCERRID.ERR_AssgReadonly2,
            CSCERRID.ERR_RefReadonlyStatic2,
            CSCERRID.ERR_AssgReadonlyStatic2
        };

        private static CSCERRID[] readOnlyErrors =
        {
            CSCERRID.ERR_RefReadonly,
            CSCERRID.ERR_AssgReadonly,
            CSCERRID.ERR_RefReadonlyStatic,
            CSCERRID.ERR_AssgReadonlyStatic
        };

        //--------------------------------------------------
        // FUNCBREC.CheckFieldRef
        //
        /// <summary>
        /// Taking the reference of a field is suspect if the type is marshalbyref.
        /// Also checks for passing volatile field by-ref.
        /// </summary>
        /// <param name="expr"></param>
        //--------------------------------------------------
        private void CheckFieldRef(EXPR expr)
        {
            if (expr == null || expr.Kind != EXPRKIND.FIELD) return;

            EXPRFIELD fieldExpr = expr as EXPRFIELD;

            // We ignore it if it's static or (an optional cast of) the this pointer.
            if (fieldExpr.FieldWithType.FieldSym.ClassSym.IsMarshalByRef &&
                !fieldExpr.FieldWithType.FieldSym.IsStatic &&
                !IsCastOptThis(fieldExpr.ObjectExpr))
            {
                Compiler.Error(
                    fieldExpr.TreeNode,
                    CSCERRID.WRN_ByRefNonAgileField,
                    new ErrArg(fieldExpr.FieldWithType),
                    new ErrArgRefOnly(fieldExpr.FieldWithType.FieldSym.ClassSym));
            }

#if DEBUG
            fieldExpr.CheckedMarshalByRef = true;
#endif

            if (fieldExpr.FieldWithType.FieldSym.IsVolatile)
            {
                Compiler.Error(fieldExpr.TreeNode, CSCERRID.WRN_VolatileByRef, new ErrArg(fieldExpr.FieldWithType));
            }
        }

        //--------------------------------------------------
        // FUNCBREC.CheckFieldUse
        //
        /// <summary>
        /// <para>(In sscli, needReport has the default value true.)</para>
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="needReport"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private bool CheckFieldUse(
            EXPR expr,
            bool needReport)	// = true
        {
            if (expr == null || expr.Kind != EXPRKIND.FIELD) return true;

            EXPRFIELD fieldExpr = expr as EXPRFIELD;

#if DEBUG
            //DebugOnly(fieldExpr.fCheckedMarshalByRef = true);
            fieldExpr.CheckedMarshalByRef = true;
#endif

            // We ignore it if it's static or (an optional cast of) the this pointer.
            // It must also be something we could use a ldflda instruction on -
            // a valuetype or type variable.
            if (fieldExpr.FieldWithType.FieldSym.ClassSym.IsMarshalByRef &&
                !fieldExpr.FieldWithType.FieldSym.IsStatic &&
                !IsCastOptThis(fieldExpr.ObjectExpr) &&
                (fieldExpr.TypeSym.IsStructOrEnum() || fieldExpr.TypeSym.IsTYVARSYM))
            {
                if (needReport)
                {
                    Compiler.Error(
                        fieldExpr.TreeNode,
                        CSCERRID.WRN_CallOnNonAgileField,
                        new ErrArg(fieldExpr.FieldWithType),
                        new ErrArgRefOnly(fieldExpr.FieldWithType.FieldSym.ClassSym));
                }
                return false;
            }
            return true;
        }

        //--------------------------------------------------
        // FUNCBREC.checkUnsafe
        //
        /// <summary>
        /// <para>(In sscli, there are default values,
        /// type = null,
        /// errCode = CSCERRID.ERR_UnsafeNeeded,
        /// and errorArg = null.</para>
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="type"></param>
        /// <param name="errCode"></param>
        /// <param name="errorArg"></param>
        //--------------------------------------------------
        private void CheckUnsafe(
            BASENODE tree,
            TYPESYM type,       //  = null
            CSCERRID errCode,	    // = CSCERRID.ERR_UnsafeNeeded
            ErrArg errorArg)	//  = null
        {
            DebugUtil.Assert((errCode != CSCERRID.ERR_SizeofUnsafe) || errorArg != null);

            if (type == null || type.IsUnsafe())
            {
                if (!IsUnsafeContext() && !this.unsafeErrorGiven)
                {
                    this.unsafeErrorGiven = true;
                    if (errorArg != null)
                    {
                        Compiler.Error(tree, errCode, errorArg);
                    }
                    else
                    {
                        Compiler.Error(tree, errCode);
                    }
                }
                else if (this.methodInfo != null && this.methodInfo.UnsafeTreeNode == null && tree != null)
                {
                    // If this is unsafe code and we didn't already report an error
                    // save this location for later in case this method turns out to
                    // be an iterator
                    this.methodInfo.UnsafeTreeNode = tree;
                }
            }
        }

        //--------------------------------------------------
        // FUNCBREC.MarkFieldAssigned
        //
        /// <summary>
        /// Sets the isAssigned bit
        /// </summary>
        /// <param name="expr"></param>
        //--------------------------------------------------
        private void MarkFieldAssigned(EXPR expr)
        {
            if (expr.Kind == EXPRKIND.FIELD && (expr.Flags & EXPRFLAG.LVALUE) != 0)
            {
                EXPRFIELD field;

                do
                {
                    field = expr as EXPRFIELD;
                    field.FieldWithType.FieldSym.IsAssigned = true;
                    expr = field.ObjectExpr;
                } while (
                    field.FieldWithType.FieldSym.ClassSym.IsStruct &&
                    !field.FieldWithType.FieldSym.IsStatic &&
                    expr != null &&
                    expr.Kind == EXPRKIND.FIELD);
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindQMark
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="op1"></param>
        /// <param name="op2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindQMark(BASENODE treeNode, EXPR op1, EXPRBINOP op2)
        {
            DebugUtil.Assert(op2.Kind == EXPRKIND.BINOP && op1.IsOK);

            op1 = BindBooleanValue(op1.TreeNode != null ? op1.TreeNode : treeNode, op1);

            EXPR T = op2.AsBIN.Operand1;
            EXPR S = op2.AsBIN.Operand2;
            DebugUtil.Assert(S.IsOK && T.IsOK);

            EXPR rval;
            EXPR opConst1;

            if (T.TypeSym != S.TypeSym || T.TypeSym.IsNeverSameType())
            {
                bool T1 = CanConvert(T, S.TypeSym, 0);
                bool S1 = CanConvert(S, T.TypeSym, 0);
                if (T1)
                {
                    if (!S1)
                    {
                        op2.AsBIN.Operand1 = MustConvert(T, S.TypeSym, 0);
                    }
                    else
                    {
                        Compiler.Error(op2.TreeNode, CSCERRID.ERR_AmbigQM,
                            new ErrArg(T.TypeSym), new ErrArg(S.TypeSym));
                        goto LERROR;
                    }
                }
                else
                { // ! T1
                    if (S1)
                    {
                        op2.AsBIN.Operand2 = MustConvert(S, T.TypeSym, 0);
                    }
                    else
                    {
                        // Don't report the error if one of the types is an unknown error type
                        if ((!T.TypeSym.IsERRORSYM || T.TypeSym.ParentSym != null) &&
                            (!S.TypeSym.IsERRORSYM || S.TypeSym.ParentSym != null))
                        {
                            Compiler.Error(op2.TreeNode, CSCERRID.ERR_InvalidQM,
                                new ErrArg(T.TypeSym, ErrArgFlagsEnum.Unique),
                                new ErrArg(S.TypeSym, ErrArgFlagsEnum.Unique));
                        }
                        else
                        {
                            DebugUtil.Assert(Compiler.ErrorCount() > 0);
                        }
                        goto LERROR;
                    }
                }
            }

            opConst1 = op1.GetConst();
            if (opConst1 != null)
            {
                if ((opConst1 as EXPRCONSTANT).ConstVal.GetInt() != 0)
                {
                    // controlling bool is constant true.
                    rval = AddSideEffects(treeNode, op2.AsBIN.Operand1, op1, true, false);
                    if (op2.AsBIN.Operand2 != null &&
                        op2.AsBIN.Operand2.IsOK &&
                        op2.AsBIN.Operand2.TreeNode != null)
                    {
                        Compiler.Error(op2.AsBIN.Operand2.TreeNode, CSCERRID.WRN_UnreachableExpr);
                    }
                }
                else
                {
                    // controlling bool is constant false.
                    rval = AddSideEffects(treeNode, op2.AsBIN.Operand2, op1, true, false);
                    if (op2.AsBIN.Operand1 != null &&
                        op2.AsBIN.Operand1.IsOK &&
                        op2.AsBIN.Operand1.TreeNode != null)
                    {
                        Compiler.Error(op2.AsBIN.Operand1.TreeNode, CSCERRID.WRN_UnreachableExpr);
                    }
                }
            }
            else
            {
                // Usual case: controlling bool is not a constant.
                TYPESYM type = op2.AsBIN.Operand1.TypeSym;
                DebugUtil.Assert(type == op2.AsBIN.Operand2.TypeSym);

                rval = NewExprBinop(treeNode, EXPRKIND.QMARK, type, op1, op2);
            }

            return rval;

        LERROR:
            return NewError(treeNode, null);
        }

        //--------------------------------------------------
        // FUNCBREC.BindStringConcat
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="operandExpr1"></param>
        /// <param name="operandExpr2"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindStringConcat(BASENODE treeNode, EXPR operandExpr1, EXPR operandExpr2)
        {
            EXPR firstB, lastA;
            int addedCount;

            if (operandExpr1.Kind == EXPRKIND.CONCAT)
            {
                //lastA = *(operandExpr1.AsCONCAT.pList);
                lastA = (operandExpr1 as EXPRCONCAT).ListLast;
            }
            else
            {
                lastA = operandExpr1;
            }

            if (operandExpr2.Kind == EXPRKIND.CONCAT)
            {
                //firstB = operandExpr2.AsCONCAT.list.AsBINOP.Operand1;
                firstB = ((operandExpr2 as EXPRCONCAT).List as EXPRBINOP).Operand1;
            }
            else
            {
                firstB = operandExpr2;
            }

            if (lastA.Kind == EXPRKIND.CONSTANT && firstB.Kind == EXPRKIND.CONSTANT)
            {
                EXPR second;
                if ((firstB as EXPRCONSTANT).List != null)
                {
                    // we need to convert it to a BINOP list
                    second = NewExprBinop(
                        null,
                        EXPRKIND.LIST,
                        null,
                        firstB,                         // operand1
                        (firstB as EXPRCONSTANT).List); // operand2
                    //firstB.AsCONSTANT.list = null;
                    //firstB.AsCONSTANT.pList = &(firstB.AsCONSTANT.list);
                    (firstB as EXPRCONSTANT).ClearList();
                }
                else
                {
                    second = firstB;
                }

                // If operand1 or the last element of operand1 which is a concatination,
                // and if the operand2 is constant value,
                // add operand2 to the list of operand1 or last element.

                // Connect second to lastA
                //NewList(second, &(lastA.AsCONSTANT.pList));
                addedCount = NewList(second,
                    ref (lastA as EXPRCONSTANT).List, ref (lastA as EXPRCONSTANT).ListLast);
                //lastA.AsCONSTANT.allocator = allocator;
                //if (second.kind == EXPRKIND.LIST)
                //{
                //    lastA.AsCONSTANT.pList = &(second.AsBIN.p2);
                //}

                if (firstB == operandExpr2)	// operandExpr2 is not EXPRCONCAT.
                { // if second was an item, and not a list
                    return operandExpr1; // just return the first...
                    // EXPRCONCAT has no list count.
                }

                if ((operandExpr2 as EXPRCONCAT).Count == 2)
                {
                    // now this list is really an item...
                    //operandExpr2 = firstB = operandExpr2.AsCONCAT.list.AsBIN.p2;
                    operandExpr2 = firstB = (operandExpr2 as EXPRCONCAT).List.AsBIN.Operand2;
                }
                else
                {
                    //operandExpr2.AsCONCAT.list = operandExpr2.AsCONCAT.list.AsBIN.p2;
                    //operandExpr2.AsCONCAT.count --;
                    (operandExpr2 as EXPRCONCAT).List = (operandExpr2 as EXPRCONCAT).List.AsBIN.Operand2;
                }
            }	// if (lastA.Kind == EXPRKIND.CONSTANT && firstB.Kind == EXPRKIND.CONSTANT)

            if (firstB == operandExpr2)
            { // ???? + item
                if (lastA != operandExpr1)
                { // LIST + ????
                    //newList(operandExpr2, &operandExpr1.AsCONCAT.pList);
                    NewList(operandExpr2,
                        ref (operandExpr1 as EXPRCONCAT).List, ref (operandExpr1 as EXPRCONCAT).ListLast);
                    (operandExpr1 as EXPRCONCAT).Count += 1;
                    return operandExpr1;
                }
                else
                { // item + ????
                    EXPRCONCAT rval = NewExpr(
                        treeNode,
                        EXPRKIND.CONCAT,
                        GetRequiredPredefinedType(PREDEFTYPE.STRING)) as EXPRCONCAT;
                    //rval.list = operandExpr1;
                    //rval.pList = &rval.list;
                    NewList(operandExpr1, ref rval.List, ref rval.ListLast);
                    //newList(operandExpr2, &rval.pList);
                    NewList(operandExpr2, ref rval.List, ref rval.ListLast);
                    rval.Count = 2;
                    rval.Flags |= EXPRFLAG.UNREALIZEDCONCAT;
                    return rval;
                }
            }
            else
            { // ???? + LIST
                if (lastA != operandExpr1)
                { // LIST + ????
                    //newList(operandExpr2.AsCONCAT.list, &operandExpr1.AsCONCAT.pList);
                    NewList((operandExpr2 as EXPRCONCAT).List,
                        ref (operandExpr1 as EXPRCONCAT).List, ref (operandExpr1 as EXPRCONCAT).ListLast);
                    //operandExpr1.AsCONCAT.pList = operandExpr2.AsCONCAT.pList;
                    (operandExpr1 as EXPRCONCAT).Count += (operandExpr2 as EXPRCONCAT).Count;
                    return operandExpr1;
                }
                else
                { // item + ????
                    (operandExpr2 as EXPRCONCAT).List = NewExprBinop(
                        null,
                        EXPRKIND.LIST,
                        null,
                        operandExpr1,
                        (operandExpr2 as EXPRCONCAT).List);
                    (operandExpr2 as EXPRCONCAT).Count++;
                    return operandExpr2;
                }
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindNull
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindNull(BASENODE tree)
        {
            return NewExprConstant(tree, Compiler.MainSymbolManager.NullSym, new ConstValInit());
        }

        //--------------------------------------------------
        // FUNCBREC.BindMethodName
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindMethodName(BASENODE treeNode)
        {
            EXPR expr;
            BASENODE nameNode;

            if (treeNode.IsAnyName)
            {
                expr = SetNodeExpr(treeNode, BindName(treeNode.AsANYNAME,
                    SYMBMASK.METHSYM |
                    SYMBMASK.MEMBVARSYM |
                    SYMBMASK.LOCVARSYM |
                    SYMBMASK.PROPSYM,
                    BindFlagsEnum.RValueRequired));
                nameNode = treeNode.AsANYNAME;
            }
            else if (treeNode.Kind == NODEKIND.DOT || treeNode.Kind == NODEKIND.ARROW)
            {
                expr = SetNodeExpr(
                    treeNode,
                    BindDot(
                        treeNode.AsANYBINOP,
                        SYMBMASK.METHSYM | SYMBMASK.MEMBVARSYM | SYMBMASK.PROPSYM,
                        BindFlagsEnum.RValueRequired));
                nameNode = treeNode.AsANYBINOP.Operand2.AsANYNAME;
            }
            else
            {
                expr = BindExpr(treeNode, BindFlagsEnum.RValueRequired);
                nameNode = treeNode;
            }

            if (!expr.IsOK)
            {
                return expr;
            }

            if (expr.Kind == EXPRKIND.MEMGRP && (expr as EXPRMEMGRP).SymKind == SYMKIND.METHSYM)
            {
                return expr as EXPRMEMGRP;
            }
            //--------------------------------------------------------
            // (CS4) EXPRRUNTIMEBINDEDMEMBER
            //--------------------------------------------------------
            else if (expr.Kind == EXPRKIND.RUNTIMEBINDEDMEMBER)
            {
                EXPRRUNTIMEBINDEDMEMBER rtMembExpr = expr as EXPRRUNTIMEBINDEDMEMBER;
                EXPRRUNTIMEBINDEDINVOCATION invokeExpr = NewExprCore(
                    rtMembExpr.TreeNode,
                    EXPRKIND.RUNTIMEBINDEDINVOCATION,
                    GetRequiredPredefinedType(PREDEFTYPE.OBJECT),
                    0,
                    EXPRKIND.RUNTIMEBINDEDINVOCATION) as EXPRRUNTIMEBINDEDINVOCATION;
                DebugUtil.Assert(invokeExpr != null);

                invokeExpr.Set(rtMembExpr);
                return invokeExpr;
            }

            if (expr.TypeSym != null && expr.TypeSym.IsDelegateType())
            {
                // Note: don't call SetNodeExpr on the MEMGRP. We want the delegate expression to be bound
                // to the name node, not the MEMGRP.
                TYPESYM typeSym = expr.TypeSym;

                if (treeNode.Kind == NODEKIND.UNOP && treeNode.Operator == OPERATOR.DEFAULT)
                {
                    Compiler.Error(treeNode.ParentNode, CSCERRID.WRN_DotOnDefault, new ErrArg(typeSym));
                }

                // Construct the method group.
                EXPRMEMGRP grpExpr = NewExpr(
                    treeNode,
                    EXPRKIND.MEMGRP,
                    Compiler.MainSymbolManager.MethodGroupTypeSym) as EXPRMEMGRP;
                grpExpr.NameNode = nameNode;
                grpExpr.Name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.INVOKE);
                grpExpr.TypeArguments = BSYMMGR.EmptyTypeArray;
                grpExpr.SymKind = SYMKIND.METHSYM;
                grpExpr.ParentTypeSym = typeSym as AGGTYPESYM;
                grpExpr.MethPropSym = Compiler.MainSymbolManager.LookupInvokeMeth((typeSym as AGGTYPESYM).GetAggregate());
                grpExpr.ObjectExpr = expr;
                grpExpr.ContainingTypeArray = null;
                grpExpr.Flags |= EXPRFLAG.DELEGATE;

                return grpExpr;
            }

            // Not a delegate, so to try to get a better error message, rebind, allowing only a method.
            if (treeNode.IsAnyName)
            {
                expr = BindName(treeNode.AsANYNAME, SYMBMASK.METHSYM, BindFlagsEnum.RValueRequired);
            }
            else if (treeNode.Kind == NODEKIND.DOT)
            {
                expr = BindDot(treeNode.AsDOT, SYMBMASK.METHSYM, BindFlagsEnum.RValueRequired);
            }
            else
            {
                // No need to do this again!
                // expr = bindExpr(treeNode);
            }
            if (!expr.IsOK)
            {
                return expr;
            }

            // Some probably that rebinding didn't catch, so use the generic error message.
            Compiler.Error(treeNode, CSCERRID.ERR_MethodNameExpected);
            return NewError(treeNode, null);
        }

        //--------------------------------------------------
        // FUNCBREC.BindArrayInit
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="arrayTypeSym"></param>
        /// <param name="argListExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindArrayInit(UNOPNODE treeNode, ARRAYSYM arrayTypeSym, EXPR argListExpr)
        {
            EXPRARRINIT arrayInitExpr = NewExpr(treeNode, EXPRKIND.ARRINIT, arrayTypeSym) as EXPRARRINIT;
            arrayInitExpr.Flags |= EXPRFLAG.CANTBENULL;

            TYPESYM elementTypeSym = arrayTypeSym.ElementTypeSym;

            arrayInitExpr.DimSizes = new List<int>();
            while (arrayInitExpr.DimSizes.Count < arrayTypeSym.Rank)
            {
                arrayInitExpr.DimSizes.Add(-1);
            }

            // Get the sizes of all ranks.
            if (argListExpr != null)
            {
                EXPR tempExpr = argListExpr;
                int index = 0;
                while (tempExpr != null)
                {
                    EXPR argExpr;
                    if (tempExpr.Kind == EXPRKIND.LIST)
                    {
                        argExpr = (tempExpr as EXPRBINOP).Operand1;
                        tempExpr = (tempExpr as EXPRBINOP).Operand2;
                    }
                    else
                    {
                        argExpr = tempExpr;
                        tempExpr = null;
                    }

                    if (argExpr.Kind != EXPRKIND.CONSTANT)
                    {
                        Compiler.Error(argExpr.TreeNode, CSCERRID.ERR_ConstantExpected);
                    }
                    else
                    {
                        arrayInitExpr.DimSizes[index] = (argExpr as EXPRCONSTANT).ConstVal.GetInt();
                    }
                    ++index;
                }
            }

            bool isConstant =
                elementTypeSym.IsSimpleType() &&
                BSYMMGR.GetAttrArgSize(elementTypeSym.GetPredefType()) > 0;
            int nonConstCount = 0;  // the count of non-constants
            int constCount = 0;     // the count of non-zero constants
            EXPR lastList = null;   // (dummy) Last EXPR of the list from arrayInitExpr.ArgumentsExpr
            bool hasSideEffects = false;

            BindArrayInitList(
                treeNode,
                elementTypeSym,
                arrayTypeSym.Rank,
                arrayInitExpr.DimSizes,
                0,
                ref arrayInitExpr.ArgumentsExpr,
                ref lastList,
                ref nonConstCount,
                ref constCount,
                ref hasSideEffects);

            if (arrayInitExpr.DimSizes[0] == 0 && arrayTypeSym.Rank > 1)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_InvalidArray);
            }

#if false
            if (isConstant &&
                (constCount > 2) &&
                (constCount * 3 >= nonConstCount) &&
                methInfo != null &&
                !Compiler.FEncBuild())
            {
                arrayInitExpr.Flags |= ((nonConstCount == 0) && !hasSideEffects) ?
                    (EXPRFLAG.ARRAYALLCONST | EXPRFLAG.ARRAYCONST) :
                    EXPRFLAG.ARRAYCONST;

                if (Compiler.MainSymbolManager.InitArrayMethSym == null)
                {
                    AGGTYPESYM helperSym = this.GetOptionalPredefinedType(PREDEFTYPE.RUNTIMEHELPERS);
                    TypeArray paramsArray = Compiler.MainSymbolManager.AllocParams(
                            this.GetRequiredPredefinedType(PREDEFTYPE.ARRAY),
                            this.GetRequiredPredefinedType(PREDEFTYPE.FIELDHANDLE));

                    Compiler.MainSymbolManager.InitArrayMethSym = FindPredefMeth(
                        treeNode,
                        PREDEFNAME.INITIALIZEARRAY,
                        helperSym,
                        paramsArray,
                        true,
                        MemLookFlagsEnum.None);
                }
            }
#endif
            return SetNodeExpr(treeNode, arrayInitExpr);
        }

        //--------------------------------------------------
        // FUNCBREC.BindArrayInitList
        //
        /// <summary></summary>
        /// <param name="treeUnOpNode"></param>
        /// <param name="elementTypeSym"></param>
        /// <param name="rank"></param>
        /// <param name="dimList"></param>
        /// <param name="dimIndex"></param>
        /// <param name="exprList"></param>
        /// <param name="totCount"></param>
        /// <param name="constCount"></param>
        /// <param name="hasSideEffects"></param>
        //--------------------------------------------------
        private void BindArrayInitList(
            UNOPNODE treeUnOpNode,
            TYPESYM elementTypeSym,
            int rank,
            List<int> dimList,      //ref int size,
            int dimIndex,
            ref EXPR topArgList,	// EXPR *** ppList,
            ref EXPR lastArgList,	// EXPR *** ppList,
            ref int nonConstCount,
            ref int constCount,
            ref bool hasSideEffects)
        {
            int count = 0;

            BASENODE node = treeUnOpNode.Operand;
            while (node != null)
            {
                BASENODE itemNode;
                if (node.Kind == NODEKIND.LIST)
                {
                    itemNode = node.AsLIST.Operand1.AsBASE;
                    node = node.AsLIST.Operand2;
                }
                else
                {
                    itemNode = node.AsBASE;
                    node = null;
                }
                count++;

                if (rank == 1)
                {
                    EXPR expr = MustConvert(
                        BindExpr(itemNode, BindFlagsEnum.RValueRequired),
                        elementTypeSym,
                        0);
                    EXPR constExpr = expr.GetConst();
                    if (constExpr != null)
                    {
                        if (!constExpr.IsZero(true))
                        {
                            ++constCount;
                        }
                        if (expr.HasSideEffects(Compiler))
                        {
                            hasSideEffects = true;
                        }
                    }
                    else
                    {
                        nonConstCount++;
                    }
                    NewList(expr, ref topArgList, ref lastArgList);
                    //exprList.Add(expr);
                }
                else
                {
                    if (itemNode.Kind == NODEKIND.ARRAYINIT && itemNode.AsARRAYINIT.Operand != null)
                    {
                        BindArrayInitList(
                            itemNode.AsARRAYINIT,
                            elementTypeSym,
                            rank - 1,
                            dimList,
                            dimIndex + 1,
                            ref topArgList,
                            ref lastArgList,
                            ref nonConstCount,
                            ref constCount,
                            ref hasSideEffects);
                    }
                    else
                    {
                        compiler.Error(itemNode, CSCERRID.ERR_InvalidArray);
                    }
                }
            }

            if (dimList[dimIndex] != -1)
            {
                if (dimList[dimIndex] != count)
                {
                    Compiler.Error(treeUnOpNode, CSCERRID.ERR_InvalidArray);
                }
            }
            else
            {
                dimList[dimIndex] = count;
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindPossibleArrayInit
        //
        /// <summary>
        /// <para>Call BindExpr or BindArrayInit.</para>
        /// <para>In sscli, binfFlags has the default value 0.</para>
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="destinationType"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPossibleArrayInit(
            BASENODE tree,
            TYPESYM destinationType,
            BindFlagsEnum bindFlags)    // = 0
        {
            if (tree == null)
            {
                return null;
            }

            if (tree.Kind != NODEKIND.ARRAYINIT)
            {
                return BindExpr(tree, bindFlags | BindFlagsEnum.RValueRequired);
            }

            if (destinationType.IsARRAYSYM)
            {
                return BindArrayInit(tree.AsARRAYINIT, destinationType as ARRAYSYM, null);
            }

            // Not an array type.
            Compiler.Error(tree, CSCERRID.ERR_ArrayInitToNonArrayType);
            ARRAYSYM typeT = Compiler.MainSymbolManager.GetArray(
                GetRequiredPredefinedType(PREDEFTYPE.OBJECT), 1, null);
            BindArrayInit(tree.AsARRAYINIT, typeT, null);
            return NewError(tree, destinationType);
        }

        //--------------------------------------------------
        // FUNCBREC.BindPossibleArrayInitAssg
        //
        /// <summary>
        /// <para>Bind an assignment including an array initialization.</para>
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="type"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPossibleArrayInitAssg(
            BINOPNODE tree,
            TYPESYM type,
            BindFlagsEnum bindFlags)	// = 0
        {
            if (tree == null)
            {
                return null;
            }

            EXPR op1 = BindExpr(
                tree.Operand1,
                BindFlagsEnum.MemberSet | (bindFlags & BindFlagsEnum.UsingValue));
            EXPR op2 = BindPossibleArrayInit(tree.Operand2, type, bindFlags);

            // CS3
            if (type.IsIMPLICITTYPESYM && op2 != null)
            {
                TYPESYM rhsTypeSym = op2.TypeSym;
                SYMKIND rhsKind = rhsTypeSym.Kind;

                if (rhsKind == SYMKIND.NULLSYM ||
                    rhsKind == SYMKIND.METHGRPSYM ||
                    rhsKind == SYMKIND.ANONMETHSYM ||
                    rhsKind == SYMKIND.LAMBDAEXPRSYM||
                    rhsKind==SYMKIND.IMPLICITTYPESYM)
                {
                    string eargStr = null;
                    switch (rhsTypeSym.Kind)
                    {
                        case SYMKIND.NULLSYM:
                            eargStr = "null";
                            break;

                        case SYMKIND.METHGRPSYM:
                            eargStr = "method group";
                            break;

                        case SYMKIND.ANONMETHSYM:
                            eargStr = "anonymous function";
                            break;

                        case SYMKIND.LAMBDAEXPRSYM:
                            eargStr = "lambda expression";
                            break;

                        case SYMKIND.IMPLICITTYPESYM:
                            eargStr = "implicit type";
                            break;

                        default:
                            break;
                    }
                    Compiler.Error(tree, CSCERRID.ERR_CannotAssignToImplicitType, new ErrArg(eargStr));
                    //return SetNodeExpr(tree, NewError(tree, rhsTypeSym));
                    return null;
                }
                else
                {
                    EXPRLOCAL locExpr = op1 as EXPRLOCAL;
                    DebugUtil.Assert(locExpr != null);

                    if (op2 != null && op2.TypeSym != null)
                    {
                        type = op2.TypeSym;
                        op1.TypeSym = type;
                        locExpr.TypeSym = type;
                        locExpr.LocVarSym.TypeSym = type;
                    }
                    else
                    {
                        //return SetNodeExpr(tree, NewError(tree, type));
                        return null;
                    }
                }
            }

            if ((op1 != null && !op1.IsOK) || (op2 != null && !op2.IsOK))
            {
                return SetNodeExpr(tree, NewError(tree, type));
            }

            return SetNodeExpr(tree, BindAssignment(tree, op1, op2, false));
        }

        //--------------------------------------------------
        // FUNCBREC.BindConstInitializer
        //
        /// <summary>
        /// Bind a const initializer. The value of the initializer must
        /// be implicitly converted to the constant type.
        /// </summary>
        /// <param name="fieldSym"></param>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindConstInitializer(MEMBVARSYM fieldSym, BASENODE treeNode)
        {
            CHECKEDCONTEXT checkedContext = new CHECKEDCONTEXT(this, Compiler.GetCheckedMode());
            this.CheckedContext.IsConstant = true;

            EXPR rval = null;
            if (treeNode.Kind == NODEKIND.ARRAYINIT && fieldSym.TypeSym.IsARRAYSYM)
            {
                // special case binding of array initializer here.  It is not legal to have an initializer for a
                // constant array, but we need to avoid generating the error deep inside bindExpr and instead
                // allow the caller to generate the appropriate error when it discovers that the initializer
                // expression is not actually constant.
                rval = BindArrayInit(treeNode.AsARRAYINIT, fieldSym.TypeSym as ARRAYSYM, null);
            }
            else
            {
                // Just bind the expression...
                rval = BindExpr(treeNode, BindFlagsEnum.RValueRequired);
            }

            checkedContext.Restore(this);

            // Convert to the correct destination type
            if (fieldSym.ParentSym.IsAGGSYM && fieldSym.ClassSym.IsEnum)
            {
                // enumerator must be of correct type.
                DebugUtil.Assert(fieldSym.TypeSym == fieldSym.ClassSym.GetThisType());

                // Enumerator fields are handled somewhat special. The initializer
                // must be convertable to the *underlying* type of the enum.
                rval = MustConvert(rval, fieldSym.TypeSym.UnderlyingType(), 0);
            }
            else if (fieldSym.FixedAggSym != null)
            {
                // Fixed-sized buffer length.
                rval = MustConvert(rval, this.GetRequiredPredefinedType(PREDEFTYPE.INT), 0);
                if (rval.Kind == EXPRKIND.CONSTANT && (rval as EXPRCONSTANT).GetI64Value() <= 0)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_InvalidFixedArraySize);
                    // No need to cascade errors
                    (rval as EXPRCONSTANT).ConstVal.SetInt(0);
                }
            }
            else
            {
                // Regular const field.
                rval = MustConvert(rval, fieldSym.TypeSym, 0);
            }

            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.BindLock
        //
        /// <summary></summary>
        /// <param name="loopStmtNode"></param>
        /// <param name="builder"></param>
        //--------------------------------------------------
        private void BindLock(LOOPSTMTNODE loopStmtNode, StatementListBuilder builder)
        {
            DebugUtil.Assert(loopStmtNode != null && loopStmtNode.ExpressionNode != null);

            EXPR argExpr = BindExpr(loopStmtNode.ExpressionNode, BindFlagsEnum.RValueRequired);
            EXPR origExpr = argExpr;
            EXPR wrapExpr = null;
            EXPRTRY tryExpr = null;

            if (argExpr.IsOK)
            {
                switch (argExpr.TypeSym.FundamentalType())
                {
                    case FUNDTYPE.VAR:
                        // Box first so we enter and exit the same object.
                        argExpr = MustConvert(argExpr, GetPDOT(), ConvertTypeEnum.NOUDC);
                        // Fall through.
                        goto case FUNDTYPE.REF;

                    case FUNDTYPE.REF:
                        wrapExpr = NewExprWrap(argExpr, TEMP_KIND.LOCK);
                        wrapExpr.Flags |= EXPRFLAG.WRAPASTEMP;
                        argExpr = NewExprBinop(argExpr.TreeNode, EXPRKIND.SAVE, argExpr.TypeSym, argExpr, wrapExpr);

                        tryExpr = NewExpr(loopStmtNode, EXPRKIND.TRY, null) as EXPRTRY;
                        tryExpr.Flags |= EXPRFLAG.ISFINALLY;
                        break;

                    default:
                        Compiler.Error(loopStmtNode, CSCERRID.ERR_LockNeedsReference, new ErrArg(argExpr.TypeSym));
                        argExpr = NewError(argExpr.TreeNode, null);
                        break;
                }

            }

            this.finallyNestingCount++;
            OnLockOrDisposeEnter(origExpr);

            SCOPESYM scopeSym = null;
            EXPR bodyExpr = BindBlock(
                loopStmtNode.StatementNode,
                SCOPEFLAGS.TRYSCOPE | SCOPEFLAGS.LAZYFINALLY,
                ref scopeSym,
                null);

            OnLockOrDisposeExit(origExpr);
            finallyNestingCount--;

            if (!argExpr.IsOK)
            {
                return;
            }

            tryExpr.TryBlockExpr = bodyExpr as EXPRBLOCK;

            EXPR callExpr = BindPredefMethToArgs(
                loopStmtNode,
                PREDEFNAME.EXIT,
                GetOptionalPredefinedType(PREDEFTYPE.CRITICAL),
                null,
                wrapExpr,
                null);
            if (!callExpr.IsOK)
            {
                return;
            }

            bodyExpr = NewExprBlock(loopStmtNode);
            (bodyExpr as EXPRBLOCK).StatementsExpr = MakeStmt(null, callExpr, EXPRFLAG.NODEBUGINFO);
            CreateNewScope();
            this.currentScopeSym.ScopeFlags = SCOPEFLAGS.FINALLYSCOPE;
            (bodyExpr as EXPRBLOCK).ScopeSym = this.currentScopeSym;
            this.currentScopeSym.BlockExpr = bodyExpr as EXPRBLOCK;
            CloseScope();

            tryExpr.HandlersExpr = bodyExpr as EXPRBLOCK;

            callExpr = BindPredefMethToArgs(
                loopStmtNode,
                PREDEFNAME.ENTER,
                GetOptionalPredefinedType(PREDEFTYPE.CRITICAL),
                null,
                argExpr,
                null);
            if (!callExpr.IsOK)
            {
                return;
            }

            builder.Add(MakeStmt(loopStmtNode, callExpr, 0));
            builder.Add(SetNodeStmt(loopStmtNode, tryExpr));
        }

        //--------------------------------------------------
        // FUNCBREC.OnLockOrDisposeEnter
        //
        /// <summary></summary>
        /// <param name="arg"></param>
        //--------------------------------------------------
        private void OnLockOrDisposeEnter(EXPR arg)
        {
            if (arg.Kind == EXPRKIND.LOCAL)
            {
                (arg as EXPRLOCAL).LocVarSym.IsLockOrDisposeTargetCount++;
            }
        }

        //--------------------------------------------------
        // FUNCBREC.OnLockOrDisposeExit
        //
        /// <summary></summary>
        /// <param name="arg"></param>
        //--------------------------------------------------
        private void OnLockOrDisposeExit(EXPR arg)
        {
            if (arg.Kind == EXPRKIND.LOCAL)
            {
                DebugUtil.Assert((arg as EXPRLOCAL).LocVarSym.IsLockOrDisposeTargetCount > 0);
                (arg as EXPRLOCAL).LocVarSym.IsLockOrDisposeTargetCount--;
            }
        }

        //--------------------------------------------------
        // FUNCBREC.OnPossibleAssignmentToArg
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="arg"></param>
        //--------------------------------------------------
        private void OnPossibleAssignmentToArg(BASENODE tree, EXPR arg)
        {
            if (arg.Kind == EXPRKIND.LOCAL)
            {
                LOCVARSYM local = (arg as EXPRLOCAL).LocVarSym;
                DebugUtil.Assert(local.IsLockOrDisposeTargetCount >= 0);
                if (local.IsLockOrDisposeTargetCount > 0)
                {
                    Compiler.Error(tree, CSCERRID.WRN_AssignmentToLockOrDispose, new ErrArg(local));
                }
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindIndexer
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="expr"></param>
        /// <param name="argsExpr"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindIndexer(
            BASENODE treeNode,
            EXPR expr,
            EXPR argsExpr,
            BindFlagsEnum bindFlags)
        {
            string name;
            TYPESYM typeSym = expr.TypeSym;

            if (!typeSym.IsAGGTYPESYM && !typeSym.IsTYVARSYM)
            {
                Compiler.Error(treeNode, CSCERRID.ERR_BadIndexLHS, new ErrArg(typeSym));
                return NewError(treeNode, null);
            }

            name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.INDEXERINTERNAL);

            MemberLookup mem = new MemberLookup();
            if (!mem.Lookup(
                Compiler,
                typeSym,
                expr,
                this.parentDeclSym,
                name,
                0,
                (bindFlags & BindFlagsEnum.BaseCall) != 0 ?
                    (MemLookFlagsEnum.BaseCall | MemLookFlagsEnum.Indexer) : MemLookFlagsEnum.Indexer))
            {
                mem.ReportErrors(treeNode);
                return NewError(treeNode, null);
            }
            mem.ReportWarnings(treeNode);
            DebugUtil.Assert(mem.FirstSym.IsPROPSYM && (mem.FirstSym as PROPSYM).IsIndexer);
            EXPRMEMGRP grp = NewExprMemGrp(treeNode, treeNode, mem);
            return BindGrpToArgs(treeNode, bindFlags, grp, argsExpr);
        }

        //--------------------------------------------------
        // FUNCBREC.bindBase
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindBase(BASENODE treeNode)
        {
            EXPR rval = BindThisCore(treeNode, EXPRFLAG.CANTBENULL);

            if (rval == null)
            {
                if (this.methodSym != null && this.methodSym.IsStatic)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_BaseInStaticMeth);
                }
                else
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_BaseInBadContext);
                    // 'this' isn't available for some other reason.
                }
                return NewError(treeNode, this.parentAggSym != null ? this.parentAggSym.BaseClassSym : null);
            }
            DebugUtil.Assert((rval.Flags & EXPRFLAG.IMPLICITTHIS) == 0);

            TYPESYM type = rval.TypeSym;
            if (type.IsNUBSYM)
            {
                type = (type as NUBSYM).GetAggTypeSym();
                DebugUtil.Assert(type != null);
            }

            AGGTYPESYM baseType = (type as AGGTYPESYM).GetBaseClass();
            if (baseType != null)
            {
                rval = TryConvert(rval, baseType, 0);
                DebugUtil.Assert(rval != null);
            }
            else
            {
                Compiler.Error(treeNode, CSCERRID.ERR_NoBaseClass);
            }

            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.GetExpandedParams
        //
        /// <summary>
        /// Create a TypeArray instance which expands paramArray up to count.
        /// </summary>
        /// <param name="paramArray"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private TypeArray GetExpandedParams(TypeArray paramArray, int count)
        {
            DebugUtil.Assert(count >= paramArray.Count - 1);

            //TYPESYM ** typeList = STACK_ALLOC(TYPESYM *, count);
            List<TYPESYM> typeList = new List<TYPESYM>();
            paramArray.CopyItems(0, paramArray.Count - 1, typeList);

            TYPESYM typeSym = (paramArray[paramArray.Count - 1] as ARRAYSYM).ElementTypeSym;

            for (int itype = paramArray.Count - 1; itype < count; itype++)
            {
                typeList.Add(typeSym);
            }

            return Compiler.MainSymbolManager.AllocParams(typeList);
        }

        //--------------------------------------------------
        // FUNCBREC.NoteReference
        //
        /// <summary>
        /// Set IsReferenced flag of EXPR op and
        /// decrement the count of unreferenced local variables.
        /// </summary>
        /// <param name="op"></param>
        //--------------------------------------------------
        private void NoteReference(EXPR op)
        {
            MEMBVARSYM field;

            if (op.Kind == EXPRKIND.LOCAL &&
                !(op as EXPRLOCAL).LocVarSym.LocSlotInfo.IsReferenced)
            {
                (op as EXPRLOCAL).LocVarSym.LocSlotInfo.IsReferenced = true;
                this.unreferencedVarCount--;
            }
            else if (
                op.Kind == EXPRKIND.FIELD &&
                !(field = (op as EXPRFIELD).FieldWithType.FieldSym).IsReferenced)
            {
                field.IsReferenced = true;
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindAttributeValue
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindAttributeValue(BASENODE treeNode)
        {
            CHECKEDCONTEXT context = new CHECKEDCONTEXT(this, Compiler.GetCheckedMode());
            this.CheckedContext.IsConstant = true;

            EXPR expr = BindExpr(treeNode, BindFlagsEnum.RValueRequired);

            context.Restore(this);
            return expr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindNamedAttributeValue
        //
        /// <summary></summary>
        /// <param name="attrTypeSym"></param>
        /// <param name="attrNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindNamedAttributeValue(AGGTYPESYM attrTypeSym, ATTRNODE attrNode)
        {
            // bind name to public non-readonly field or property

            string name = (attrNode.NameNode as NAMENODE).Name;
            TYPESYM typeSym = null;
            AGGTYPESYM searchAggTypeSym = attrTypeSym;
            bool badModifiers = false;
            bool badType = false;
            bool badSymbol = false;

            MemberLookup mem = new MemberLookup();
            if (!mem.Lookup(
                Compiler,
                searchAggTypeSym,
                null,
                this.parentDeclSym,
                name,
                0,
                MemLookFlagsEnum.UserCallable))
            {
                mem.ReportErrors(attrNode);
                return null;
            }
            mem.ReportWarnings(attrNode);

            SymWithType swt = mem.FirstSymWithType;

            if (swt.Sym is MEMBVARSYM)
            {
                if (swt.Sym.Access != ACCESS.PUBLIC ||
                    swt.FieldSym.IsReadOnly ||
                    swt.FieldSym.IsStatic ||
                    swt.FieldSym.IsConst)
                {
                    badModifiers = true;
                }
                else
                {
                    if (!Compiler.ClsDeclRec.IsAttributeType(swt.FieldSym.TypeSym))
                    {
                        badType = true;
                    }
                    else
                    {
                        typeSym = swt.FieldSym.TypeSym;
                        swt.FieldSym.IsAssigned = true;
                    }
                }
            }
            else if (swt.Sym is PROPSYM)
            {
                DebugUtil.Assert(!swt.PropSym.IsIndexer);

                // check modifiers on property and accessors.  Both accessors must exist and be public.
                // This may be called before we create the accessor methods though,
                // so we also have to check the parsetree as well.
                if (swt.PropSym.Access != ACCESS.PUBLIC ||
                    swt.PropSym.IsStatic)
                {
                    badModifiers = true;
                }
                else
                {
                    if (swt.PropSym.SetMethodSym != null)
                    {
                        if (swt.PropSym.SetMethodSym.Access != ACCESS.PUBLIC)
                        {
                            badModifiers = true;
                        }
                    }
                    else if (
                        swt.PropSym.ParseTreeNode == null ||
                        swt.PropSym.ParseTreeNode.AsANYPROPERTY.SetNode == null ||
                        (swt.PropSym.ParseTreeNode.AsANYPROPERTY.GetNode.Flags & NODEFLAGS.MOD_ACCESSMODIFIERS) != 0 &&
                        (swt.PropSym.ParseTreeNode.AsANYPROPERTY.SetNode.Flags & NODEFLAGS.MOD_PUBLIC) == 0)
                    {
                        badModifiers = true;
                    }

                    if (swt.PropSym.GetMethodSym != null)
                    {
                        if (swt.PropSym.GetMethodSym != null && swt.PropSym.GetMethodSym.Access != ACCESS.PUBLIC)
                        {
                            badModifiers = true;
                        }
                    }
                    else if (
                        swt.PropSym.ParseTreeNode == null ||
                        swt.PropSym.ParseTreeNode.AsANYPROPERTY.GetNode == null ||
                        (swt.PropSym.ParseTreeNode.AsANYPROPERTY.GetNode.Flags & NODEFLAGS.MOD_ACCESSMODIFIERS) != 0 &&
                        (swt.PropSym.ParseTreeNode.AsANYPROPERTY.GetNode.Flags & NODEFLAGS.MOD_PUBLIC) == 0)
                    {
                        badModifiers = true;
                    }
                }

                if (!badModifiers)
                {
                    if (!Compiler.ClsDeclRec.IsAttributeType(swt.PropSym.ReturnTypeSym))
                    {
                        badType = true;
                    }
                    else
                    {
                        typeSym = swt.PropSym.ReturnTypeSym;
                    }
                }
            }
            else
            {
                badSymbol = true;
            }

            if (typeSym == null)
            {
                // didn't find an accessible field
                // report what we did find ...

                Compiler.ErrorRef(attrNode.NameNode,
                    badType ? CSCERRID.ERR_BadNamedAttributeArgumentType : CSCERRID.ERR_BadNamedAttributeArgument,
                    new ErrArgNameNode(attrNode.NameNode, ErrArgFlagsEnum.None),
                    new ErrArgRef(swt));

                return null;
            }

            if (swt.Sym.IsDeprecated())
            {
                ReportDeprecated(attrNode, swt);
            }

            // bind value

            EXPR valueExpr = BindAttributeValue(attrNode.ArgumentsNode);
            if (valueExpr == null || !valueExpr.IsOK)
            {
                return null;
            }
            valueExpr = MustConvert(valueExpr, typeSym, 0);
            if (valueExpr == null || !valueExpr.IsOK)
            {
                return null;
            }

            // package it up as an assignment

            EXPR opExpr1;
            if (swt.Sym.IsMEMBVARSYM)
            {
                opExpr1 = NewExpr(attrNode.NameNode, EXPRKIND.FIELD, typeSym);
                (opExpr1 as EXPRFIELD).FieldWithType = swt as FieldWithType;
            }
            else
            {
                DebugUtil.Assert(swt.Sym is PROPSYM);
                PROPSYM propSym = swt.Sym as PROPSYM;
                opExpr1 = NewExpr(attrNode.NameNode, EXPRKIND.PROP, typeSym);
                (opExpr1 as EXPRPROP).SlotPropWithType.Set(propSym, swt.AggTypeSym);
                if (propSym.GetMethodSym!=null)
                {
                    (opExpr1 as EXPRPROP).GetMethodWithType.Set(propSym.GetMethodSym, swt.AggTypeSym);
                }
                if (propSym.SetMethodSym != null)
                {
                    (opExpr1 as EXPRPROP).SetMethodWithType.Set(propSym.SetMethodSym, swt.AggTypeSym);
                }
            }
            return SetNodeExpr(
                attrNode,
                NewExprBinop(attrNode, EXPRKIND.ASSG, opExpr1.TypeSym, opExpr1, valueExpr));
        }

        //--------------------------------------------------
        // FUNCBREC.BindAttrArgs
        //
        /// <summary>
        /// <para>Returns the positional parameter list.
        /// The named parameter list is set to firstNamedArg and lastNamedArg.</para>
        /// </summary>
        /// <param name="attrAggTypeSym"></param>
        /// <param name="attrNode"></param>
        /// <param name="firstNamedArg"></param>
        /// <param name="lastNamedArg"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindAttrArgs(
            AGGTYPESYM attrAggTypeSym,
            ATTRNODE attrNode,
            ref EXPR firstNamedArg,
            ref EXPR lastNamedArg) //EXPR** namedArgs)
        {
            //EXPR *rval = null;
            //EXPR ** prval = &rval;
            EXPR expr = null;
            EXPR firstArgExpr = null;
            EXPR lastArgExpr = null;

            BASENODE nd1 = attrNode.ArgumentsNode;
            while (nd1 != null)
            {
                BASENODE node;
                if (nd1.Kind == NODEKIND.LIST)
                {
                    node = nd1.AsLIST.Operand1.AsBASE;
                    nd1 = nd1.AsLIST.Operand2;
                }
                else
                {
                    node = nd1.AsBASE;
                    nd1 = null;
                }

                ATTRNODE argNode = node.AsATTRARG;

                if (argNode.NameNode != null)
                {
                    // check for duplicate named argument

                    BASENODE nd2 = attrNode.ArgumentsNode;
                    while (nd2 != null)
                    {
                        BASENODE innerNode;
                        if (nd2.Kind == NODEKIND.LIST)
                        {
                            innerNode = nd2.AsLIST.Operand1.AsBASE;
                            nd2 = nd2.AsLIST.Operand2;
                        }
                        else
                        {
                            innerNode = nd2.AsBASE;
                            nd2 = null;
                        }

                        ATTRNODE innerArgNode = innerNode.AsATTRARG;
                        if (innerArgNode.NameNode != null)
                        {
                            if ((innerArgNode.NameNode as NAMENODE).Name == (argNode.NameNode as NAMENODE).Name)
                            {
                                if (innerArgNode == argNode)
                                {
                                    break;
                                }
                                else
                                {
                                    Compiler.Error(
                                        argNode,
                                        CSCERRID.ERR_DuplicateNamedAttributeArgument,
                                        new ErrArg((argNode.NameNode as NAMENODE).Name));
                                }
                            }
                        }
                    }

                    expr = BindNamedAttributeValue(attrAggTypeSym, argNode);
                    if (expr != null)
                    {
                        NewList(expr, ref firstNamedArg, ref lastNamedArg);
                    }
                }
                else	// if (argNode.NameNode!=null)
                {
                    expr = BindAttributeValue(argNode.ArgumentsNode);
                    NewList(expr, ref firstArgExpr, ref lastArgExpr);
                }
            }

            return firstArgExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.BindMakeRefAny
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="op"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindMakeRefAny(BASENODE tree, EXPR op)
        {
            AGGTYPESYM refAnyAts = GetOptionalPredefinedType(PREDEFTYPE.REFANY);

            if (!CheckLvalue(op, true))
            {
                return NewError(tree, refAnyAts);
            }

            if (op.TypeSym.IsSpecialByRefType())
            {
                Compiler.Error(op.TreeNode, CSCERRID.ERR_MethodArgCantBeRefAny, new ErrArg(op.TypeSym));
                return NewError(tree, refAnyAts);
            }

            CheckFieldRef(op);

            if (refAnyAts == null)
            {
                return NewError(tree, null);
            }

            return NewExprBinop(tree, EXPRKIND.MAKERA, refAnyAts, op, null);
        }

        //--------------------------------------------------
        // FUNCBREC.bindRefType
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="op"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindRefType(BASENODE tree, EXPR op)
        {
            AGGTYPESYM refAnyAts = GetOptionalPredefinedType(PREDEFTYPE.REFANY);
            TYPESYM typeSym = GetOptionalPredefinedType(PREDEFTYPE.TYPE);

            if (refAnyAts == null)
            {
                return NewError(tree, typeSym);
            }
            op = MustConvert(op, refAnyAts, 0);
            if (!op.IsOK)
            {
                return NewError(tree, typeSym);
            }

            EXPR rval = NewExpr(tree, EXPRKIND.TYPEOF, typeSym) as EXPRTYPEOF;

            // this is a dummy, we will instead use the type of the refany to load...
            (rval as EXPRTYPEOF).SourceTypeSym = GetRequiredPredefinedType(PREDEFTYPE.OBJECT);

            if (!FixupTypeOfExpr(tree, rval as EXPRTYPEOF))
            {
                return NewError(tree, typeSym);
            }

            rval = NewExprBinop(tree, EXPRKIND.TYPERA, typeSym, op, rval);

            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.BindRefValue
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindRefValue(BINOPNODE treeNode)
        {
            EXPR ranyExpr = BindExpr(treeNode.Operand1, BindFlagsEnum.RValueRequired);
            TYPESYM typeSym = BindType(treeNode.Operand2.AsANYTYPE);
            DebugUtil.Assert(typeSym != null);

            AGGTYPESYM atsRefAny = this.GetOptionalPredefinedType(PREDEFTYPE.REFANY);
            if (!ranyExpr.IsOK || typeSym.IsERRORSYM || atsRefAny == null)
            {
                return NewError(treeNode, typeSym);
            }

            ranyExpr = MustConvert(ranyExpr, atsRefAny, 0);

            EXPR rval = NewExprBinop(treeNode, EXPRKIND.VALUERA, typeSym, ranyExpr, NewExpr(EXPRKIND.TYPEOF));
            (rval.AsBIN.Operand2 as EXPRTYPEOF).SourceTypeSym = typeSym;
            rval.Flags |= EXPRFLAG.ASSGOP | EXPRFLAG.LVALUE;
            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.BindPtrIndirection
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="op"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPtrIndirection(UNOPNODE tree, EXPR op)
        {
            // In the EE:
            // class Foo ...
            // Foo f = ...
            // &f is the address of the local f (its location on the stack(
            // *f is the address of the object referenced by f (the actual hidden value of f)
            // &f has type Foo** which means it can be indirected once to get Foo*
            // *f has type Foo* which means that it can not be indirected
            // *f is not an lvalue
            // &f is not an lvalue
            // you can say *&f which gives you Foo*
            // you cannot say &*f as *f is not an lvalue

            if (!op.TypeSym.IsPTRSYM)
            {
                Compiler.Error(tree, CSCERRID.ERR_PtrExpected);
                return NewError(tree, null);
            }

            TYPESYM typeBase = (op.TypeSym as PTRSYM).BaseTypeSym;

            if (typeBase == this.GetVoidType())
            {
                Compiler.Error(tree, CSCERRID.ERR_VoidError);
                return NewError(tree, typeBase);
            }

            EXPR rval = NewExprBinop(tree, EXPRKIND.INDIR, typeBase, op, null);
            rval.Flags |= EXPRFLAG.ASSGOP | EXPRFLAG.LVALUE;
            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.BindPtrAddr
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="expr"></param>
        /// <param name="bindFlags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPtrAddr(UNOPNODE treeNode, EXPR expr, BindFlagsEnum bindFlags)
        {
            CheckUnsafe(treeNode, null, CSCERRID.ERR_UnsafeNeeded, null);

            switch (expr.Kind)
            {
                case EXPRKIND.ANONMETH:
                case EXPRKIND.MEMGRP:
                case EXPRKIND.LAMBDAEXPR:   // CS3
                    Compiler.Error(treeNode, CSCERRID.ERR_InvalidAddrOp);
                    return NewError(treeNode, null);

                case EXPRKIND.FIELD:
                    CheckFieldRef(expr);
                    MarkFieldAssigned(expr);
                    break;

                default:
                    break;
            }

            LOCVARSYM localSym = null;
            bool needsFixing = !IsFixedExpression(expr, out localSym);
            bool skipFixedErrors = false;

            if (IsManagedType(expr.TypeSym))
            {
                Compiler.Error(treeNode, CSCERRID.ERR_ManagedAddr, new ErrArg(expr.TypeSym));
                // Prevent reporting cascading errors
                skipFixedErrors = true;
            }

            if (expr.IsOK && (expr.Flags & EXPRFLAG.LVALUE) == 0 || !IsAddressable(expr))
            {
                Compiler.Error(
                    treeNode,
                    expr.Kind == EXPRKIND.LOCAL ? CSCERRID.ERR_AddrOnReadOnlyLocal : CSCERRID.ERR_InvalidAddrOp);
                // Prevent reporting cascading errors
                skipFixedErrors = true;
            }

            if (!skipFixedErrors && needsFixing != ((bindFlags & BindFlagsEnum.FixedValue) != 0))
            {
                Compiler.Error(treeNode, !needsFixing ? CSCERRID.ERR_FixedNotNeeded : CSCERRID.ERR_FixedNeeded);
            }

            if (!skipFixedErrors && !needsFixing && localSym != null)
            {
                // a lo^cal doesn't need fixing unless it might get hoisted into an anonymous delegate
                if (localSym.UsedInAnonMeth)
                {
                    if (localSym.NodeUsedInAnonMethod != null)
                    {
                        Compiler.Error(
                            treeNode,
                            CSCERRID.ERR_LocalCantBeFixedAndHoisted,
                            new ErrArg(localSym),
                            new ErrArgRefOnly(localSym.NodeUsedInAnonMethod));
                    }
                    else
                    {
                        Compiler.Error(treeNode, CSCERRID.ERR_LocalCantBeFixedAndHoisted, new ErrArg(localSym));
                    }
                }
                else
                {
                    DebugUtil.Assert(treeNode != null);
                    if (localSym.AddressTakenNode == null)
                    {
                        localSym.AddressTakenNode = treeNode;
                    }
                }
            }

            SetExternalRef(expr.TypeSym);

            TYPESYM desiredType = Compiler.MainSymbolManager.GetPtrType(expr.TypeSym);
            EXPR rval = NewExprBinop(treeNode, EXPRKIND.ADDR, desiredType, expr, null);

            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.BindLocAlloc
        //
        /// <summary></summary>
        /// <param name="newTreeNode"></param>
        /// <param name="ptrSym"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindLocAlloc(NEWNODE newTreeNode, PTRSYM ptrSym)
        {
            CheckUnsafe(newTreeNode, null, CSCERRID.ERR_UnsafeNeeded, null);

            if (this.innermostCatchScopeSym != this.OuterScopeSym ||
                this.innermostFinallyScopeSym != this.OuterScopeSym)
            {
                Compiler.Error(newTreeNode, CSCERRID.ERR_StackallocInCatchFinally);
            }

            EXPR argExpr = BindExpr(newTreeNode.ArgumentsNode, BindFlagsEnum.RValueRequired);
            if (argExpr == null)
            {
                DebugUtil.Assert(Compiler.ErrorCount() > 0);
                return NewError(newTreeNode, ptrSym);
            }

            argExpr = MustConvert(argExpr, this.GetRequiredPredefinedType(PREDEFTYPE.INT), 0);

            CheckNegativeConstant(
                newTreeNode.ArgumentsNode,
                argExpr,
                CSCERRID.ERR_NegativeStackAllocSize);

            argExpr = NewExprBinop(
                null,
                EXPRKIND.MUL,
                this.GetRequiredPredefinedType(PREDEFTYPE.INT),
                BindSizeOf(null, ptrSym.BaseTypeSym),
                argExpr);

            if (this.CheckedContext.IsNormal)
            {
                argExpr.Flags |= EXPRFLAG.CHECKOVERFLOW;
            }

            EXPR rval = NewExprBinop(newTreeNode, EXPRKIND.LOCALLOC, ptrSym, argExpr, null);
            rval.Flags |= EXPRFLAG.ASSGOP;
            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.BindPtrArrayIndexer
        //--------------------------------------------------
        private EXPR BindPtrArrayIndexer(
            BINOPNODE binOpTreeNode,
            EXPR arrOpExpr,
            EXPR indexOpExpr)
        {
            DebugUtil.Assert(arrOpExpr.TypeSym.IsPTRSYM);
            TYPESYM typeSym = (arrOpExpr.TypeSym as PTRSYM).BaseTypeSym;

            if (indexOpExpr.Kind == EXPRKIND.LIST)
            {
                Compiler.Error(binOpTreeNode, CSCERRID.ERR_PtrIndexSingle);
                return NewError(binOpTreeNode, typeSym);
            }
            if (typeSym == this.GetVoidType())
            {
                Compiler.Error(binOpTreeNode, CSCERRID.ERR_VoidError);
                return NewError(binOpTreeNode, null);
            }

            TYPESYM indexTypeSym = ChooseArrayIndexType(binOpTreeNode, indexOpExpr);

            if (indexTypeSym == null)
            {
                // using int as the ty^pe will allow us to give a better error...
                indexTypeSym = GetRequiredPredefinedType(PREDEFTYPE.INT);
            }

            indexOpExpr = MustConvert(indexOpExpr, indexTypeSym, 0);
            if (!indexOpExpr.IsOK)
            {
                return NewError(binOpTreeNode, typeSym);
            }

            EXPR sizeExpr = BindSizeOf(binOpTreeNode, typeSym);

            EXPR addExpr = BindPtrAddMul(
                binOpTreeNode,
                arrOpExpr,
                indexOpExpr,
                sizeExpr,
                true,
                EXPRKIND.ADD);
            EXPR rval = NewExprBinop(binOpTreeNode, EXPRKIND.INDIR, typeSym, addExpr, null);
            rval.Flags |= EXPRFLAG.LVALUE | EXPRFLAG.ASSGOP;

            return rval;
        }

        //--------------------------------------------------
        // FUNCBREC.BindPtrMul
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="timesExpr"></param>
        /// <param name="sizeExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPtrMul(BASENODE treeNode, EXPR timesExpr, EXPR sizeExpr)
        {
            if (timesExpr != null)
            {
                if (timesExpr.TypeSym.IsPredefType(PREDEFTYPE.ULONG))
                {
                    sizeExpr = MustCast(sizeExpr, timesExpr.TypeSym,0);
                }

                bool isUserDef = false;             //dummy
                NubInfo nubInfo = new NubInfo();    //dummy
                EXPR mulResultExpr = BindStdBinOp(
                    treeNode,
                    EXPRKIND.MUL,
                    timesExpr,
                    sizeExpr,
                    ref isUserDef,
                    ref nubInfo);

                if (mulResultExpr.Kind == EXPRKIND.MUL &&
                    !mulResultExpr.TypeSym.IsPredefType(PREDEFTYPE.LONG) &&
                    !mulResultExpr.TypeSym.IsPredefType(PREDEFTYPE.ULONG))
                {
                    // this multiplication needs to be done as natural ints, but since a int * natint = natint,
                    // we only need to promote one side
                    mulResultExpr.AsBIN.Operand1 = BindCastToNatural(mulResultExpr.AsBIN.Operand1);
                    mulResultExpr.TypeSym = mulResultExpr.AsBIN.Operand1.TypeSym;
                    return mulResultExpr;
                }
                else if (mulResultExpr.Kind == EXPRKIND.CONSTANT)
                {
                    return BindCastToNatural(mulResultExpr);
                }
                else
                {
                    return mulResultExpr;
                }
            }
            else
            {
                return BindCastToNatural(sizeExpr);
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindPtrAddMul
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="ptrExpr"></param>
        /// <param name="timesExpr"></param>
        /// <param name="sizeExpr"></param>
        /// <param name="isFirstPtr"></param>
        /// <param name="kind"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindPtrAddMul(
            BASENODE treeNode,
            EXPR ptrExpr,
            EXPR timesExpr,
            EXPR sizeExpr,
            bool isFirstPtr,	// = true
            EXPRKIND kind)	// = EXPRKIND.ADD
        {
            EXPR resMulExpr = BindPtrMul(treeNode, timesExpr, sizeExpr);
            EXPR tempExpr = resMulExpr;
            while (tempExpr != null && tempExpr.Kind == EXPRKIND.CAST)
            {
                tempExpr = (tempExpr as EXPRCAST).Operand;
            }
            if (tempExpr != null && tempExpr.IsZero(false))
            {
                return ptrExpr;
            }
            if (resMulExpr.IsOK &&
                (resMulExpr.TypeSym.IsPredefType(PREDEFTYPE.LONG) ||
                resMulExpr.TypeSym.IsPredefType(PREDEFTYPE.ULONG)))
            {
                resMulExpr = BindCastToNatural(resMulExpr);
            }
            if (isFirstPtr)
            {
                return NewExprBinop(treeNode, kind, ptrExpr.TypeSym, ptrExpr, resMulExpr);
            }
            else
            {
                return NewExprBinop(treeNode, kind, ptrExpr.TypeSym, resMulExpr, ptrExpr);
            }
        }

        //--------------------------------------------------
        // FUNCBREC.BindCastToNatural
        //
        /// <summary></summary>
        /// <param name="origExpr"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPR BindCastToNatural(EXPR origExpr)
        {
            AGGTYPESYM naturalIntAts = GetRequiredPredefinedType(
                origExpr.TypeSym.IsUnsigned() ? PREDEFTYPE.UINTPTR : PREDEFTYPE.INTPTR);
            if (naturalIntAts == null)
            {
                return NewError(origExpr.TreeNode, null);
            }

            EXPR tempExpr = NewExpr(origExpr.TreeNode, EXPRKIND.CAST, naturalIntAts);
            (tempExpr as EXPRCAST).Operand = origExpr;
            return tempExpr;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindSizeOf (1)
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="typeSym"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR BindSizeOf(BASENODE treeNode, TYPESYM typeSym)
        {
            if (typeSym.IsEnumType())
            {
                typeSym = typeSym.UnderlyingEnumType();
            }
            CONSTVAL cv = new CONSTVAL();
            cv.SetInt(0);
            if (typeSym.IsSimpleType())
            {
                cv.SetInt(BSYMMGR.GetAttrArgSize(typeSym.GetPredefType()));
            }
            if (typeSym.IsPredefType(PREDEFTYPE.DECIMAL))
            {
                cv.SetInt(16);
            }

            if (cv.GetInt() > 0)
            {
                return NewExprConstant(treeNode, this.GetRequiredPredefinedType(PREDEFTYPE.INT), cv);
            }

            ErrArg arg = new ErrArg(typeSym);
            CheckUnsafe(treeNode, null, CSCERRID.ERR_SizeofUnsafe, arg);
            EXPRSIZEOF rval = NewExpr(treeNode, EXPRKIND.SIZEOF, this.GetRequiredPredefinedType(PREDEFTYPE.INT)) as EXPRSIZEOF;
            rval.SourceTypeSym = typeSym;
            return rval;
        }

        //------------------------------------------------------------
        // FUNCBREC.bindSizeOf (2)
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR BindSizeOf(UNOPNODE treeNode)
        {
            TYPESYM typeSym = BindType(treeNode.Operand.AsANYTYPE);
            DebugUtil.Assert(typeSym != null);
            if (typeSym.IsERRORSYM)
            {
                return NewError(treeNode, this.GetRequiredPredefinedType(PREDEFTYPE.INT));
            }

            if (IsManagedType(typeSym))
            {
                Compiler.Error(treeNode.Operand, CSCERRID.ERR_ManagedAddr, new ErrArg(typeSym));
            }
            return BindSizeOf(treeNode, typeSym);
        }

        //------------------------------------------------------------
        // FUNCBREC.BindForEach
        //
        /// <summary></summary>
        /// <param name="forStmtNode"></param>
        /// <param name="builder"></param>
        //------------------------------------------------------------
        private void BindForEach(FORSTMTNODE forStmtNode, StatementListBuilder builder)
        {
            EXPRDEBUGNOOP nopExpr
                = NewExpr(forStmtNode, EXPRKIND.DEBUGNOOP, null) as EXPRDEBUGNOOP;
            nopExpr.Flags |= EXPRFLAG.USEORIGDEBUGINFO;
            builder.Add(nopExpr);

            EXPRTRY tryExpr = NewExpr(forStmtNode, EXPRKIND.TRY, null) as EXPRTRY;
            tryExpr.Flags |= EXPRFLAG.ISFINALLY;
            tryExpr.HandlersExpr = NewExprBlock(forStmtNode);

            this.finallyNestingCount++;

            CreateNewScope();
            this.currentScopeSym.ScopeFlags = SCOPEFLAGS.TRYSCOPE;
            this.currentBlockExpr = NewExprBlock(forStmtNode);
            tryExpr.TryBlockExpr = this.currentBlockExpr;
            SCOPESYM oldScopeSym = this.innermostTryScopeSym;
            this.innermostTryScopeSym = this.currentScopeSym;
            this.currentBlockExpr.ScopeSym = this.currentScopeSym;

            EXPR enumerator = null;
            StatementListBuilder tmpBuilder = new StatementListBuilder();
            // (&this.currentExprBlock.statements);
            BindForEachInner(forStmtNode, ref enumerator, builder, tmpBuilder);
            this.currentBlockExpr.StatementsExpr = tmpBuilder.GetList();
            tmpBuilder.Clear();

            this.currentBlockExpr = this.currentBlockExpr.OwingBlockExpr;
            CloseScope();
            this.innermostTryScopeSym = oldScopeSym;

            this.finallyNestingCount--;

            // Now, do we need a finally block?
            if (enumerator != null)
            {
                DebugUtil.Assert(enumerator.TypeSym.IsAGGTYPESYM || enumerator.TypeSym.IsTYVARSYM);
                bool removeFinally = false;
                //tmpBuilder.Init(&tryExpr.handlers.AsBLOCK.statements);
                if (!BindForEachFinally(forStmtNode, enumerator, ref tmpBuilder, ref removeFinally))
                {
                    return;
                }
                (tryExpr.HandlersExpr as EXPRBLOCK).StatementsExpr = tmpBuilder.GetList();
                tmpBuilder.Clear();

                if (removeFinally)
                {
                    tryExpr.Flags |= EXPRFLAG.REMOVEFINALLY;
                }
                else
                {
                    CreateNewScope();
                    this.currentScopeSym.ScopeFlags = SCOPEFLAGS.FINALLYSCOPE;
                    (tryExpr.HandlersExpr as EXPRBLOCK).ScopeSym = this.currentScopeSym;
                    this.currentScopeSym.BlockExpr = tryExpr.HandlersExpr as EXPRBLOCK;
                    CloseScope();
                }

                builder.Add(tryExpr);
                builder.Add(MakeStmt(
                    forStmtNode.InitialNode,
                    NewExprWrap(enumerator, TEMP_KIND.SHORTLIVED), EXPRFLAG.GENERATEDSTMT));
            }
            // this was either an error, or an array foreach...
            else if (tryExpr.TryBlockExpr.StatementsExpr != null)
            {
                tryExpr.Flags |= EXPRFLAG.REMOVEFINALLY;
                builder.Add(tryExpr);
            }
        }

        //------------------------------------------------------------
        // FUNCBREC.HasIEnumerable
        //
        /// <summary>
        /// Returns the implemented interface or NULL if there is none
        /// It always reports an error before returning NULL
        /// if there are multiple generic interfaces, it reports ERR_MultipleIEnumOfT
        /// if badMember is -1, it reports ERR_BadGetEnumerator
        /// otherwise it reports ERR_ForEachMissingMember
        /// </summary>
        /// <param name="collection"></param>
        /// <param name="tree"></param>
        /// <param name="badType"></param>
        /// <param name="badMember"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private AGGTYPESYM HasIEnumerable(
            TYPESYM collectionTypeSym,
            BASENODE treeNode,
            TYPESYM badTypeSym,
            PREDEFNAME badMemberName)
        {
            AGGTYPESYM ifaceCandidateAts = null;
            // First try the generic interfaces
            AGGSYM gEnumAggSym
                = Compiler.GetOptPredefAgg(PREDEFTYPE.G_IENUMERABLE, true);
            TypeArray allIfacesTypeArray = null;
            AGGTYPESYM baseAts = null;

            // If generics don't exist or the type isn't an AGGTYPESYM
            // then we can't check the interfaces (and base-class interfaces)
            // for IEnumerable<T> so immediately try the non-generic IEnumerable
            if (gEnumAggSym == null)
            {
                goto NO_GENERIC;
            }

            if (collectionTypeSym.IsAGGTYPESYM)
            {
                if (collectionTypeSym.GetAggregate() == gEnumAggSym ||
                    collectionTypeSym.IsPredefType(PREDEFTYPE.IENUMERABLE))
                {
                    DebugUtil.Assert(false, "IEnumerable/ator types are bad!");
                    goto LERROR;
                }

                AGGTYPESYM tempAts = collectionTypeSym as AGGTYPESYM;
                allIfacesTypeArray = tempAts.GetIfacesAll();
                baseAts = tempAts.GetBaseClass();
            }
            else if (collectionTypeSym.IsTYVARSYM)
            {
                // Note:
                // we'll search the interface list before the class constraint,
                // but it doesn't matter since we require a unique instantiation of IEnumerable<T>.

                // Note:
                // The pattern search will usually find the interface constraint
                // - but if the class constraint has a non-public or non-applicable
                // or non-method GetEnumerator,
                // the interfaces are hidden in which case we will find them here.

                TYVARSYM tempTvSym = collectionTypeSym as TYVARSYM;
                allIfacesTypeArray = tempTvSym.AllInterfaces;
                baseAts = tempTvSym.BaseClassSym;
            }
            else
            {
                goto NO_GENERIC;
            }

            DebugUtil.Assert(allIfacesTypeArray != null);

            // If the type implements exactly one instantiation of
            // IEnumerable<T> then it's the one.
            //
            // If it implements none then try the non-generic interface.
            //
            // If it implements more than one, then it's an error.
            //
            // Search the direct and indirect interfaces via allIfacesTypeArray,
            // going up the base chain...
            // Work up the base chain
            for (; ; )
            {
                // Now work across all the interfaces
                for (int i = 0; i < allIfacesTypeArray.Count; ++i)
                {
                    AGGTYPESYM iface = allIfacesTypeArray[i] as AGGTYPESYM;
                    if (iface.GetAggregate() == gEnumAggSym)
                    {
                        if (ifaceCandidateAts == null)
                        {
                            // First implementation
                            ifaceCandidateAts = iface;
                        }
                        else if (iface != ifaceCandidateAts)
                        {
                            // If this really is a different instantiation report an error
                            Compiler.Error(
                                treeNode,
                                CSCERRID.ERR_MultipleIEnumOfT,
                                new ErrArgRef(collectionTypeSym),
                                new ErrArg(gEnumAggSym.GetThisType()));
                            return null;
                        }
                    }
                }
                // Check the base class.
                if (baseAts == null)
                {
                    break;
                }
                allIfacesTypeArray = baseAts.GetIfacesAll();
                baseAts = baseAts.GetBaseClass();
            }

            // Report the one and only generic interface
            if (ifaceCandidateAts != null)
            {
                DebugUtil.Assert(
                    CanConvert(collectionTypeSym, ifaceCandidateAts, ConvertTypeEnum.NOUDC));
                return ifaceCandidateAts;
            }

        NO_GENERIC:
            if (collectionTypeSym.IsPredefType(PREDEFTYPE.IENUMERABLE))
            {
                DebugUtil.VsFail("Why didn't IEnumerator match the pattern?");
                goto LERROR;
            }

            // No errors, no generic interfaces, try the non-generic interface
            ifaceCandidateAts = GetRequiredPredefinedType(PREDEFTYPE.IENUMERABLE);
            if (CanConvert(collectionTypeSym, ifaceCandidateAts, ConvertTypeEnum.NOUDC))
            {
                return ifaceCandidateAts;
            }

        LERROR:
            Compiler.Error(
                treeNode,
                CSCERRID.ERR_ForEachMissingMember,
                new ErrArg(collectionTypeSym),
                new ErrArg(badTypeSym),
                new ErrArg(badMemberName));

            return null;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindForEachInner
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="enumerator"></param>
        /// <param name="bldrInit"></param>
        /// <param name="bldr"></param>
        //------------------------------------------------------------
        private void BindForEachInner(
            FORSTMTNODE tree,
            ref EXPR enumerator,
            StatementListBuilder bldrInit,
            StatementListBuilder bldr)
        {
            // Note that the caller has prepared a block and scope for us already,
            // so we just fill in the statements into that block
            LOOPLABELS prev = this.LoopLabels;
            LOOPLABELS ll = new LOOPLABELS(this);   // set a new LOOPLABELS to this.LoopLabels

            BindForEachInnerCore(tree, ref enumerator, bldrInit, bldr);

            this.LoopLabels = prev;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindForEachInnerCore
        //
        /// <summary></summary>
        /// <param name="forStmtNode"></param>
        /// <param name="enumeratorExpr"></param>
        /// <param name="initBuilder"></param>
        /// <param name="builder"></param>
        //------------------------------------------------------------
        private void BindForEachInnerCore(
            FORSTMTNODE forStmtNode,
            ref EXPR enumeratorExpr,
            StatementListBuilder initBuilder,
            StatementListBuilder builder)
        {
            enumeratorExpr = null;

            EXPR callGetEnumExpr = null;
            EXPR callMoveNextExpr = null;
            EXPR callCurrentExpr = null;
            EXPRLABEL againLabelExpr = null;
            TYPESYM enumTypeSym = null;
            EXPRWRAP atorWrapExpr = null;

            // Note that the caller has prepared a block and scope for us already,
            // so we just fill in the statements into that block

            MemberLookup mem = new MemberLookup();
            MethWithInst ambigMwi = new MethWithInst();
            MethWithInst tempMwi = new MethWithInst();

            // This is cleared below if we don't encounter any errors.
            bool fError = true;

            EXPR collectionExpr = BindExpr(
                forStmtNode.ExpressionNode,
                BindFlagsEnum.RValueRequired);
            TYPESYM coTypeSym = null;

            if (collectionExpr.IsNull())
            {
                Compiler.Error(forStmtNode, CSCERRID.ERR_NullNotValid);
            }
            else if (collectionExpr.IsOK)
            {
                coTypeSym = collectionExpr.TypeSym;

                if (coTypeSym.IsARRAYSYM)
                {
                    BindForEachArray(forStmtNode, collectionExpr, builder);
                    return;
                }
                if (coTypeSym.IsPredefType(PREDEFTYPE.STRING))
                {
                    BindForEachString(forStmtNode, collectionExpr,ref builder);
                    return;
                }

                if (!coTypeSym.IsAGGTYPESYM && !coTypeSym.IsTYVARSYM)
                {
                    if (coTypeSym.IsANONMETHSYM || coTypeSym.IsMETHGRPSYM)
                    {
                        Compiler.Error(
                            forStmtNode,
                            CSCERRID.ERR_AnonMethGrpInForEach,
                            new ErrArg(coTypeSym));
                    }
                    else
                    {
                        Compiler.Error(forStmtNode, CSCERRID.ERR_ForEachMissingMember,
                            new ErrArg(coTypeSym),
                            new ErrArg(coTypeSym),
                            new ErrArg(PREDEFNAME.GETENUMERATOR));
                    }
                    goto LError;
                }

                //----------------------------------------------------
                // First check for the pattern.
                //----------------------------------------------------
                callGetEnumExpr = BindPatternToMethod(
                    forStmtNode,
                    PREDEFNAME.GETENUMERATOR,
                    coTypeSym,
                    collectionExpr,
                    null,
                    ResNo.CSCSTR_Collection);
                if (callGetEnumExpr == null)
                {
                    // There is no pattern, so we try the interface
                    AGGTYPESYM typeIAble = HasIEnumerable(
                        coTypeSym,
                        forStmtNode,
                        coTypeSym,
                        PREDEFNAME.GETENUMERATOR);
                    if (typeIAble == null)
                    {
                        goto LError;
                    }

                    callGetEnumExpr = BindPredefMethToArgs(
                        forStmtNode,
                        PREDEFNAME.GETENUMERATOR,
                        typeIAble,
                        collectionExpr,
                        null,
                        null);
                    if (!callGetEnumExpr.IsOK)
                    {
                        goto LError;
                    }
                }

                enumTypeSym = callGetEnumExpr.TypeSym;

                if (!enumTypeSym.IsAGGTYPESYM && !enumTypeSym.IsTYVARSYM)
                {
                    goto LBadRetType;
                }

                Compiler.EnsureState(enumTypeSym, AggStateEnum.Prepared);
                if (enumTypeSym.IsDeprecated())
                {
                    ReportDeprecated(forStmtNode, new SymWithType(enumTypeSym, null));
                }

                atorWrapExpr = NewExprWrap(callGetEnumExpr, TEMP_KIND.FOREACH_GETENUM);
                atorWrapExpr.Flags |= EXPRFLAG.WRAPASTEMP;
                atorWrapExpr.DoNotFree = true;
                enumeratorExpr = atorWrapExpr;

                //----------------------------------------------------
                // Handle the MoveNext method.
                //----------------------------------------------------
                string name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.MOVENEXT);

                if (!mem.Lookup(
                        Compiler,
                        enumTypeSym,
                        atorWrapExpr,
                        this.parentDeclSym,
                        name,
                        0,
                        MemLookFlagsEnum.None))
                {
                    mem.ReportErrors(forStmtNode);
                    goto LBadRetType;
                }
                if (!mem.FirstSym.IsMETHSYM)
                {
                    goto LBadRetType;
                }
                mem.ReportWarnings(forStmtNode);

                EXPRMEMGRP grpExpr = NewExprMemGrp(forStmtNode, null, mem);

                if (!BindGrpToParams(
                    tempMwi,
                    forStmtNode,
                    grpExpr,
                    BSYMMGR.EmptyTypeArray,
                    false,
                    ambigMwi,
                    null))
                {
                    goto LBadRetType;
                }
                if (ambigMwi.IsNotNull)
                {
                    Compiler.Error(forStmtNode, CSCERRID.ERR_AmbigCall,
                        new ErrArg(tempMwi), new ErrArg(ambigMwi));
                    goto LBadRetType;
                }
                if (!tempMwi.MethSym.ReturnTypeSym.IsPredefType(PREDEFTYPE.BOOL) ||
                    tempMwi.MethSym.Access != ACCESS.PUBLIC ||
                    tempMwi.MethSym.IsStatic)
                {
                    goto LBadRetType;
                }

                callMoveNextExpr = BindToMethod(
                    forStmtNode,
                    grpExpr.ObjectExpr,
                    tempMwi,
                    null,
                    MemLookFlagsEnum.None);
                if (!callMoveNextExpr.IsOK)
                {
                    goto LBadRetType;
                }

                //----------------------------------------------------
                // Handle the Current property.
                //----------------------------------------------------
                name = Compiler.NameManager.GetPredefinedName(PREDEFNAME.CURRENT);
                if (!mem.Lookup(
                    Compiler,
                    enumTypeSym,
                    atorWrapExpr,
                    this.parentDeclSym,
                    name,
                    0,
                    MemLookFlagsEnum.None))
                {
                    mem.ReportErrors(forStmtNode);
                    goto LBadRetType;
                }
                if (!mem.FirstSym.IsPROPSYM ||
                    mem.FirstSym.Access != ACCESS.PUBLIC ||
                    (mem.FirstSym as PROPSYM).IsStatic)
                {
                    goto LBadRetType;
                }
                mem.ReportWarnings(forStmtNode);
                callCurrentExpr = BindToProperty(
                    forStmtNode,
                    atorWrapExpr,
                    PropWithType.Convert(mem.FirstSymWithType),
                    BindFlagsEnum.RValueRequired, null, null);
                if (!callCurrentExpr.IsOK)
                {
                    goto LBadRetType;
                }

                fError = false;
            }

        LError:
            //EXPRSTMT ** pstmtNext = initBuilder.PstmtNext();
            EXPRSTMT nextStmtExpr = initBuilder.GetLast();
            BindVarDecls(forStmtNode.InitialNode as DECLSTMTNODE, initBuilder, true);
            //EXPR * initExpr = *pstmtNext;
            EXPR initExpr = null;
            if (nextStmtExpr == null)
            {
                initExpr = initBuilder.GetList();
            }
            else
            {
                initExpr = nextStmtExpr.NextStatement;
            }

            if (initExpr == null || initExpr.Kind != EXPRKIND.DECL)
            {
                DebugUtil.Assert(initExpr == null);
                fError = true;
                BindStatement(forStmtNode.StatementNode, builder);
                return;
            }

            LOCVARSYM locVarSym = (initExpr as EXPRDECL).LocVarSym;
            //--------------------------------------------------------
            // (CS3) Determine the implicit type.
            //--------------------------------------------------------
            if (locVarSym.TypeSym.IsIMPLICITTYPESYM)
            {
                AGGTYPESYM elementTypeSym = callCurrentExpr.TypeSym as AGGTYPESYM;
                if (elementTypeSym != null)
                {
#if false
                    TypeArray ta = elementTypeSym.TypeArguments;
                    if (ta != null && ta.Count > 0)
                    {
                        locVarSym.TypeSym = ta[0];
                    }
#endif
                    locVarSym.TypeSym = elementTypeSym;
                }
                if (locVarSym.TypeSym == null ||
                    locVarSym.TypeSym.IsIMPLICITTYPESYM)
                {
                    locVarSym.TypeSym = GetRequiredPredefinedType(PREDEFTYPE.OBJECT);
                }
            }

            if (!fError)
            {
                initBuilder.Add(MakeAssignment(forStmtNode.ExpressionNode, atorWrapExpr, callGetEnumExpr));
                builder.Add(MakeGoto(null, this.LoopLabels.ContinueLabel, 0));
                builder.Add(againLabelExpr = NewExprLabel());
                builder.Add(
                    MakeAssignment(
                        forStmtNode.InitialNode,
                        MakeLocal(forStmtNode, locVarSym, true),
                        MustCast(callCurrentExpr, locVarSym.TypeSym, 0)),
                    EXPRFLAG.GENERATEDSTMT);
            }

            locVarSym.IsNonWriteable = true;
            locVarSym.IsForeach = true;
            DebugUtil.Assert(!locVarSym.LocSlotInfo.IsReferenced);
            locVarSym.LocSlotInfo.IsReferenced = true;
            this.unreferencedVarCount--;

            BindStatement(forStmtNode.StatementNode, builder);

            locVarSym.IsNonWriteable = false;

            if (fError)
            {
                return;
            }

            builder.Add(this.LoopLabels.ContinueLabel);
            builder.Add(MakeGotoIf(
                forStmtNode,
                MustConvertCore(callMoveNextExpr, GetRequiredPredefinedType(PREDEFTYPE.BOOL), forStmtNode, 0),
                againLabelExpr,
                true,
                EXPRFLAG.GENERATEDSTMT));
            builder.Add(this.LoopLabels.BreakLabel);
            return;

        LBadRetType:
            Compiler.ErrorRef(forStmtNode, CSCERRID.ERR_BadGetEnumerator,
                new ErrArgRef(enumTypeSym),
                new ErrArgRef((callGetEnumExpr as EXPRCALL).MethodWithInst));
            goto LError;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindForEachArray
        //
        /// <summary></summary>
        /// <param name="forStmtNode"></param>
        /// <param name="arrayExpr"></param>
        /// <param name="builder"></param>
        //------------------------------------------------------------
        private void BindForEachArray(
            FORSTMTNODE forStmtNode,
            EXPR arrayExpr,
            StatementListBuilder builder)
        {
            DebugUtil.Assert(arrayExpr.TypeSym.IsARRAYSYM);
            DebugUtil.Assert((arrayExpr.TypeSym as ARRAYSYM).Rank != 0);

            int rank;
            int curRank;
            rank = (arrayExpr.TypeSym as ARRAYSYM).Rank;

            //ARRAYFOREACHSLOT foreachSlots;
            //foreachSlots = STACK_ALLOC(ARRAYFOREACHSLOT, rank);
            List<ARRAYFOREACHSLOT> foreachSlots = new List<ARRAYFOREACHSLOT>();

            EXPRWRAP tempArrayWrapExpr;
            tempArrayWrapExpr = NewExprWrap(arrayExpr, TEMP_KIND.FOREACH_ARRAY);
            tempArrayWrapExpr.Flags |= EXPRFLAG.WRAPASTEMP;
            tempArrayWrapExpr.DoNotFree = true;

            builder.Add(MakeAssignment(forStmtNode.ExpressionNode, tempArrayWrapExpr, arrayExpr));

            TYPESYM intTypeSym = GetRequiredPredefinedType(PREDEFTYPE.INT);

            //TYPESYM * oneIntArg[1];
            //oneIntArg[0] = intTypeSym;
            //TypeArray * oneIntArgTypeArray;
            TypeArray oneIntArgTypeArray = Compiler.MainSymbolManager.AllocParams(intTypeSym);

            if (rank == 1)
            {
                // we do not prefetch the arrayExpr limit as that results in worse code...
                foreachSlots.Add(new ARRAYFOREACHSLOT());
                foreachSlots[0].LimitWrapExpr = null;
            }
            else
            {
                // First initialize locals to the maximum sizes for each dimension
                for (curRank = 0; curRank < rank; curRank++)
                {
                    EXPRWRAP limitWrapExpr =
                        NewExprWrap(null, (TEMP_KIND)((int)TEMP_KIND.FOREACH_ARRAYLIMIT_0 + (int)curRank));
                    limitWrapExpr.TypeSym = intTypeSym;
                    limitWrapExpr.DoNotFree = true;
                    limitWrapExpr.Flags = EXPRFLAG.WRAPASTEMP;

                    foreachSlots.Add(new ARRAYFOREACHSLOT());
                    foreachSlots[curRank].LimitWrapExpr = limitWrapExpr;

                    EXPR argExpr = NewExprConstant(null, intTypeSym, new ConstValInit(curRank));
                    EXPR callGetLimitExpr = BindPredefMethToArgs(
                        forStmtNode,
                        PREDEFNAME.GETUPPERBOUND,
                        GetRequiredPredefinedType(PREDEFTYPE.ARRAY),
                        tempArrayWrapExpr,
                        argExpr,
                        null);

                    builder.Add(
                        MakeAssignment(forStmtNode.ExpressionNode, limitWrapExpr, callGetLimitExpr),
                        EXPRFLAG.GENERATEDSTMT);
                }
            }

            for (curRank = 0; curRank < rank; curRank++)
            {
                EXPRWRAP currentWrapExpr = NewExprWrap(
                    null, (TEMP_KIND)((int)TEMP_KIND.FOREACH_ARRAYINDEX_0 + (int)curRank));
                currentWrapExpr.TypeSym = intTypeSym;
                currentWrapExpr.DoNotFree = true;
                currentWrapExpr.Flags = EXPRFLAG.WRAPASTEMP;

                foreachSlots[curRank].CurrentWrapExpr = currentWrapExpr;

                if (rank > 1)
                {
                    EXPR argExpr = NewExprConstant(null, intTypeSym, new ConstValInit(curRank));
                    EXPR callGetLimitExpr = BindPredefMethToArgs(
                        forStmtNode,
                        PREDEFNAME.GETLOWERBOUND,
                        GetRequiredPredefinedType(PREDEFTYPE.ARRAY),
                        tempArrayWrapExpr,
                        argExpr,
                        null);

                    builder.Add(
                        MakeAssignment(forStmtNode.ExpressionNode, currentWrapExpr, callGetLimitExpr),
                        EXPRFLAG.GENERATEDSTMT);
                }
                else
                {
                    builder.Add(
                        MakeAssignment(
                            forStmtNode.ExpressionNode,
                            currentWrapExpr,
                            NewExprConstant(forStmtNode, intTypeSym, new ConstValInit(0))),
                        EXPRFLAG.GENERATEDSTMT);
                }

                EXPRLABEL testLabelExpr = NewExprLabel();
                foreachSlots[curRank].TestLabelExpr = testLabelExpr;
                builder.Add(MakeGoto(null, testLabelExpr, EXPRFLAG.NODEBUGINFO));

                EXPRLABEL bodyLabelExpr = NewExprLabel();
                foreachSlots[curRank].BodyLabelExpr = bodyLabelExpr;
                builder.Add(bodyLabelExpr);
            }

            EXPRSTMT initStmtExpr = null;
            StatementListBuilder tempBuilder = new StatementListBuilder();	// (&initStmtExpr);
            BindVarDecls(forStmtNode.InitialNode as DECLSTMTNODE, tempBuilder, true);
            initStmtExpr = tempBuilder.GetList();
            if (initStmtExpr == null || initStmtExpr.Kind != EXPRKIND.DECL)
            {
                BindStatement(forStmtNode.StatementNode, builder);
                initStmtExpr = tempBuilder.GetList();
                return;
            }

            LOCVARSYM locVarSym = (initStmtExpr as EXPRDECL).LocVarSym;
            // CS3
            if (locVarSym.TypeSym.IsIMPLICITTYPESYM)
            {
                locVarSym.TypeSym = (arrayExpr.TypeSym as ARRAYSYM).ElementTypeSym;
            }

            //EXPR * indexListExpr;
            //EXPR ** pIndexList;
            //indexListExpr = null;
            //pIndexList = &indexListExpr;
            EXPR indexListExpr = null;
            EXPR indexListLastExpr = null;

            for (curRank = 0; curRank < rank; curRank++)
            {
                NewList(foreachSlots[curRank].CurrentWrapExpr, ref indexListExpr, ref indexListLastExpr);
            }

            EXPR arrayIndexingExpr = NewExprBinop(
                forStmtNode,
                EXPRKIND.ARRINDEX,
                (arrayExpr.TypeSym as ARRAYSYM).ElementTypeSym,
                tempArrayWrapExpr,
                indexListExpr);
            arrayIndexingExpr.Flags |= EXPRFLAG.LVALUE | EXPRFLAG.ASSGOP;

            builder.Add(
                MakeAssignment(
                    forStmtNode.InitialNode,
                    MakeLocal(forStmtNode, locVarSym, true),
                    MustCast(arrayIndexingExpr, locVarSym.TypeSym, 0)),
                EXPRFLAG.GENERATEDSTMT);

            locVarSym.IsNonWriteable = true;
            locVarSym.IsForeach = true;
            DebugUtil.Assert(!locVarSym.LocSlotInfo.IsReferenced);
            locVarSym.LocSlotInfo.IsReferenced = true;
            this.unreferencedVarCount--;

            BindStatement(forStmtNode.StatementNode, builder);

            locVarSym.IsNonWriteable = false;

            builder.Add(this.LoopLabels.ContinueLabel);

            for (curRank = rank - 1; curRank >= 0; curRank--)
            {
                EXPRSTMT assignment = MakeAssignment(
                    forStmtNode,
                    foreachSlots[curRank].CurrentWrapExpr,
                    NewExprBinop(
                        forStmtNode,
                        EXPRKIND.ADD,
                        intTypeSym,
                        foreachSlots[curRank].CurrentWrapExpr,
                        NewExprConstant(forStmtNode, intTypeSym, new ConstValInit(1))));
                if (curRank == rank - 1)
                {
                    assignment.Flags |= EXPRFLAG.NODEBUGINFO;
                    // To get better breakpoint behavior, innermost increment has no debug info. See VS7:343108.
                }
                builder.Add(assignment, EXPRFLAG.GENERATEDSTMT);
                builder.Add(foreachSlots[curRank].TestLabelExpr, EXPRFLAG.GENERATEDSTMT);
                builder.Add(MakeGotoIf(
                    forStmtNode,
                    NewExprBinop(
                        forStmtNode,
                        rank == 1 ? EXPRKIND.LT : EXPRKIND.LE,
                        GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                        foreachSlots[curRank].CurrentWrapExpr,
                        rank == 1 ? NewExprBinop(
                            forStmtNode, EXPRKIND.ARRLEN, intTypeSym, tempArrayWrapExpr, null).AsEXPR :
                        foreachSlots[curRank].LimitWrapExpr.AsEXPR),
                    foreachSlots[curRank].BodyLabelExpr, true, EXPRFLAG.GENERATEDSTMT));
            }

            builder.Add(this.LoopLabels.BreakLabel);

            // this will free the temporaries
            for (curRank = 0; curRank < rank; curRank++)
            {
                builder.Add(MakeStmt(
                    null,
                    NewExprWrap(foreachSlots[curRank].CurrentWrapExpr, TEMP_KIND.SHORTLIVED),
                    0));
                if (rank != 1)
                {
                    builder.Add(MakeStmt(
                        null,
                        NewExprWrap(foreachSlots[curRank].LimitWrapExpr, TEMP_KIND.SHORTLIVED),
                        0));
                }
            }

            builder.Add(MakeStmt(null, NewExprWrap(tempArrayWrapExpr, TEMP_KIND.FOREACH_ARRAY), 0));
        }

        //------------------------------------------------------------
        // FUNCBREC.BindForEachString
        //
        /// <summary></summary>
        /// <param name="forTreeNode"></param>
        /// <param name="stringExpr"></param>
        /// <param name="builder"></param>
        //------------------------------------------------------------
        private void BindForEachString(
            FORSTMTNODE forTreeNode,
            EXPR stringExpr,
            ref StatementListBuilder builder)
        {
            DebugUtil.Assert(stringExpr.TypeSym == GetRequiredPredefinedType(PREDEFTYPE.STRING));

            EXPRWRAP stringTempExpr;
            stringTempExpr = NewExprWrap(stringExpr, TEMP_KIND.FOREACH_ARRAY);
            stringTempExpr.Flags |= EXPRFLAG.WRAPASTEMP;
            stringTempExpr.DoNotFree = true;

            builder.Add(MakeAssignment(forTreeNode.ExpressionNode, stringTempExpr, stringExpr));

            TYPESYM intTypeSym = GetRequiredPredefinedType(PREDEFTYPE.INT);

            TYPESYM[] oneIntArg = { intTypeSym };
            compiler.MainSymbolManager.AllocParams(oneIntArg);

            EXPR getLengthCallExpr = BindPredefMethToArgs(
                forTreeNode,
                PREDEFNAME.GETLENGTH,
                GetRequiredPredefinedType(PREDEFTYPE.STRING),
                stringTempExpr,
                null,
                null);

            EXPRWRAP currentWrapExpr = NewExprWrap(null, TEMP_KIND.FOREACH_ARRAYINDEX_0);
            currentWrapExpr.TypeSym = intTypeSym;
            currentWrapExpr.DoNotFree = true;
            currentWrapExpr.Flags = EXPRFLAG.WRAPASTEMP;

            builder.Add(
                MakeAssignment(
                    forTreeNode.ExpressionNode,
                    currentWrapExpr,
                    NewExprConstant(forTreeNode, intTypeSym, new ConstValInit((int)0))),
                EXPRFLAG.GENERATEDSTMT);

            EXPRLABEL testLabelExpr = NewExprLabel();
            builder.Add(MakeGoto(null, testLabelExpr, EXPRFLAG.NODEBUGINFO));

            EXPRLABEL labelBodyExpr = NewExprLabel();
            builder.Add(labelBodyExpr);

            EXPRSTMT initExpr = null;
            StatementListBuilder tempBuilder = new StatementListBuilder();	// (&initExpr);
            BindVarDecls(forTreeNode.InitialNode as DECLSTMTNODE, tempBuilder, true);
            initExpr = tempBuilder.GetList();
            if (initExpr == null || initExpr.Kind != EXPRKIND.DECL)
            {
                BindStatement(forTreeNode.StatementNode, builder);
                return;
            }

            LOCVARSYM localSym = (initExpr as EXPRDECL).LocVarSym;
            // CS3
            if (localSym.TypeSym.IsIMPLICITTYPESYM)
            {
                localSym.TypeSym = GetRequiredPredefinedType(PREDEFTYPE.CHAR);
            }

            METHSYM getCharsMethodSym;

            bool isError = false;
            MemberLookup mem = new MemberLookup();
            if (!mem.Lookup(
                compiler,
                stringExpr.TypeSym,
                stringExpr,
                this.parentDeclSym,
                compiler.NameManager.GetPredefinedName(PREDEFNAME.INDEXERINTERNAL),
                0,
                MemLookFlagsEnum.Indexer))
            {
                mem.ReportErrors(forTreeNode);
                isError = true;
            }
            else
            {
                mem.ReportWarnings(forTreeNode);
                DebugUtil.Assert(
                    mem.FirstSym != null &&
                    mem.FirstSym.IsPROPSYM &&
                    (mem.FirstSym as PROPSYM).IsIndexer);

                getCharsMethodSym = (mem.FirstSym as PROPSYM).GetMethodSym;
                DebugUtil.Assert(
                    getCharsMethodSym != null &&
                    getCharsMethodSym.ParameterTypes.Count == 1 &&
                    getCharsMethodSym.ParameterTypes[0] == intTypeSym);

                EXPRCALL getCharsCallExpr = NewExpr(forTreeNode, EXPRKIND.CALL, null) as EXPRCALL;
                getCharsCallExpr.MethodWithInst.Set(getCharsMethodSym, mem.GetContainingTypeSym(0), null);
                getCharsCallExpr.ArgumentsExpr = currentWrapExpr;
                getCharsCallExpr.ObjectExpr = stringTempExpr;
                getCharsCallExpr.TypeSym = getCharsMethodSym.ReturnTypeSym;

                builder.Add(
                    MakeAssignment(
                        forTreeNode.InitialNode,
                        MakeLocal(forTreeNode, localSym, true),
                        MustCast(getCharsCallExpr, localSym.TypeSym, 0)),
                    EXPRFLAG.GENERATEDSTMT);
            }

            localSym.IsNonWriteable = true;
            localSym.IsForeach = true;
            DebugUtil.Assert(!localSym.LocSlotInfo.IsReferenced);
            localSym.LocSlotInfo.IsReferenced = true;
            this.unreferencedVarCount--;

            BindStatement(forTreeNode.StatementNode, builder);

            localSym.IsNonWriteable = false;

            if (isError)
            {
                return;
            }

            builder.Add(this.LoopLabels.ContinueLabel);

            // To get better breakpoint behavior, increment has no debug info. See VS7:343108.
            builder.Add(
                MakeAssignment(
                    forTreeNode,
                    currentWrapExpr,
                    NewExprBinop(
                        forTreeNode,
                        EXPRKIND.ADD,
                        intTypeSym,
                        currentWrapExpr,
                        NewExprConstant(forTreeNode, intTypeSym, new ConstValInit((int)1)))),
                EXPRFLAG.NODEBUGINFO | EXPRFLAG.GENERATEDSTMT);

            builder.Add(testLabelExpr);
            builder.Add(MakeGotoIf(
                forTreeNode,
                NewExprBinop(forTreeNode, EXPRKIND.LT, GetRequiredPredefinedType(PREDEFTYPE.BOOL), currentWrapExpr, getLengthCallExpr),
                labelBodyExpr,
                true,
                EXPRFLAG.GENERATEDSTMT));
            builder.Add(this.LoopLabels.BreakLabel);
            builder.Add(MakeStmt(null, NewExprWrap(currentWrapExpr, TEMP_KIND.SHORTLIVED), 0));
            builder.Add(MakeStmt(null, NewExprWrap(stringTempExpr, TEMP_KIND.FOREACH_ARRAY), 0));
        }

        //------------------------------------------------------------
        // FUNCBREC.BindForEachFinally
        //
        /// BindForEachFinally()
        /// binds the finally clause on a foreach statement if there is one.
        /// We first check for the dispose pattern,
        /// and if that does not exist then we check for IDisposable interface,
        /// and as a last resort we check at runtime.
        ///
        /// tree -- parsetree for error messages
        /// enumerator -- the EXPR for the enumerator
        /// pList -- [In/Out] List of statements to append to
        /// pfRemoveFinally -- [Out] can we optimize away the finally clause?
        //------------------------------------------------------------
        private bool BindForEachFinally(
            BASENODE treeNode,
            EXPR enumeratorExpr,
            ref StatementListBuilder builder,
            ref bool removeFinally)
        {
            DebugUtil.Assert(enumeratorExpr != null);
            removeFinally = false;

            TYPESYM enumeratorTypeSym = enumeratorExpr.TypeSym;
            bool isStruct = enumeratorTypeSym.IsStructType();

            EXPR disposableExpr = enumeratorExpr;
            bool mustCheckAtRuntime = false;
            bool hasInterface = false;
            bool removeFinallyTemp = false;

            AGGTYPESYM disposableTypeSym =GetRequiredPredefinedType(PREDEFTYPE.IDISPOSABLE);
            DebugUtil.Assert(disposableTypeSym != null);

            if (enumeratorTypeSym.IsPredefType(PREDEFTYPE.IENUMERATOR))
            {
                mustCheckAtRuntime = true;
            }
            else
            {
                if (CanConvert(enumeratorTypeSym, disposableTypeSym, ConvertTypeEnum.NOUDC))
                {
                    hasInterface = true;
                }
                else if (
                    isStruct ||
                    enumeratorTypeSym.IsAGGTYPESYM && enumeratorTypeSym.GetAggregate().IsSealed)
                {
                    removeFinallyTemp = true;
                }
                else
                {
                    mustCheckAtRuntime = true;
                }
            }

            // must be exactly one of the above
            DebugUtil.Assert(
                (mustCheckAtRuntime ^ hasInterface ^ removeFinallyTemp) &&
                !(mustCheckAtRuntime && hasInterface && removeFinallyTemp));
            DebugUtil.Assert(disposableTypeSym != null);

            if (removeFinallyTemp)
            {
                // no dispose to call, so get rid of the try/finally mechanism
                removeFinally = true;
                return true;
            }

            DebugUtil.Assert(mustCheckAtRuntime || hasInterface);
            if (mustCheckAtRuntime)
            {
                DebugUtil.Assert(!isStruct);

                // if we haven't found a public dispose method, and it does not implement IDisposable
                // then we have to check at runtime
                EXPRTYPEOF typeofExpr = NewExpr(
                    treeNode,
                    EXPRKIND.TYPEOF,
                    GetRequiredPredefinedType(PREDEFTYPE.TYPE)) as EXPRTYPEOF;
                typeofExpr.SourceTypeSym = disposableTypeSym;
                typeofExpr.MethodSym = null;

                EXPR asExpr = NewExprBinop(treeNode, EXPRKIND.AS, disposableTypeSym, enumeratorExpr, typeofExpr);
                EXPRWRAP dispWrapExpr = NewExprWrap(asExpr, TEMP_KIND.SHORTLIVED);
                dispWrapExpr.Flags |= EXPRFLAG.WRAPASTEMP;
                dispWrapExpr.DoNotFree = true;

                EXPRSTMT stmtExpr = MakeAssignment(treeNode, dispWrapExpr, asExpr);
                stmtExpr.Flags |= EXPRFLAG.NODEBUGINFO;

                builder.Add(stmtExpr);
                isStruct = false;

                disposableExpr = dispWrapExpr;
            }

            // Call Dispose on the interface
            METHSYM methodSym = FindPredefMeth(
                treeNode,
                PREDEFNAME.DISPOSE,
                disposableTypeSym,
                BSYMMGR.EmptyTypeArray,
                true,
                MemLookFlagsEnum.None);
            disposableExpr = MustConvertCore(
                disposableExpr,
                disposableTypeSym,
                treeNode,
                ConvertTypeEnum.NOUDC);

            EXPR disposeCallExpr = BindToMethod(
                treeNode,
                disposableExpr,
                new MethWithInst(methodSym, disposableTypeSym,null),
                null,
                MemLookFlagsEnum.None);
            if (disposeCallExpr==null || disposeCallExpr.Kind != EXPRKIND.CALL)
            {
                return false;
            }
            if (enumeratorTypeSym.IsTYVARSYM && !mustCheckAtRuntime || isStruct)
            {
                disposeCallExpr.Flags |= EXPRFLAG.CONSTRAINED;
            }

            // we have a dispose method, now generate the EXPR and add it to the list
            DebugUtil.Assert(disposeCallExpr != null && disposableExpr != null);

            EXPRLABEL labelExpr = null;
            if (!isStruct)
            {
                // we also need to check for null before calling...
                labelExpr = NewExprLabel();

                // Need to box type variables for the null test.
                EXPR objectExpr = disposableExpr.TypeSym.IsTYVARSYM ?
                    MustConvertCore
                        (disposableExpr,
                        GetRequiredPredefinedType(PREDEFTYPE.OBJECT),
                        treeNode,
                        ConvertTypeEnum.NOUDC) :
                    disposableExpr;

                builder.Add(MakeGotoIf(
                    treeNode,
                    NewExprBinop(
                        treeNode,
                        EXPRKIND.EQ,
                        GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                        objectExpr,
                        BindNull(null)),
                    labelExpr,
                    true,
                    EXPRFLAG.NODEBUGINFO));
            }

            builder.Add(MakeStmt(treeNode, disposeCallExpr, EXPRFLAG.NODEBUGINFO));
            if (disposableExpr.Kind == EXPRKIND.WRAP && (disposableExpr as EXPRWRAP).Expr.Kind == EXPRKIND.AS)
            {
                builder.Add(MakeStmt(
                    treeNode,
                    NewExprWrap(disposableExpr, TEMP_KIND.SHORTLIVED),
                    0));
            }
            if (labelExpr != null)
            {
                builder.Add(labelExpr);
            }
            return true;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindBooleanValue
        //
        /// <summary></summary>
        /// <param name="treeNode"></param>
        /// <param name="expr"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR BindBooleanValue(BASENODE treeNode, EXPR expr)
        {
            DebugUtil.Assert(treeNode != null && expr != null);
            TYPESYM boolTypeSym = GetRequiredPredefinedType(PREDEFTYPE.BOOL);

            if (!expr.IsOK)
            {
                return NewError(treeNode, boolTypeSym);
            }

            // Give a warning for something like "if (x = false)"
            if (expr.Kind == EXPRKIND.ASSG)
            {
                EXPR rightExpr = expr.AsBIN.Operand2;
                if (rightExpr.Kind == EXPRKIND.CONSTANT &&
                    rightExpr.TypeSym.IsPredefType(PREDEFTYPE.BOOL) &&
                    (rightExpr.Flags & EXPRFLAG.LITERALCONST) != 0)
                {
                    Compiler.Error(treeNode, CSCERRID.WRN_IncorrectBooleanAssg);
                }
            }

            EXPR resExpr = TryConvert(expr, boolTypeSym, 0);
            if (resExpr == null)
            {
                // Check for operator true.
                EXPR srcExpr = BindUDUnop(treeNode, EXPRKIND.TRUE, expr);
                if (srcExpr == null || (resExpr = TryConvert(srcExpr, boolTypeSym, 0)) == null)
                {
                    // This will give an error.
                    resExpr = MustConvert(expr, boolTypeSym, 0);
                }
            }
            DebugUtil.Assert(resExpr != null && (resExpr.TypeSym == boolTypeSym || !resExpr.IsOK));
            return resExpr;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindValOrDefOp
        //
        /// <summary>
        /// Binds the ?? operator. This works for either nullables or reference types.
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="argExpr1"></param>
        /// <param name="argExpr2"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private EXPR BindValOrDefOp(BASENODE treeNode, EXPR argExpr1, EXPR argExpr2)
        {
            NubInfo nubInfo = new NubInfo();
            TYPESYM resTypeSym;
            EXPR leftExpr;
            EXPR tempExpr;
            EXPR rightExpr = argExpr2;
            EXPR constLeftExpr = null;

            if (argExpr1.TypeSym.IsNUBSYM)
            {
                BindNubCondValBin(treeNode, argExpr1, null, ref nubInfo, LiftFlagsEnum.LiftBoth);
                DebugUtil.Assert(nubInfo.IsActive);
                leftExpr = nubInfo.Val(0);
                DebugUtil.Assert(leftExpr.TypeSym == argExpr1.TypeSym.StripNubs());
            }
            else if (argExpr1.TypeSym.IsReferenceType())
            {
                DebugUtil.Assert(!nubInfo.IsActive);
                constLeftExpr = argExpr1.GetConst();
                leftExpr = constLeftExpr != null ? argExpr1 : NewExprWrap(argExpr1, TEMP_KIND.SHORTLIVED);
            }
            else if (argExpr1.IsOK)
            {
                return BadOperatorTypesError(treeNode, argExpr1, argExpr2, null);
            }
            else
            {
                return NewError(treeNode, null);
            }
            DebugUtil.Assert(nubInfo.IsActive == (leftExpr.TypeSym != argExpr1.TypeSym));

            // argExpr1 is of type A?* and argExpr2 is of type B. The rules are:
            // * if argExpr2 => A then resTypeSym = A
            // * else if argExpr2 => A?* then resTypeSym = A?*
            // * else if A => B then resTypeSym = B
            // * else error.

            if ((tempExpr = TryConvert(rightExpr, resTypeSym = leftExpr.TypeSym, 0)) != null)
            {
                rightExpr = tempExpr;
            }
            else if (
                nubInfo.IsActive &&
                (tempExpr = TryConvert(rightExpr, resTypeSym = argExpr1.TypeSym, 0)) != null)
            {
                leftExpr = MustConvert(nubInfo.TmpVal(0), resTypeSym, 0);
                rightExpr = tempExpr;
            }
            else if ((tempExpr = TryConvert(leftExpr, resTypeSym = rightExpr.TypeSym, 0)) != null)
            {
                leftExpr = tempExpr;
            }
            else if (argExpr1.IsOK && argExpr2.IsOK)
            {
                return BadOperatorTypesError(treeNode, argExpr1, argExpr2, leftExpr.TypeSym);
            }
            else
            {
                return NewError(treeNode, null);
            }
            DebugUtil.Assert(rightExpr.TypeSym == resTypeSym && leftExpr.TypeSym == resTypeSym);

            if (nubInfo.IsActive)
            {
                return BindNubOpRes(treeNode, resTypeSym, leftExpr, rightExpr, ref nubInfo);
            }

            if (constLeftExpr != null)
            {
                return !constLeftExpr.IsNull() ? leftExpr : AddSideEffects(treeNode, rightExpr, leftExpr, true, true);
            }

            EXPRDBLQMARK resExpr = NewExpr(treeNode, EXPRKIND.DBLQMARK, resTypeSym) as EXPRDBLQMARK;
            resExpr.TestExpr = argExpr1;
            resExpr.ConvertExpr = leftExpr;
            resExpr.ElseExpr = rightExpr;

            return resExpr;
        }

        //------------------------------------------------------------
        // FUNCBREC.BindNubCondValBin
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubOpRes (1)
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubOpRes (2)
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubAddTmps
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubSave
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubFetchAndFree
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.AddSideEffects
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.EnsureNonConstNonLvalue
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubConstBool
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindQMark
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.EnsureNubHasValue
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.EnsureNubGetValOrDef
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubHasValue
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubValue
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubGetValOrDef
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubNew
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.StripNubCtor
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.IsNubCtor (1)(2)
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.BindNubConversion
        //
        // Moved to Nullable.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.ErrorBadSK
        //
        /// <summary>
        /// Display an error based on the fact that the given symbol is not of the
        /// expected kind...
        /// </summary>
        /// <param name="treeNode"></param>
        /// <param name="symWithType"></param>
        /// <param name="symMask"></param>
        /// <param name="bindFlags"></param>
        //------------------------------------------------------------
        private void ErrorBadSK(
            BASENODE treeNode,
            SymWithType symWithType,
            SYMBMASK symMask,
            BindFlagsEnum bindFlags) // = 0
        {
            DebugUtil.Assert((symWithType.Sym.Mask & symMask) == 0);

            // First check for the bad cast error.
            if ((bindFlags & BindFlagsEnum.MaybeConfusedNegativeCast) != 0)
            {
                // This could be a case where the user wrote (E)-1 instead of (E)(-1) where E is a
                // type that a negative number could be cast to. If it is of this form, report
                // an additional hint to the user.
                AGGTYPESYM ats = null;
                if (symWithType.Sym.IsAGGSYM)
                {
                    ats = (symWithType.Sym as AGGSYM).GetThisType();
                }
                else if (symWithType.Sym.IsAGGTYPESYM)
                {
                    ats = symWithType.Sym as AGGTYPESYM;
                }

                if (ats != null &&
                    (ats.IsEnumType() ||
                    ats.IsNumericType() ||
                    ats.IsPredefType(PREDEFTYPE.OBJECT) ||
                    ats.GetAggregate().HasConversion))
                {
                    // Look 'up' the parse tree for the OPERATOR.SUB that set the flag
                    BASENODE parent = treeNode.ParentNode;
                    while (parent != null && parent.Kind != NODEKIND.BINOP && parent.Operator != OPERATOR.SUB)
                    {
                        parent = parent.ParentNode;
                    }
                    if (parent == null) parent = treeNode;

                    Compiler.Error(parent, CSCERRID.ERR_PossibleBadNegCast);
                }
            }

            SYMKIND expectedKind;
            if ((symMask & (SYMBMASK.LOCVARSYM)) != 0 &&
                (symMask & (SYMBMASK.AGGTYPESYM)) == 0 &&
                (symMask & (SYMBMASK.NSAIDSYM)) == 0 &&
                (symMask & (SYMBMASK.EVENTSYM)) == 0)
            {
                expectedKind = SYMKIND.LOCVARSYM;
            }
            else if (symMask == (SYMBMASK.MEMBVARSYM | SYMBMASK.PROPSYM))
            {
                expectedKind = SYMKIND.LOCVARSYM;
            }
            else if (symMask == SYMBMASK.METHSYM)
            {
                expectedKind = SYMKIND.METHSYM;
            }
            else if (symMask == SYMBMASK.MEMBVARSYM)
            {
                expectedKind = SYMKIND.MEMBVARSYM;
            }
            else if (symMask == SYMBMASK.AGGSYM)
            {
                expectedKind = SYMKIND.AGGSYM;
            }
            else
            {
                expectedKind = (SYMKIND)0;
            }

            if (symWithType.Sym.IsEVENTSYM && (symMask & SYMBMASK.MEMBVARSYM) != 0)
            {
                if (symWithType.EventSym.EventImplementSym != null)
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_BadEventUsage,
                        new ErrArg(symWithType), new ErrArg(symWithType.EventSym.ClassSym));
                }
                else
                {
                    Compiler.Error(treeNode, CSCERRID.ERR_BadEventUsageNoField, new ErrArg(symWithType));
                }
            }
            else if (expectedKind != 0)
            {
                // if this fires, then we should bring back CS654
                DebugUtil.Assert(!(
                    symWithType.Sym.IsMETHSYM &&
                    (expectedKind == SYMKIND.LOCVARSYM || expectedKind == SYMKIND.MEMBVARSYM)));
                Compiler.Error(
                    treeNode,
                    CSCERRID.ERR_BadSKknown,
                    new ErrArg(symWithType),
                    new ErrArgSymKind(symWithType.Sym),
                    new ErrArg(expectedKind));
            }
            else
            {
                Compiler.Error(treeNode, CSCERRID.ERR_BadSKunknown,
                    new ErrArg(symWithType), new ErrArgSymKind(symWithType.Sym));
            }
        }

        //------------------------------------------------------------
        // FUNCBREC.ReportDeprecated
        //
        /// <summary>
        /// Report a deprecation error on a symbol.
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="swt"></param>
        //------------------------------------------------------------
        private void ReportDeprecated(BASENODE tree, SymWithType swt)
        {
            DebugUtil.Assert(swt.Sym.IsDeprecated());
            if (this.methodSym == null || !this.methodSym.IsDeprecated())
            {
                Compiler.ClsDeclRec.ReportDeprecated(tree, this.parentAggSym, swt);
            }
        }

        //------------------------------------------------------------
        // FUNCBREC.GetRequiredPredefinedType
        //
        /// <summary>
        /// (GetReqPDT in sscli.)
        /// </summary>
        /// <param name="pt"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private AGGTYPESYM GetRequiredPredefinedType(PREDEFTYPE pt)
        {
            DebugUtil.Assert(pt != PREDEFTYPE.VOID);  // use getVoidType()
            return Compiler.GetReqPredefType(pt, true);
        }

        //------------------------------------------------------------
        // FUNCBREC.GetOptionalPredefinedType
        //
        /// <summary>
        /// Call BSYMMGR.GetOptPredefTypeErr method.
        /// </summary>
        /// <param name="pt"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private AGGTYPESYM GetOptionalPredefinedType(PREDEFTYPE pt)
        {
            DebugUtil.Assert(pt != PREDEFTYPE.VOID);  // use getVoidType()
            return Compiler.GetOptPredefTypeErr(pt, true);
        }

        //------------------------------------------------------------
        // FUNCBREC.GetPDOT
        //
        /// <summary>
        /// Return AGGTYPESYM for System.Object.
        /// </summary>
        /// <returns></returns>
        //------------------------------------------------------------
        private AGGTYPESYM GetPDOT()
        {
            return Compiler.GetReqPredefType(PREDEFTYPE.OBJECT, true);
        }

        //------------------------------------------------------------
        // FUNCBREC.getPDO
        //------------------------------------------------------------
        //__forceinline AGGSYM * FUNCBREC::getPDO()
        //{
        //    return compiler()->GetReqPredefAgg(PT_OBJECT);
        //}

        //------------------------------------------------------------
        // FUNCBREC.GetVoidType
        //
        /// <summary>
        /// <para>Return BSYMMGR.VoidSym.</para>
        /// </summary>
        /// <returns></returns>
        //------------------------------------------------------------
        private TYPESYM GetVoidType()
        {
            return this.Compiler.MainSymbolManager.VoidSym;
        }

        //internal:
        //    // Used by CLSDREC::MakeIterator

        //------------------------------------------------------------
        // FUNCBREC.CreateSpecialName
        //
        /// <summary></summary>
        /// <param name="spNameKind"></param>
        /// <param name="nameText"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal string CreateSpecialName(
            SpecialNameKindEnum spNameKind,
            string nameText)	// = null
        {
            DebugUtil.Assert(spNameKind > 0 && (int)spNameKind < 16);
            string invisibleSuffix = "";

            switch (spNameKind)
            {
                case SpecialNameKindEnum.HoistedIteratorLocal:
                case SpecialNameKindEnum.HoistedThis:
                case SpecialNameKindEnum.SavedParamOrThis:
                    DebugUtil.Assert(nameText != null);
                    break;

                case SpecialNameKindEnum.OuterscopeLocals:
                    // Move the name to the invisible part since it's not really
                    // a user-provided name anyway
                    DebugUtil.Assert(nameText != null);
                    invisibleSuffix = nameText;
                    nameText = "";
                    break;

                case SpecialNameKindEnum.HoistedWrap:
                    DebugUtil.Assert(nameText == null);
                    nameText = "";
                    invisibleSuffix = "wrap";
                    break;

                // Locals
                case SpecialNameKindEnum.DisplayClassInstance:
                    DebugUtil.Assert(nameText == null);
                    nameText = "";
                    invisibleSuffix = "locals";
                    break;

                case SpecialNameKindEnum.IteratorInstance:
                    DebugUtil.Assert(nameText == null);
                    nameText = "";
                    invisibleSuffix = "iterator";
                    break;

                case SpecialNameKindEnum.CachedDelegateInstance:
                    DebugUtil.Assert(nameText == null);
                    nameText = "";
                    invisibleSuffix = "CachedAnonymousMethodDelegate";
                    break;

                // Methods
                case SpecialNameKindEnum.AnonymousMethod:
                    DebugUtil.Assert(nameText != null);
                    break;

                // Types
                case SpecialNameKindEnum.AnonymousMethodDisplayClass:
                    DebugUtil.Assert(nameText == null);
                    nameText = "";
                    invisibleSuffix = "DisplayClass";
                    break;

                case SpecialNameKindEnum.IteratorClass:
                    DebugUtil.Assert(nameText != null);
                    break;

                case SpecialNameKindEnum.FixedBufferStruct:
                    DebugUtil.Assert(nameText != null);
                    invisibleSuffix = "FixedBuffer";
                    break;

                case SpecialNameKindEnum.IteratorState:
                case SpecialNameKindEnum.CurrentField:
                // These should never come through here!
                default:
                    DebugUtil.Assert(false, "Unhandled SpecialNameKind!!!!");
                    break;
            }

            //string template = "<%s>%x__%s%x";
            string template = "<{0}>{1,0:x}__{2}{3,0:x}";
            return CreateName(template, nameText, (int)spNameKind, invisibleSuffix, uniqueNameIndex++);
        }

        //------------------------------------------------------------
        // FUNCBREC.IsSpecialName
        //------------------------------------------------------------
        //internal static SpecialNameKindEnum IsSpecialName(NAME * name);
        //internal NAME * GetDisplayNameOfPossibleSpecialName(NAME * specialName);

        //private:

        //------------------------------------------------------------
        // FUNCBREC.CreateName
        //
        /// <summary></summary>
        /// <param name="template"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        private string CreateName(string template, params Object[] args)
        {
            string formatted = null;
            try
            {
                formatted = String.Format(template, args);
            }
            catch (ArgumentException)
            {
                DebugUtil.Assert(false);
            }

            // We shouldn't be tacking on so much goop that it overflows the full-name
            // size allowed, assuming that the user-parts are all <= MAX_IDENT_SIZE

            Compiler.NameManager.AddString(formatted);
            return formatted;
        }

        //------------------------------------------------------------
        // FUNCBREC.RecurseAndRewriteExprTree
        //
        // Moved to RewriteTree.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.RewriteIteratorFunc
        //
        // Moved to Iterator.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.RewriteAnonymousMethodFunc
        //
        // Moved to AnonymousMethod.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.MoveLocalToField
        //
        // Moved to AnonymousMethod.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.MoveLocalsToIter
        //
        // Moved to Iterator.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.CorrectAnonMethScope
        //
        // Moved to AnonymousMethod.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.SubstAndTestLocalUsedInAnon
        //
        // Moved to AnonymousMethod.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.RewriteLocalsBlock
        //
        // Moved to AnonymousMethod.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.RewriteAnonMethExpr
        //
        // Moved to AnonymousMethod.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.InitAnonDelegateLocals
        //
        // Moved to AnonymousMethod.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.AddAnonMethInfo
        //
        // Moved to AnonymousMethod.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.MakeIteratorSwitch
        //
        // Moved to Iterator.cs
        //------------------------------------------------------------

        //------------------------------------------------------------
        // FUNCBREC.MakeSwitchLabel
        //
        // Moved to Iterator.cs
        //------------------------------------------------------------

        // ExprFactory routines copied from MSR (todd proebstring et.al.)

        //--------------------------------------------------
        // FUNCBREC.MakeFieldAccess (1)
        //
        // Moved to AnonymousMethod.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.MakeFieldAccess (2)
        //
        // Moved to AnonymousMethod.cs
        //--------------------------------------------------

        //--------------------------------------------------
        // FUNCBREC.MakeIntConst
        //
        /// <summary></summary>
        /// <param name="x"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRCONSTANT MakeIntConst(int x)
        {
            return NewExprConstant(
                null,
                GetRequiredPredefinedType(PREDEFTYPE.INT),
                new ConstValInit(x));
        }

        //--------------------------------------------------
        // FUNCBREC.MakeBoolConst
        //
        /// <summary></summary>
        /// <param name="b"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRCONSTANT MakeBoolConst(bool b)
        {
            return NewExprConstant(
                null,
                GetRequiredPredefinedType(PREDEFTYPE.BOOL),
                new ConstValInit(b));
        }

        //--------------------------------------------------
        // FUNCBREC.MakeReturn
        //
        /// <summary></summary>
        /// <param name="scopeSym"></param>
        /// <param name="valueExpr"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRRETURN MakeReturn(
            SCOPESYM scopeSym,
            EXPR valueExpr,
            EXPRFLAG flags) // = 0
        {
            DebugUtil.Assert(valueExpr != null);

            EXPRRETURN returnExpr = NewExpr(null, EXPRKIND.RETURN, null) as EXPRRETURN;
            returnExpr.ObjectExpr = valueExpr;
            returnExpr.CurrentScopeSym = scopeSym;
            returnExpr.Flags |= flags;

            return returnExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.MakeFreshLabel
        //
        /// <summary></summary>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRLABEL MakeFreshLabel()
        {
            EXPRLABEL labelExpr = NewExpr(null, EXPRKIND.LABEL, null) as EXPRLABEL;
            return labelExpr;
        }

        //--------------------------------------------------
        // FUNCBREC.MakeAssignment
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="exprLeft"></param>
        /// <param name="exprRight"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRSTMT MakeAssignment(BASENODE tree, EXPR exprLeft, EXPR exprRight)
        {
            // Make an assignment expression.
            EXPR expr = NewExprBinop(tree, EXPRKIND.ASSG, exprLeft.TypeSym, exprLeft, exprRight);
            expr.Flags |= EXPRFLAG.ASSGOP;
            return MakeStmt(tree, expr, 0);
        }

        //--------------------------------------------------
        // FUNCBREC.MakeAssignment
        //
        /// <summary></summary>
        /// <param name="exprLeft"></param>
        /// <param name="exprRight"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRSTMT MakeAssignment(EXPR exprLeft, EXPR exprRight)
        {
            return MakeAssignment(null, exprLeft, exprRight);
        }

        //--------------------------------------------------
        // FUNCBREC.MakeLocal
        //
        /// <summary></summary>
        /// <param name="tree"></param>
        /// <param name="loc"></param>
        /// <param name="fLVal"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRLOCAL MakeLocal(BASENODE tree, LOCVARSYM loc, bool fLVal)
        {
            EXPRLOCAL expr = NewExpr(tree, EXPRKIND.LOCAL, loc.TypeSym) as EXPRLOCAL;
            expr.LocVarSym = loc;
            if (fLVal)
            {
                expr.Flags |= EXPRFLAG.LVALUE;
            }
            return expr;
        }

        //--------------------------------------------------
        // FUNCBREC.MakeGoto
        //
        /// <summary>
        /// <para>(In sscli, flags has default value 0.)</para>
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="lab"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        EXPRGOTO MakeGoto(
            BASENODE tree,
            EXPRLABEL lab,
            EXPRFLAG flags)	// = 0
        {
            // Make an unconditional goto statement.
            EXPRGOTO gt = NewExpr(tree, EXPRKIND.GOTO, null) as EXPRGOTO;

            gt.LabelExpr = lab;
            gt.Flags |= flags;

            return gt;
        }

        //--------------------------------------------------
        // FUNCBREC.MakeGotoIf
        //
        /// <summary>
        /// <para>(In sscli, flags has the default value 0.)</para>
        /// </summary>
        /// <param name="tree"></param>
        /// <param name="exprCond"></param>
        /// <param name="lab"></param>
        /// <param name="fSense"></param>
        /// <param name="flags"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private EXPRGOTOIF MakeGotoIf(
            BASENODE tree,
            EXPR exprCond,
            EXPRLABEL lab,
            bool fSense,
            EXPRFLAG flags)	// = 0
        {
            // Make a conditional goto statement.
            EXPRGOTOIF gtif = NewExpr(tree, EXPRKIND.GOTOIF, null) as EXPRGOTOIF;

            gtif.LabelExpr = lab;
            gtif.ConditionExpr = exprCond;
            gtif.HasSense = fSense;
            gtif.Flags |= flags;

            return gtif;
        }

        // End of ExprFactory routines

        //--------------------------------------------------
        // FUNCBREC.CheckForNonvirtualAccessFromClosure
        //
        // Moved to AnonymousMethod.cs
        //--------------------------------------------------
        //private void CheckForNonvirtualAccessFromClosure(EXPR* expr);

        //--------------------------------------------------
        // FUNCBREC.PostBindCompile
        //
        /// <summary>
        /// <para>This does the following:
        /// <list type="bullet">
        /// <item>Warn on unreferenced variables.</item>
        /// <item>Do reachability analysis and warn on unreachable statements.</item>
        /// <item>Determine whether the method (and anon methods) have any returns
        /// out of try-catch blocks.</item>
        /// <item>Realize gotos and error on untargetable ones.</item>
        /// <item>Warn on untargeted user defined labels.</item>
        /// <item>Error on any label that shadows another label.</item>
        /// <item>Check definite assignment and error on bad variable use.</item>
        /// <item>Check definite assignment of out parameters.</item>
        /// <item>Error if a method returning a value has a reachable end.</item>
        /// <item>Realize string concatenations (EK_CONCAT).</item>
        /// <item>Mark locals that need to be hoisted for anonymous methods.</item>
        /// <item>Mark AnonMethInfos that are in reachable code.</item>
        /// </list>
        /// </para>
        /// <para>This assumes that the reachability is already set for all anon meth bodies.
        /// This should be done when the anon method expr tree is created (in bindAnonymousMethod).</para>
        /// <para>This does the definite assignment analysis on the main method and all anonymous methods.
        /// This should be called before anything is "rewritten" (for anon meths or iterators).</para>
        /// </summary>
        /// <param name="blockExpr"></param>
        //--------------------------------------------------
        private void PostBindCompile(EXPRBLOCK blockExpr)
        {
            if (this.unreferencedVarCount != 0)
            {
                ReportUnreferencedVars(this.OuterScopeSym);
            }

            if (this.methodInfo.YieldTypeSym != null)
            {
                CheckForIteratorErrors();
            }

            // Binding linked these in reverse order.
            ReverseAnonMeths(ref this.firstAnonymousMethodInfo);

            // NOTE: Reachability for an anon meth is set when the anon meth is bound.
            ReachabilityChecker reach = new ReachabilityChecker(Compiler);

            reach.SetReachability(blockExpr, true);
            this.methodInfo.HasReturnAsLeave = reach.HasReturnAsLeave;

            // For error reporting, realize all remaining gotos.
            for (EXPRGOTO curGotoExpr = this.gotoExprs; curGotoExpr != null; curGotoExpr = curGotoExpr.PreviousExpr)
            {
                reach.RealizeGoto(curGotoExpr, false);
            }

            // Now that all gotos have been resolved, proceed to unreferened labels:
            EXPR listExpr = userLabelList;
            while (listExpr != null)
            {
                EXPR expr;
                if (listExpr.Kind == EXPRKIND.LIST)
                {
                    expr = listExpr.AsBIN.Operand1;
                    listExpr = listExpr.AsBIN.Operand2;
                }
                else
                {
                    expr = listExpr;
                    listExpr = null;
                }
                EXPRLABEL labelExpr = expr.AsANYLABEL;
                if (labelExpr.Kind == EXPRKIND.LABEL)
                {
                    if ((labelExpr.Flags & EXPRFLAG.LABELREFERENCED) == 0)
                    {
                        Compiler.Error(labelExpr.TreeNode, CSCERRID.WRN_UnreferencedLabel);
                    }
                    for (SCOPESYM scope = labelExpr.ScopeSym; (scope = scope.ParentSym as SCOPESYM) != null; )
                    {
                        SYM sym = Compiler.LocalSymbolManager.LookupLocalSym(
                            labelExpr.LabelSym.Name, scope, SYMBMASK.LABELSYM);
                        if (sym != null)
                        {
                            Compiler.Error(labelExpr.TreeNode, CSCERRID.ERR_LabelShadow,
                                new ErrArg(labelExpr.LabelSym.Name));
                            break;
                        }
                    }
                }
            }

            // This does all of the following:
            // * Check definite assignment.
            // * Realize string concatenation.
            // * Mark locals that need to be hoisted for anonymous methods (see ScanLocal).
            // * Mark AnonMethInfos that are in reachable code.
            // Since this does more than just definite assignment analysis, we always do this,
            // even if there are no uninited vars.

            FlowChecker.CheckDefiniteAssignment(
                Compiler,
                this.bindCallback.GetTarget(),
                //allocator,
                blockExpr,
                this.methodInfo,
                this.firstAnonymousMethodInfo,
                this.uninitedVarCount);
        }

        //--------------------------------------------------
        // FUNCBREC.CheckForIteratorErrors
        //
        /// <summary>
        /// <para>Check for iterator specific errors:
        /// <list type="bullet">
        /// <item>no out/ref parameters</item>
        /// <item>no unsafe code</item>
        /// <item>no varargs</item>
        /// </list>
        /// </para>
        /// </summary>
        //--------------------------------------------------
        private void CheckForIteratorErrors()
        {
            DebugUtil.Assert(this.methodInfo.YieldTypeSym != null);
            bool unsafeError = false;

            for (int i = 0; i < this.methodInfo.ParameterInfoCount; i++)
            {
                PARAMETERNODE paramNode = this.methodInfo.ParameterInfos[i].ParameterNode;
                if (paramNode != null)
                {
                    if ((paramNode.Flags & (NODEFLAGS.PARMMOD_REF | NODEFLAGS.PARMMOD_OUT)) != 0)
                    {
                        Compiler.Error(paramNode, CSCERRID.ERR_BadIteratorArgType);
                    }
                    if (this.methodInfo.MethodSym.ParameterTypes[i].IsUnsafe())
                    {
                        unsafeError = true;
                        Compiler.Error(paramNode, CSCERRID.ERR_UnsafeIteratorArgType);
                    }
                }
            }

            // No varargs
            if (this.methodInfo.MethodSym.IsVarargs)
                Compiler.ErrorRef(
                    null,
                    CSCERRID.ERR_VarargsIterator,
                    new ErrArgRef(this.methodInfo.MethodSym));

            BASENODE node = this.methodInfo.MethodSym.GetParseTree();

            if (!node.InGroup(NODEGROUP.METHOD))
            {
                // Get unsafe from the property node, not accessor node.
                node = node.ParentNode;
            }

            if ((node.Flags & NODEFLAGS.MOD_UNSAFE) != 0)
            {
                // You can't put unsafe right on the iterator declaration
                Compiler.ErrorRef(null, CSCERRID.ERR_IllegalInnerUnsafe, new ErrArgRef(this.methodInfo.MethodSym));
            }
            else if (this.methodInfo.MethodSym.IsUnsafe && this.methodInfo.YieldTypeSym.IsUnsafe())
            {
                Compiler.ErrorRef(null, CSCERRID.ERR_UnsafeIteratorArgType, new ErrArgRef(this.methodInfo.MethodSym));
            }
            else if (this.methodInfo.UnsafeTreeNode != null && !unsafeError)
            {
                // You can't have unsafe code blocks (we do this check here due to ordering issues)
                Compiler.Error(this.methodInfo.UnsafeTreeNode, CSCERRID.ERR_IllegalInnerUnsafe);
            }
        }

        //--------------------------------------------------
        // FUNCBREC.ReverseAnonMeths
        //
        /// <summary>
        /// The anon meth info lists are created in reverse order.
        /// This puts them back in source order.
        /// This is just so any errors get reported in a natural order.
        /// </summary>
        /// <param name="origInfo"></param>
        //--------------------------------------------------
        private void ReverseAnonMeths(ref AnonMethInfo origInfo)
        {
            AnonMethInfo curInfo = origInfo;
            origInfo = null;

            while (curInfo != null)
            {
                if (curInfo.ChildInfo != null)
                {
                    ReverseAnonMeths(ref curInfo.ChildInfo);
                }
                AnonMethInfo nextInfo = curInfo.NextInfo;
                curInfo.NextInfo = origInfo;
                origInfo = curInfo;
                curInfo = nextInfo;
            }
        }
        //--------------------------------------------------
        // FUNCBREC::ReverseAnonMeths (sscli)
        //--------------------------------------------------
        //void FUNCBREC::ReverseAnonMeths(AnonMethInfo ** ppami)
        //{
        //    AnonMethInfo * pamiCur = *ppami;
        //    *ppami = NULL;
        //
        //    while (pamiCur) {
        //        if (pamiCur->pamiChild)
        //            ReverseAnonMeths(&pamiCur->pamiChild);
        //        AnonMethInfo * pamiNext = pamiCur->pamiNext;
        //        pamiCur->pamiNext = *ppami;
        //        *ppami = pamiCur;
        //        pamiCur = pamiNext;
        //    }
        //}

        //--------------------------------------------------
        // FUNCBREC.ScanAnonMeths
        //
        //--------------------------------------------------
        //private void ScanAnonMeths(AnonMethInfo * pami, BitSet & bsetCur, BitSet & bsetErr);

        //--------------------------------------------------
        // FUNCBREC.ReportUnreferencedVars
        //
        /// <summary>
        /// Warn on unused locals.
        /// </summary>
        /// <param name="scopeSym"></param>
        //--------------------------------------------------
        private void ReportUnreferencedVars(SCOPESYM scopeSym)
        {
            for (SYM currentSym = scopeSym.FirstChildSym;
                currentSym != null;
                currentSym = currentSym.NextSym)
            {
                switch (currentSym.Kind)
                {
                    case SYMKIND.LOCVARSYM:
                        if (!(currentSym as LOCVARSYM).LocSlotInfo.IsReferenced &&
                            !(currentSym as LOCVARSYM).LocSlotInfo.IsParameter)
                        {
                            Compiler.Error((currentSym as LOCVARSYM).DeclTreeNode,
                                (currentSym as LOCVARSYM).LocSlotInfo.IsReferencedAssignement ?
                                CSCERRID.WRN_UnreferencedVarAssg : CSCERRID.WRN_UnreferencedVar,
                                new ErrArg(currentSym));
                        }
                        break;

                    case SYMKIND.SCOPESYM:
                        ReportUnreferencedVars(currentSym as SCOPESYM);
                        break;

                    case SYMKIND.ANONSCOPESYM:
                        ReportUnreferencedVars((currentSym as ANONSCOPESYM).ScopeSym);
                        break;

                    default:
                        break;
                }
            }
        }

        //--------------------------------------------------
        // FUNCBREC.OpName
        //
        /// <summary>
        /// Get the name of an operator for error reporting purposes.
        /// </summary>
        //--------------------------------------------------
        private string OpName(OPERATOR op)
        {
            return CParser.GetTokenInfo(CParser.GetOperatorInfo(op).TokenID).Text;
        }

        //--------------------------------------------------
        // FUNCBREC.ExprKindName
        //
        /// <summary>
        /// <para>(In sscli, ekName.)</para>
        /// </summary>
        /// <param name="ek"></param>
        /// <returns></returns>
        //--------------------------------------------------
        private string ExprKindName(EXPRKIND ek)
        {
            DebugUtil.Assert(ek >= EXPRKIND.FIRSTOP && (ek - EXPRKIND.FIRSTOP) < EK2NAME.Length);

            //return Compiler.NameManager.GetPredefinedName(FetchAtIndex(EK2NAME, ek - EXPRKIND.FIRSTOP));
            return Compiler.NameManager.GetPredefinedName(EK2NAME[(int)ek - (int)EXPRKIND.FIRSTOP]);
        }

        //--------------------------------------------------
        // FUNCBREC.betterConversionTable
        //
        /// <summary>
        /// This table is used to implement the last set of 'better' conversion rules
        /// when there are no implicit conversions between T1(down) and T2 (across)
        /// Use all the simple types plus 1 more for Object
        /// See CLR section 7.4.1.3
        /// </summary>
        //--------------------------------------------------
        static protected byte[,] betterConversionTable =
        {
            //BYTE  SHORT   INT     LONG    FLOAT   DOUBLE  DECIMAL CHAR    BOOL    SBYTE   USHORT  UINT    ULONG   IPTR     UIPTR    OBJECT
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      2,      0,      0,      0,      0,       0,       0}, // BYTE
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      1,      1,      1,      0,       0,       0}, // SHORT
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      1,      1,      0,       0,       0}, // INT
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      1,      0,       0,       0}, // LONG
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,       0,       0}, // FLOAT
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,       0,       0}, // DOUBLE
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,       0,       0}, // DECIMAL
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,       0,       0}, // CHAR
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,       0,       0}, // BOOL
            {1,     0,      0,      0,      0,      0,      0,      0,      0,      0,      1,      1,      1,      0,       0,       0}, // SBYTE
            {0,     2,      0,      0,      0,      0,      0,      0,      0,      2,      0,      0,      0,      0,       0,       0}, // USHORT
            {0,     2,      2,      0,      0,      0,      0,      0,      0,      2,      0,      0,      0,      0,       0,       0}, // UINT
            {0,     2,      2,      2,      0,      0,      0,      0,      0,      2,      0,      0,      0,      0,       0,       0}, // ULONG
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,       0,       0}, // IPTR
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,       0,       0}, // UIPTR
            {0,     0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,       0,       0} // OBJECT
        };

        //--------------------------------------------------
        // FUNCBREC.rgptIntOp
        //--------------------------------------------------
        static protected PREDEFTYPE[] rgptIntOp =
        {
            PREDEFTYPE.INT,
            PREDEFTYPE.UINT,
            PREDEFTYPE.LONG,
            PREDEFTYPE.ULONG
        };

        //--------------------------------------------------
        // FUNCBREC.Store
        //--------------------------------------------------
        internal void Store(FUNCBREC backup)
        {
            backup.bindCallback = this.bindCallback;
            backup.methodSym = this.methodSym;
            backup.treeNode = this.treeNode;
            backup.methodInfo = this.methodInfo;

            backup.firstAnonymousMethodInfo = this.firstAnonymousMethodInfo;
            backup.currentAnonymousMethodInfo = this.currentAnonymousMethodInfo;

            backup.classTypeVariablesForMethod = this.classTypeVariablesForMethod;

            backup.typeBindFlags = this.typeBindFlags;

            backup.currentFieldSym = this.currentFieldSym;
            backup.originalFieldSym = this.originalFieldSym;

            backup.parentAggSym = this.parentAggSym;
            backup.parentDeclSym = this.parentDeclSym;
            backup.classInfo = this.classInfo;

            backup.InitLabels = this.InitLabels;
            backup.LoopLabels = this.LoopLabels;

            backup.OuterScopeSym = this.OuterScopeSym;
            backup.currentScopeSym = this.currentScopeSym;
            backup.innermostFinallyScopeSym = this.innermostFinallyScopeSym;
            backup.innermostTryScopeSym = this.innermostTryScopeSym;
            backup.innermostSwitchScopeSym = this.innermostSwitchScopeSym;
            backup.innermostCatchScopeSym = this.innermostCatchScopeSym;

            backup.currentBlockExpr = this.currentBlockExpr;
            backup.CurrentSwitchExpr = this.CurrentSwitchExpr;

            backup.thisPointerSym = this.thisPointerSym;
            backup.outerThisPointerSym = this.outerThisPointerSym;

            backup.uninitedVarCount = this.uninitedVarCount;
            backup.unreferencedVarCount = this.unreferencedVarCount;
            backup.finallyNestingCount = this.finallyNestingCount;
            backup.localCount = this.localCount;
            backup.firstParentOffset = this.firstParentOffset;
            backup.uniqueNameIndex = this.uniqueNameIndex;
            backup.errorsBeforeBind = this.errorsBeforeBind;

            backup.areForwardGotos = this.areForwardGotos;
            backup.unsafeErrorGiven = this.unsafeErrorGiven;
            backup.insideTryOfCatch = this.insideTryOfCatch;

            backup.lastNode = this.lastNode;

            backup.CheckedContext = this.CheckedContext;

            backup.userLabelList = this.userLabelList;
            backup.userLabelListLast = this.userLabelListLast;
            backup.gotoExprs = this.gotoExprs;

            backup.evaluatingFieldInitializer = this.evaluatingFieldInitializer;
            backup.determineImplicitTypeLater = this.determineImplicitTypeLater;
        }

        //--------------------------------------------------
        // FUNCBREC.Restore
        //--------------------------------------------------
        internal void Restore(FUNCBREC backup)
        {
            this.bindCallback = backup.bindCallback;
            this.methodSym = backup.methodSym;
            this.treeNode = backup.treeNode;
            this.methodInfo = backup.methodInfo;

            this.firstAnonymousMethodInfo = backup.firstAnonymousMethodInfo;
            this.currentAnonymousMethodInfo = backup.currentAnonymousMethodInfo;

            this.classTypeVariablesForMethod = backup.classTypeVariablesForMethod;

            this.typeBindFlags = backup.typeBindFlags;

            this.currentFieldSym = backup.currentFieldSym;
            this.originalFieldSym = backup.originalFieldSym;

            this.parentAggSym = backup.parentAggSym;
            this.parentDeclSym = backup.parentDeclSym;
            this.classInfo = backup.classInfo;

            this.InitLabels = backup.InitLabels;
            this.LoopLabels = backup.LoopLabels;

            this.OuterScopeSym = backup.OuterScopeSym;
            this.currentScopeSym = backup.currentScopeSym;
            this.innermostFinallyScopeSym = backup.innermostFinallyScopeSym;
            this.innermostTryScopeSym = backup.innermostTryScopeSym;
            this.innermostSwitchScopeSym = backup.innermostSwitchScopeSym;
            this.innermostCatchScopeSym = backup.innermostCatchScopeSym;

            this.currentBlockExpr = backup.currentBlockExpr;
            this.CurrentSwitchExpr = backup.CurrentSwitchExpr;

            this.thisPointerSym = backup.thisPointerSym;
            this.outerThisPointerSym = backup.outerThisPointerSym;

            this.uninitedVarCount = backup.uninitedVarCount;
            this.unreferencedVarCount = backup.unreferencedVarCount;
            this.finallyNestingCount = backup.finallyNestingCount;
            this.localCount = backup.localCount;
            this.firstParentOffset = backup.firstParentOffset;
            this.uniqueNameIndex = backup.uniqueNameIndex;
            this.errorsBeforeBind = backup.errorsBeforeBind;

            this.areForwardGotos = backup.areForwardGotos;
            this.unsafeErrorGiven = backup.unsafeErrorGiven;
            this.insideTryOfCatch = backup.insideTryOfCatch;

            this.lastNode = backup.lastNode;

            this.CheckedContext = backup.CheckedContext;

            this.userLabelList = backup.userLabelList;
            this.userLabelListLast = backup.userLabelListLast;
            this.gotoExprs = backup.gotoExprs;

            this.evaluatingFieldInitializer = backup.evaluatingFieldInitializer;
            this.determineImplicitTypeLater = backup.determineImplicitTypeLater;
        }
    } // internal class FUNCBREC

    //======================================================================
    // class ReachabilityChecker
    //======================================================================
    internal class ReachabilityChecker
    {
        //------------------------------------------------------------
        // ReachabilityChecker Fields and Properties
        //------------------------------------------------------------
        private COMPILER compiler = null;   // * m_comp;

        private COMPILER Compiler
        {
            get { return this.compiler; }   // compiler()
        }

        private bool hasReturnAsLeave = false;  // m_fHasRetAsLeave;

        internal bool HasReturnAsLeave
        {
            get { return this.hasReturnAsLeave; }   // HasRetAsLeave()
        }

        //------------------------------------------------------------
        // ReachabilityChecker Constructor
        //------------------------------------------------------------
        internal ReachabilityChecker(COMPILER comp)
        {
            compiler = comp;
        }

        //------------------------------------------------------------
        // ReachabilityChecker.SetReachability
        //
        /// <summary>
        /// <para>This:
        /// <list type="number">
        /// <item>Clears all reachability flags and
        /// sets parent information for the statements in the given block.</item>
        /// <item>Sets reachability information by scanning.</item>
        /// <item>Optionally reports warnings on unreachable code.</item>
        /// </list></para>
        /// </summary>
        /// <param name="block"></param>
        /// <param name="reportWarnings"></param>
        //------------------------------------------------------------
        internal void SetReachability(EXPRBLOCK block, bool reportWarnings)
        {
            DebugUtil.Assert(block.ParentStatement == null);
            DebugUtil.Assert(block.NextStatement == null);

            this.hasReturnAsLeave = false;
            block.ClearReachable();
            SetParents(block, block.StatementsExpr);
            MarkReachable(block);

            if (reportWarnings)
            {
                bool reachable = true;
                ReportUnreachable(block, ref reachable);
            }
            // DumpStmts(block, 0);
        }

        //------------------------------------------------------------
        // ReachabilityChecker.RealizeGoto
        //
        /// <summary>
        /// <para>Make sure the goto is realized.
        /// Also checks for jumping out of an anonymous method or finally block.</para>
        /// <para>If fFull is true, also makes sure the goto is marked
        /// with either EXF_FINALLYBLOCKED or EXF_GOTONOTBLOCKED.
        /// If fFull is false, this is being called just to report errors so checking
        /// whether a finally blocks the goto should not be done.</para>
        /// </summary>
        /// <param name="gotoExpr"></param>
        /// <param name="fFull"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal bool RealizeGoto(EXPRGOTO gotoExpr, bool fFull)
        {
            if ((gotoExpr.Flags & (EXPRFLAG.BADGOTO | EXPRFLAG.FINALLYBLOCKED)) != 0)
            {
                DebugUtil.Assert(
                    (gotoExpr.Flags & EXPRFLAG.UNREALIZEDGOTO) == 0 ||
                    (gotoExpr.Flags & EXPRFLAG.BADGOTO) != 0);
                return false;
            }
            if ((gotoExpr.Flags & EXPRFLAG.GOTONOTBLOCKED) != 0)
            {
                DebugUtil.Assert((gotoExpr.Flags & EXPRFLAG.UNREALIZEDGOTO) == 0);
                return true;
            }

            if ((gotoExpr.Flags & EXPRFLAG.UNREALIZEDGOTO) != 0)
            {
                LABELSYM targetLabelSym = null;

                if ((gotoExpr.Flags & EXPRFLAG.GOTOCASE) != 0)
                {
                    DebugUtil.Assert(gotoExpr.TargetScopeSym != null);
                    targetLabelSym = compiler.LocalSymbolManager.LookupLocalSym(
                        gotoExpr.LabelName,
                        gotoExpr.TargetScopeSym,
                        SYMBMASK.LABELSYM) as LABELSYM;
                }
                else
                {
                    for (SCOPESYM scope = gotoExpr.CurrentScopeSym;
                        scope != null;
                        scope = scope.ParentSym as SCOPESYM)
                    {
                        targetLabelSym = compiler.LocalSymbolManager.LookupLocalSym(
                            gotoExpr.LabelName,
                            scope,
                            SYMBMASK.LABELSYM) as LABELSYM;
                        if (targetLabelSym != null)
                        {
                            gotoExpr.TargetScopeSym = scope;
                            break;
                        }
                    }
                }

                if (targetLabelSym == null)
                {
                    compiler.Error(gotoExpr.TreeNode, CSCERRID.ERR_LabelNotFound, new ErrArg(gotoExpr.LabelName));
                    gotoExpr.Flags |= EXPRFLAG.UNREALIZEDGOTO | EXPRFLAG.BADGOTO;
                    return false;
                }
                gotoExpr.LabelExpr = targetLabelSym.LabelExpr;
                gotoExpr.Flags &= ~EXPRFLAG.UNREALIZEDGOTO;
                gotoExpr.LabelExpr.Flags |= EXPRFLAG.LABELREFERENCED;
            }

            DebugUtil.Assert((gotoExpr.Flags & (EXPRFLAG.BADGOTO | EXPRFLAG.UNREALIZEDGOTO)) == 0);
            DebugUtil.Assert((gotoExpr.TargetScopeSym == null) == (gotoExpr.CurrentScopeSym == null));

            if (gotoExpr.TargetScopeSym == null || gotoExpr.CurrentScopeSym == null)
            {
                // Not a user entered goto. Comes from an if, for, while, etc.
                gotoExpr.Flags |= EXPRFLAG.GOTONOTBLOCKED;
                return true;
            }

            // Check for jumping out of anon methods and finally blocks.
            for (SCOPESYM scope = gotoExpr.CurrentScopeSym;
                scope != gotoExpr.TargetScopeSym;
                scope = scope.ParentSym as SCOPESYM)
            {
                DebugUtil.Assert(scope != null);

                if ((scope.ScopeFlags & (SCOPEFLAGS.FINALLYSCOPE | SCOPEFLAGS.DELEGATESCOPE)) != 0)
                {
                    compiler.Error(gotoExpr.TreeNode,
                        (scope.ScopeFlags & SCOPEFLAGS.FINALLYSCOPE) != 0 ?
                        CSCERRID.ERR_BadFinallyLeave : CSCERRID.ERR_BadDelegateLeave);
                    gotoExpr.Flags |= EXPRFLAG.BADGOTO;
                    return false;
                }

                if ((scope.ScopeFlags & (SCOPEFLAGS.TRYSCOPE | SCOPEFLAGS.CATCHSCOPE)) != 0)
                {
                    gotoExpr.Flags |= EXPRFLAG.ASLEAVE;
                    if (scope.FinallyScopeSym != null)
                    {
                        gotoExpr.Flags |= EXPRFLAG.ASFINALLYLEAVE;
                    }
                }
            }
            DebugUtil.Assert((gotoExpr.Flags & (EXPRFLAG.BADGOTO | EXPRFLAG.UNREALIZEDGOTO)) == 0);

            // Determine whether there is a blocking finally.
            if ((gotoExpr.Flags & EXPRFLAG.ASFINALLYLEAVE) == 0)
            {
                gotoExpr.Flags |= EXPRFLAG.GOTONOTBLOCKED;
                return true;
            }

            if (!fFull) return false;

            for (EXPRSTMT parentStmt = gotoExpr.ParentStatement;
                parentStmt != gotoExpr.LabelExpr.ParentStatement;
                parentStmt = parentStmt.ParentStatement)
            {
                if (parentStmt == null)
                {
                    DebugUtil.Assert(false, "Why didn't we find the labels parent?");
                    break;
                }
                if (parentStmt.Kind == EXPRKIND.TRY &&
                    (parentStmt.Flags & EXPRFLAG.ISFINALLY) != 0 &&
                    (parentStmt as EXPRTRY).IsFinallyBlocked())
                {
                    gotoExpr.Flags |= EXPRFLAG.FINALLYBLOCKED;
                    return false;
                }
            }

            gotoExpr.Flags |= EXPRFLAG.GOTONOTBLOCKED;
            return true;
        }

        // This is valid after a call to SetReachability.

        //internal static void DumpStmts(EXPRSTMT * stmtFirst, int ctab);


        //------------------------------------------------------------
        // ReachabilityChecker.SetParents
        //
        /// <summary>
        /// Sets the parents information for the statement forest and
        /// clears all the reachability states.
        /// </summary>
        /// <param name="parentStatement"></param>
        /// <param name="firstStatement"></param>
        //------------------------------------------------------------
        private void SetParents(EXPRSTMT parentStatement, EXPRSTMT firstStatement)
        {
            for (EXPRSTMT stmt = firstStatement; stmt != null; stmt = stmt.NextStatement)
            {
                stmt.ClearReachable();
                stmt.ParentStatement = parentStatement;
                switch (stmt.Kind)
                {
                    case EXPRKIND.BLOCK:
                        SetParents(stmt, (stmt as EXPRBLOCK).StatementsExpr);
                        break;

                    case EXPRKIND.SWITCH:
                        SetParents(stmt, (stmt as EXPRSWITCH).BodiesExpr);
                        break;

                    case EXPRKIND.SWITCHLABEL:
                        SetParents(stmt, (stmt as EXPRSWITCHLABEL).StatementsExpr);
                        break;

                    case EXPRKIND.HANDLER:
                        SetParents(stmt, (stmt as EXPRHANDLER).HandlerBlock);
                        break;

                    case EXPRKIND.TRY:
                        SetParents(stmt, (stmt as EXPRTRY).TryBlockExpr);
                        SetParents(stmt, (stmt as EXPRTRY).HandlersExpr);
                        break;

                    default:
                        break;
                }
            }
        }

        //------------------------------------------------------------
        // ReachabilityChecker.MarkReachable
        //
        /// <summary>
        /// Mark the given statement as subsequent ones as reachable.
        /// When a statement previously marked reachable is encountered, this returns.
        /// </summary>
        /// <param name="statementExpr"></param>
        //------------------------------------------------------------
        private void MarkReachable(EXPRSTMT statementExpr)
        {
            if (statementExpr == null) return;

            EXPRLABEL topLabel = null;
            MarkReachableInner(statementExpr, ref topLabel);
            while (topLabel != null)
            {
                EXPRLABEL currentLabel = EXPRLABEL.PopFromStack(ref topLabel);

                // No switch labels should come through here.
                DebugUtil.Assert(currentLabel.Kind == EXPRKIND.LABEL);

                if (!currentLabel.Reachable())
                {
                    MarkReachableInner(currentLabel, ref topLabel);
                }
            }
        }

        //------------------------------------------------------------
        // ReachabilityChecker.MarkReachableInner
        //
        /// <summary>
        /// Mark the given statement as subsequent ones as reachable.
        /// When a statement previously marked reachable is encountered, this returns.
        /// </summary>
        /// <param name="statementExpr"></param>
        /// <param name="topLabeExpr"></param>
        //------------------------------------------------------------
        private void MarkReachableInner(EXPRSTMT statementExpr, ref EXPRLABEL topLabeExpr)
        {
            DebugUtil.Assert(statementExpr != null);
            for (; ; )
            {
                if (statementExpr.Reachable())
                {
                    return;
                }
                DebugUtil.Assert(!statementExpr.ReachableEnd());

                switch (statementExpr.Kind)
                {
                    default:
                    case EXPRKIND.HANDLER:
                        DebugUtil.Assert(false, "Bad stmt expr kind");
                        return;

                    case EXPRKIND.DELIM:
                    case EXPRKIND.NOOP:
                    case EXPRKIND.DEBUGNOOP:
                    case EXPRKIND.DECL:
                    case EXPRKIND.STMTAS:
                    case EXPRKIND.LABEL:
                        statementExpr.SetReachableEnd();
                        break;

                    case EXPRKIND.THROW:
                        statementExpr.SetReachable();
                        return;

                    case EXPRKIND.RETURN:
                        // Yield return has a reachable end. Other forms don't.
                        if ((statementExpr.Flags & EXPRFLAG.RETURNISYIELD) != 0 &&
                            (statementExpr as EXPRRETURN).ObjectExpr != null)
                        {
                            statementExpr.SetReachableEnd();
                            // Mark the SCOPESYMs.
                            for (SCOPESYM scope = (statementExpr as EXPRRETURN).CurrentScopeSym;
                                scope != null && (scope.ScopeFlags & SCOPEFLAGS.HASYIELDRETURN) == 0;
                                scope = scope.ParentSym as SCOPESYM)
                            {
                                scope.ScopeFlags |= SCOPEFLAGS.HASYIELDRETURN;
                            }
                        }
                        else
                        {
                            statementExpr.SetReachable();
                        }

                        if ((statementExpr.Flags & EXPRFLAG.ASLEAVE) != 0)
                        {
                            this.hasReturnAsLeave = true;

                            // Mark whether the return is blocked by a finally.
                            if ((statementExpr.Flags & EXPRFLAG.ASFINALLYLEAVE) != 0)
                            {
                                DebugUtil.Assert((statementExpr.Flags & EXPRFLAG.FINALLYBLOCKED) == 0);
                                for (EXPRSTMT parent = statementExpr.ParentStatement;
                                    parent != null;
                                    parent = parent.ParentStatement)
                                {
                                    if (parent.Kind == EXPRKIND.TRY &&
                                        (parent.Flags & EXPRFLAG.ISFINALLY) != 0 &&
                                        (parent as EXPRTRY).IsFinallyBlocked())
                                    {
                                        statementExpr.Flags |= EXPRFLAG.FINALLYBLOCKED;
                                        break;
                                    }
                                }
                            }
                        }
                        break;

                    case EXPRKIND.BLOCK:
                        if (!MarkBlock(statementExpr as EXPRBLOCK))
                        {
                            return;
                        }
                        break;

                    case EXPRKIND.GOTO:
                        statementExpr.SetReachable();
                        // Resolve and continue from the target.
                        if (RealizeGoto(statementExpr as EXPRGOTO, true))
                        {
                            DebugUtil.Assert((statementExpr.Flags & EXPRFLAG.GOTONOTBLOCKED) != 0);
                            statementExpr = (statementExpr as EXPRGOTO).LabelExpr;
                            continue;
                        }
                        DebugUtil.Assert((statementExpr.Flags & (EXPRFLAG.BADGOTO | EXPRFLAG.FINALLYBLOCKED)) != 0);
                        break;

                    case EXPRKIND.GOTOIF:
                        if ((statementExpr as EXPRGOTOIF).FNeverJumps())
                        {
                            // Just like a STMTAS.
                            statementExpr.SetReachableEnd();
                            RealizeGoto(statementExpr as EXPRGOTOIF, true);
                        }
                        else if ((statementExpr as EXPRGOTOIF).AlwaysJumps())
                        {
                            // Just like a GOTO.
                            statementExpr.SetReachable();
                            // Resolve and continue from the target.
                            if (RealizeGoto(statementExpr as EXPRGOTOIF, true))
                            {
                                statementExpr = (statementExpr as EXPRGOTOIF).LabelExpr;
                                continue;
                            }
                            DebugUtil.Assert((statementExpr.Flags & (EXPRFLAG.BADGOTO | EXPRFLAG.FINALLYBLOCKED)) != 0);
                        }
                        else
                        {
                            statementExpr.SetReachableEnd();
                            // Resolve and add the target to the label list.
                            if (RealizeGoto(statementExpr as EXPRGOTOIF, true))
                            {
                                // Don't mark the label's statement list now, but instead add it to the
                                // label list. This avoids nasty unbounded recursion.
                                EXPRLABEL currentLabel = (statementExpr as EXPRGOTOIF).LabelExpr;
                                if (!currentLabel.Reachable() && !currentLabel.InStack())
                                {
                                    currentLabel.PushOnStack(ref topLabeExpr);
                                }
                            }
                        }
                        break;

                    case EXPRKIND.SWITCH:
                        // Only a matching switch label is reachable. We put a goto before the switch
                        // to the label. Scanning from the goto should have already hit the target and closure.
                        DebugUtil.Assert((statementExpr as EXPRSWITCH).ArgumentExpr.Kind != EXPRKIND.CONSTANT);

                        if ((statementExpr.Flags & EXPRFLAG.HASDEFAULT) == 0)
                        {
                            statementExpr.SetReachableEnd();
                        }
                        else
                        {
                            statementExpr.SetReachable();
                        }

                        // All switch labels are reachable.
                        DebugUtil.Assert((statementExpr.Flags & EXPRFLAG.MARKING) == 0);
                        statementExpr.Flags |= EXPRFLAG.MARKING;

                        //EXPRSTMT * _nd = statementExpr.asSWITCH().bodies;
                        //while (_nd)
                        for (EXPRSTMT stmt = (statementExpr as EXPRSWITCH).BodiesExpr;
                            stmt != null;
                            stmt = stmt.NextStatement)
                        {
                            //EXPRSTMT * stmtChd = _nd;
                            //_nd = _nd->stmtNext;
                            EXPRSTMT stmtChd = stmt;
                            // These don't affect the reachable state of the switch since
                            // they all jump out of the switch to the break label.
                            MarkReachable(stmtChd);
                        }
                        DebugUtil.Assert((statementExpr.Flags & EXPRFLAG.MARKING) != 0);
                        statementExpr.Flags &= ~EXPRFLAG.MARKING;
                        break;

                    case EXPRKIND.SWITCHLABEL:
                        statementExpr.SetReachable();
                        if ((statementExpr as EXPRSWITCHLABEL).StatementsExpr != null)
                        {
                            DebugUtil.Assert((statementExpr.Flags & EXPRFLAG.MARKING) == 0);
                            statementExpr.Flags |= EXPRFLAG.MARKING;
                            MarkReachable((statementExpr as EXPRSWITCHLABEL).StatementsExpr);

                            DebugUtil.Assert(!statementExpr.ReachableEnd());
                            DebugUtil.Assert((statementExpr.Flags & EXPRFLAG.MARKING) != 0);

                            statementExpr.Flags &= ~EXPRFLAG.MARKING;
                        }
                        else if (statementExpr.NextStatement == null)
                        {
                            DebugUtil.Assert(false, "We should have put a NOOP in here!");
                            Compiler.Error(
                                statementExpr.TreeNode,
                                CSCERRID.ERR_SwitchFallThrough,
                                new ErrArg((statementExpr as EXPRSWITCHLABEL).LabelSym));
                            return;
                        }
                        else
                        {
                            // Just part of a switch label group. "Fall through" is legal.
                            statementExpr.SetReachableEnd();
                        }
                        break;

                    case EXPRKIND.TRY:
                        if ((statementExpr.Flags & EXPRFLAG.ISFINALLY) != 0)
                        {
                            statementExpr.SetReachableEnd();
                            // Must do the finally block first, since its reachability affects
                            // return statements and gotos inside the try block.
                            if (!MarkBlock((statementExpr as EXPRTRY).HandlersExpr as EXPRBLOCK))
                            {
                                statementExpr.ClearReachableEnd();
                            }
                            if (!MarkBlock((statementExpr as EXPRTRY).TryBlockExpr))
                            {
                                statementExpr.ClearReachableEnd();
                            }
                        }
                        else
                        {
                            statementExpr.SetReachable();
                            if (MarkBlock((statementExpr as EXPRTRY).TryBlockExpr))
                            {
                                statementExpr.SetReachableEnd();
                            }

                            // All handlers are reachable.
                            //EXPRSTMT * _nd = statementExpr.asTRY().handlers;
                            //while (_nd)
                            for (EXPRSTMT stmt = (statementExpr as EXPRTRY).HandlersExpr;
                                stmt != null;
                                stmt = stmt.NextStatement)
                            {
                                //EXPRSTMT * stmtChd = _nd;
                                //_nd = _nd->stmtNext;
                                EXPRSTMT stmtChd = stmt;
                                if (MarkBlock((stmtChd as EXPRHANDLER).HandlerBlock))
                                {
                                    stmtChd.SetReachableEnd();
                                    statementExpr.SetReachableEnd();
                                }
                                else
                                {
                                    stmtChd.SetReachable();
                                }
                            }
                        }
                        break;
                }

                if (!statementExpr.ReachableEnd()) return;

                if (statementExpr.NextStatement == null) break;
                statementExpr = statementExpr.NextStatement;
            }

            // We come here when the end of stmt is reachable and stmt is the end of a chain.
            // The reachability needs to be propogated to the parent.
            DebugUtil.Assert(
                statementExpr != null &&
                statementExpr.NextStatement == null &&
                statementExpr.ReachableEnd());

            EXPRSTMT parentStmt = statementExpr.ParentStatement;
            if (parentStmt == null)
            {
                return;
            }

            // We should be processing the parent somewhere up the stack.
            DebugUtil.Assert((parentStmt.Flags & EXPRFLAG.MARKING) != 0);

            switch (parentStmt.Kind)
            {
                default:
                case EXPRKIND.SWITCH:
                case EXPRKIND.HANDLER:
                case EXPRKIND.TRY:
                    DebugUtil.Assert(false, "Shouldn't get here!");
                    break;

                case EXPRKIND.BLOCK:
                    parentStmt.SetReachableEnd();
                    break;

                case EXPRKIND.SWITCHLABEL:
                    Compiler.Error(parentStmt.TreeNode, CSCERRID.ERR_SwitchFallThrough,
                        new ErrArg((parentStmt as EXPRSWITCHLABEL).LabelSym));
                    break;
            }
        }

        //------------------------------------------------------------
        // ReachabilityChecker.MarkBlock
        //
        /// <summary>
        /// Mark the block and contents as reachable. The end reachability is marked by the last child.
        /// </summary>
        /// <param name="blockExpr"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        internal bool MarkBlock(EXPRBLOCK blockExpr)
        {
            //If there is no block, let its end be reachable. This can happen when
            //working with a malformed parse tree while refactoring.
            if (blockExpr == null) return true;

            // If there are no statements, the end is reachable. Otherwise, the
            // recursive call to MarkReachable will set the reachability of the
            // end of the block.
            if (blockExpr.StatementsExpr == null)
            {
                blockExpr.SetReachableEnd();
                return true;
            }

            blockExpr.SetReachable();
            DebugUtil.Assert((blockExpr.Flags & EXPRFLAG.MARKING) == 0);
            blockExpr.Flags |= EXPRFLAG.MARKING;
            MarkReachable(blockExpr.StatementsExpr);
            DebugUtil.Assert((blockExpr.Flags & EXPRFLAG.MARKING) != 0);
            blockExpr.Flags &= ~EXPRFLAG.MARKING;

            return blockExpr.ReachableEnd();
        }

        //------------------------------------------------------------
        // ReachabilityChecker.ReportUnreachable
        //
        /// <summary>
        /// Report warnings on unreachable code.
        /// </summary>
        /// <param name="statementExpr"></param>
        /// <param name="isReachable"></param>
        //------------------------------------------------------------
        internal void ReportUnreachable(EXPRSTMT statementExpr, ref bool isReachable)
        {
            for (; statementExpr != null; statementExpr = statementExpr.NextStatement)
            {
                // See if the state is changing.
                if ((!isReachable) != (!statementExpr.Reachable()) &&
                    statementExpr.TreeNode != null &&
                    (statementExpr.Flags & EXPRFLAG.GENERATEDSTMT) == 0)
                {
                    switch (statementExpr.Kind)
                    {
                        default:
                            DebugUtil.Assert(false, "Bad statementExpr expr kind");
                            goto case EXPRKIND.SWITCHLABEL;

                        case EXPRKIND.BLOCK:
                        case EXPRKIND.DELIM:
                        case EXPRKIND.NOOP:
                        case EXPRKIND.DEBUGNOOP:
                        case EXPRKIND.LABEL:
                        case EXPRKIND.SWITCH:
                        case EXPRKIND.SWITCHLABEL:
                            // These don't really matter.
                            break;

                        case EXPRKIND.STMTAS:
                        case EXPRKIND.DECL:
                        case EXPRKIND.RETURN:
                        case EXPRKIND.THROW:
                        case EXPRKIND.GOTO:
                        case EXPRKIND.TRY:
                        case EXPRKIND.HANDLER:
                            // If we went from reachable to unreachable, warn.
                            if (isReachable)
                            {
                                compiler.Error(statementExpr.TreeNode, CSCERRID.WRN_UnreachableCode);
                            }
                            isReachable = !isReachable;
                            break;

                        case EXPRKIND.GOTOIF:
                            if (isReachable)
                            {
                                BASENODE errNode = statementExpr.TreeNode;
                                if (errNode != null && errNode.Kind == NODEKIND.DO && errNode.AsDO.ExpressionNode != null)
                                {
                                    errNode = errNode.AsDO.ExpressionNode;
                                }
                                compiler.Error(errNode, CSCERRID.WRN_UnreachableCode);
                            }
                            isReachable = !isReachable;
                            break;
                    }
                }

                switch (statementExpr.Kind)
                {
                    case EXPRKIND.BLOCK:
                        ReportUnreachable((statementExpr as EXPRBLOCK).StatementsExpr, ref isReachable);
                        break;

                    case EXPRKIND.SWITCH:
                        ReportUnreachable((statementExpr as EXPRSWITCH).BodiesExpr, ref isReachable);
                        break;

                    case EXPRKIND.SWITCHLABEL:
                        ReportUnreachable((statementExpr as EXPRSWITCHLABEL).StatementsExpr, ref isReachable);
                        break;

                    case EXPRKIND.HANDLER:
                        ReportUnreachable((statementExpr as EXPRHANDLER).HandlerBlock, ref isReachable);
                        break;

                    case EXPRKIND.TRY:
                        ReportUnreachable((statementExpr as EXPRTRY).TryBlockExpr, ref isReachable);
                        ReportUnreachable((statementExpr as EXPRTRY).HandlersExpr, ref isReachable);
                        break;

                    default:
                        break;
                }
            }
        }
    }

    //======================================================================
    // class FncBindUtil
    //======================================================================
    static internal class FncBindUtil
    {
        //------------------------------------------------------------
        // FncBindUtil.IsSameLocalOrField
        //
        /// <summary>
        /// check if two expressions are actually referring to the same local variable
        /// </summary>
        /// <param name-"expr1"></param>
        /// <param name-"expr2"></param>
        /// <returns></returns>
        //------------------------------------------------------------
        static internal bool IsSameLocalOrField(EXPR expr1, EXPR expr2)
        {
            if (expr1.Kind != expr2.Kind)
            {
                return false;
            }

            if (expr1.Kind == EXPRKIND.LOCAL)
            {
                return (expr1 as EXPRLOCAL).LocVarSym == (expr2 as EXPRLOCAL).LocVarSym;
            }
            if (expr1.Kind == EXPRKIND.FIELD)
            {
                EXPRFIELD fld1 = expr1 as EXPRFIELD;
                EXPRFIELD fld2 = expr2 as EXPRFIELD;

                // Must be the same field on the same type and
                // the objects must either both be null or be the same.

                return fld1.FieldWithType.FieldSym == fld2.FieldWithType.FieldSym &&
                    fld1.FieldWithType.AggTypeSym == fld2.FieldWithType.AggTypeSym &&
                    (fld1.ObjectExpr == null) == (fld2.ObjectExpr == null) &&
                    (fld1.ObjectExpr == null || IsSameLocalOrField(fld1.ObjectExpr, fld2.ObjectExpr));
            }
            return false;
        }

        //------------------------------------------------------------
        // FncBindUtil.EscapeChar
        //
        /// <summary>
        /// Assumes pDest is at least 2 chars wide
        /// </summary>
        /// <param name="builder"></param>
        /// <param name="src"></param>
        //------------------------------------------------------------
        static internal void EscapeChar(StringBuilder builder, char src)
        {
            switch (src)
            {
                case '\0':
                    builder.Append('\\');
                    builder.Append('0');
                    break;
                case '\'':
                    builder.Append('\\');
                    builder.Append('\'');
                    break;
                case '\"':
                    builder.Append('\\');
                    builder.Append('\"');
                    break;
                case '\\':
                    builder.Append('\\');
                    builder.Append('\\');
                    break;
                case '\a':
                    builder.Append('\\');
                    builder.Append('a');
                    break;
                case '\b':
                    builder.Append('\\');
                    builder.Append('b');
                    break;
                case '\f':
                    builder.Append('\\');
                    builder.Append('f');
                    break;
                case '\n':
                    builder.Append('\\');
                    builder.Append('n');
                    break;
                case '\r':
                    builder.Append('\\');
                    builder.Append('r');
                    break;
                case '\t':
                    builder.Append('\\');
                    builder.Append('t');
                    break;
                case '\v':
                    builder.Append('\\');
                    builder.Append('v');
                    break;
                default:
                    builder.Append(src);
                    break;
            }
        }

        //------------------------------------------------------------
        // FncBindUtil.SetDisposeScopeFlagInner
        //
        /// <summary></summary>
        /// <param name="scopeSym"></param>
        //------------------------------------------------------------
        static internal void SetDisposeScopeFlagInner(SCOPESYM scopeSym)
        {
            for (SYM child = scopeSym.FirstChildSym; child != null; child = child.NextSym)
            {
                if (child.IsSCOPESYM)
                {
                    (child as SCOPESYM).ScopeFlags |= SCOPEFLAGS.DISPOSESCOPE;
                    SetDisposeScopeFlagInner(child as SCOPESYM);
                }
            }
        }

        //------------------------------------------------------------
        // FncBindUtil.SetDisposeScopeFlag
        //
        /// <summary></summary>
        /// <param name="scopeSym"></param>
        //------------------------------------------------------------
        static internal void EraseDebugInfo(SCOPESYM scopeSym)
        {
            scopeSym.DebugStartBBlock = null;
            scopeSym.DebugEndBBlock = null;
            scopeSym.DebugStartOffset = 0;
            scopeSym.DebugEndOffset = 0;

            for (SYM sym = scopeSym.FirstChildSym; sym != null; sym = sym.NextSym)
            {
                switch (sym.Kind)
                {
                    case SYMKIND.LOCVARSYM:
                        LOCVARSYM loc = sym as LOCVARSYM;
                        loc.DegubBlockFirstUsed = null;
                        loc.DebugOffsetFirstUsed = 0;
                        loc.LocSlotInfo.TypeSym = null;
                        if ((scopeSym.ScopeFlags & SCOPEFLAGS.DISPOSESCOPE) == 0)
                        {
                            loc.LocSlotInfo.IsUsed = false;
                        }
                        break;

                    case SYMKIND.SCOPESYM:
                        EraseDebugInfo(sym as SCOPESYM);
                        break;

                    case SYMKIND.ANONSCOPESYM:
                    case SYMKIND.CACHESYM:
                    case SYMKIND.LABELSYM:
                        break;

                    default:
                        DebugUtil.VsFail("Unexpected sym kind");
                        break;
                }
            }
        }

        //------------------------------------------------------------
        // FncBindUtil.SetDisposeScopeFlag
        //
        /// <summary></summary>
        /// <param name="blockExpr"></param>
        //------------------------------------------------------------
        static internal void SetDisposeScopeFlag(EXPRBLOCK blockExpr)
        {
            SCOPESYM scopeSym = blockExpr.ScopeSym;
            while (scopeSym == null)
            {
                blockExpr = blockExpr.OwingBlockExpr;
                scopeSym = blockExpr.ScopeSym;
                DebugUtil.Assert(scopeSym != null);
            }

            for (SCOPESYM outerScopeSym = scopeSym;
                outerScopeSym != null;
                outerScopeSym = outerScopeSym.ParentSym as SCOPESYM)
            {
                outerScopeSym.ScopeFlags |= SCOPEFLAGS.DISPOSESCOPE;
            }

            SetDisposeScopeFlagInner(scopeSym);
        }
    }

    //======================================================================
    // class class CCompareSwitchLabels
    //
    /// <summary>
    /// <para>Derives from IComparer&lt;EXPRSWITCHLABEL&gt;</para>
    /// <para>Has Compare method which comparing two EXPRSWITCHLABEL instances.</para>
    /// </summary>
    //======================================================================
    internal class CCompareSwitchLabels : IComparer<EXPRSWITCHLABEL>
    {
        public int Compare(EXPRSWITCHLABEL e1, EXPRSWITCHLABEL e2)
        {
            return FUNCBREC.CompareSwitchLabels(e1, e2);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // funcbind.cpp
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////

    //static const WCHAR szOriginalPrefix[] = L"<>3__";
    //static const int cchOriginalPrefix = lengthof(szOriginalPrefix) - 1;

    //inline bool __fastcall FUNCBREC::hasThisPointer()
    //{
    //    return pMSym && !pMSym->isStatic && this->thisPointer;
    //}

    //======================================================================
    // class ARRAYFOREACHSLOT
    //======================================================================
    internal class ARRAYFOREACHSLOT
    {
        internal EXPRWRAP LimitWrapExpr = null;     // * limit;
        internal EXPRWRAP CurrentWrapExpr = null;   // * current;
        internal EXPRLABEL BodyLabelExpr = null;    // * body;
        internal EXPRLABEL TestLabelExpr = null;    // * test;
    }

    //bool FUNCBREC::isCastOrExpr(EXPR * search, EXPR * target)
    //{
    //AGAIN:
    //    if (search == target) return true;
    //
    //    if (search && search->kind == EK_CAST) {
    //        search = search->AsCAST->p1;
    //        goto AGAIN;
    //    }
    //
    //    return false;
    //}

    //LOCSLOTINFO * FUNCBREC::getThisPointerSlot()
    //{
    //    if (thisPointer) {
    //        return &(thisPointer->slot);
    //    } else {
    //        return NULL;
    //    }
    //}

    //SpecialNameKindEnum DecodeSpecialNameChar(WCHAR ch)
    //{
    //    SpecialNameKindEnum rval = SpecialNameKind::None;
    //    if (ch >= L'1' && ch <= L'9') {
    //        rval = (SpecialNameKindEnum) (SpecialNameKind::None + (ch - L'1') + 1);
    //    } else if (ch >= L'a' && ch <= L'f') {
    //        rval = (SpecialNameKindEnum) (SpecialNameKind::None + (ch - L'a') + 10);
    //    }
    //    if (rval < SpecialNameKind::None || rval > SpecialNameKind::LastKind) {
    //        rval = SpecialNameKind::None;
    //    }
    //    return rval;
    //}

    //SpecialNameKindEnum FUNCBREC::IsSpecialName(NAME * name)
    //{
    //    if (name->text[0] != L'<') return SpecialNameKind::None;
    //    const WCHAR * ptr = name->text + 1;
    //    while (*ptr != L'>' && *ptr != 0) {
    //        ptr ++;
    //    }
    //    if (*ptr != L'>') return SpecialNameKind::None;
    //    return DecodeSpecialNameChar(*(ptr + 1));
    //
    //}

    //NAME * FUNCBREC::GetDisplayNameOfPossibleSpecialName(NAME * specialName)
    //{
    //    if (specialName->text[0] != L'<') return specialName;
    //    const WCHAR * ptr = specialName->text + 1;
    //    const WCHAR * endPtr = ptr;
    //    while (*endPtr != L'>' && *endPtr != 0) {
    //        endPtr ++;
    //    }
    //    if (endPtr == ptr) return NULL;
    //    if (*endPtr != L'>') return specialName;
    //    return compiler()->getNamemgr()->AddString(ptr, (int)(endPtr - ptr));
    //}
}
